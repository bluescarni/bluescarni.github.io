<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Zig Zag Wanderer, Stuff of various degrees of importance">


        <title>Memory-friendly data structures in Piranha -Â 1/3 // Zig Zag Wanderer // Stuff of various degrees of importance</title>


    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.3.0/pure-min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.1.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/theme/css/pure.css">
    <link rel="stylesheet" href="/theme/css/pygments.css">

    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/fitvids/1.0.1/jquery.fitvids.min.js"></script>
    <script>
        $(document).ready(function(){
            $(".content").fitVids();
        });
    </script>
</head>

<body>
    <div class="pure-g-r" id="layout">
        <div class="sidebar pure-u">
            <div class="cover-img" style="background-image: url('https://raw.githubusercontent.com/bluescarni/site_source/master/side_pic.jpg')">
                <div class="cover-body">
                    <header class="header">
                        <hgroup>
                            <h1 class="brand-main"><a href="">Zig Zag Wanderer</a></h1>
                            <p class="tagline">Stuff of various degrees of importance</p>
                                <p class="links"><a href="/pages/about-me.html">About</a></p>
                                <p class="links"><a href="/pages/research.html">Research</a></p>
                                <p class="links"><a href="/pages/software.html">Software</a></p>
                                <p class="social">
                                    <a href="https://github.com/bluescarni/">
                                        <i class="fa fa-github fa-3x"></i>
                                    </a>
                                </p>
                        </hgroup>
                    </header>
                </div>
            </div>
        </div>
    <div class="pure-u">
        <div class="content">
            <section class="post">
                <header class="post-header">
                    <h1>Memory-friendly data structures in Piranha -&nbsp;1/3</h1>
                        <p class="post-meta">
                            // under                                 <a class="post-category" href="/tag/c.html">c++</a>
                                <a class="post-category" href="/tag/coding.html">coding</a>
                                <a class="post-category" href="/tag/piranha.html">piranha</a>
                        </p>
                </header>
            </section>
            <div class="section" id="introduction">
<h2>Introduction</h2>
<p>A significant trend in the evolution of computer hardware over the past few decades
is the so-called <a class="reference external" href="https://en.wikipedia.org/wiki/Random-access_memory#Memory_wall">memory wall</a>. This term commonly designates the growing discrepancy between
the speed of the <span class="caps">CPU</span> and the speed of <span class="caps">RAM</span>: whereas <span class="caps">CPU</span> performance has kept a steady growth,
the speed of <span class="caps">RAM</span> has increased at a much slower pace. As a consequence, modern CPUs can end
up spending most of the time waiting for data to be delivered from the main memory (instead
of doing useful&nbsp;work).</p>
<p>One of the approaches adopted by hardware manufacturers to ameliorate the memory wall problem
is that of equipping CPUs with <a class="reference external" href="https://en.wikipedia.org/wiki/CPU_cache">cache memory</a>. Cache memory is very fast (but very
expensive and very small) memory residing directly on the <span class="caps">CPU</span>. Accessing data from the cache can be
orders of magnitudes faster than loading data from <span class="caps">RAM</span>, and modern CPUs typically feature
a complex multi-level hierarchy of caches. The efficient
exploitation of the memory hierarchy has become today a fundamental aspect of performance&nbsp;optimisation.</p>
<p>Although the implementation details of cache memory hierarchies vary across CPUs, there are
two fundamental ideas that are broadly&nbsp;applicable:</p>
<ul class="simple">
<li><em>temporal locality</em>: when data is loaded from <span class="caps">RAM</span> into the cache memory, it will be kept
in the cache for some time (typically until it gets kicked out to make room for other data).
It is thus important, once the data is in the cache, to try to run any computation that needs
that data as soon as possible. It would be a waste to have the data removed from the cache,
only to reload it later from <span class="caps">RAM</span> for further&nbsp;processing;</li>
<li><em>spatial locality</em>: loading data from <span class="caps">RAM</span> into the cache typically proceeds by chunks. If
some data is loaded from <span class="caps">RAM</span>, it is likely that also other contiguous data will
be loaded in the cache at the same time. Memory structures, such as C arrays and C++ vectors,
that store data contiguously are, in this sense, cache-friendly: by paying the price
of loading an element of the vector into the cache, you also get a bunch of nearby elements
for&nbsp;free.</li>
</ul>
<p>It is important to note that not all computational workloads benefit from cache-friendly
algorithms and data structures. An example in scientific computing is that of numerical
integration of ODEs, which essentially consists of an iterative loop in which the state of
the system is continuously updated. Normally, the ratio between the time spent moving and managing data
(i.e., the state vector) and actually doing computations with that data is very small, and all the
data needed for the computation fits in the cache&nbsp;memory.</p>
<p>On the other hand, algorithms that employ large data structures can be particularly vulnerable to
the memory wall. A classical example is linear algebra: when matrices and vectors are larger
than the available cache memory, it becomes crucial to employ optimisations such as
<a class="reference external" href="https://en.wikipedia.org/wiki/Loop_nest_optimization">loop tiling</a> in order to promote temporal locality and make sure that as much computation as possible
is performed on data currently residing in&nbsp;cache.</p>
<p>Sparse data structures are also problematic. In this context, with the admittedly-fuzzy &quot;sparse&quot; moniker
I mean structures which feature one or more of the&nbsp;following:</p>
<ul class="simple">
<li>frequent allocation of dynamic&nbsp;memory,</li>
<li>non-contiguous data storage and/or&nbsp;traversal,</li>
<li>pointer&nbsp;chasing.</li>
</ul>
<p>Trees, lists, hash tables, and many other data structures can be considered sparse according to this
definition (at least in their most common implementations). The biggest problem with sparse structures is
that the memory access pattern is unpredictable, and spatial locality is not&nbsp;promoted.</p>
<p>One of the main focuses of <a class="reference external" href="https://github.com/bluescarni/piranha">Piranha</a> is the manipulation of very large algebraic objects, such as multivariate
polynomials and Poisson series, commonly encountered in celestial mechanics.
This is a computational workload in which large amounts of data are generated
quickly from small input data. Take for instance the following symbolic&nbsp;multiplication:</p>
<div class="math">
\begin{equation*}
\left(1+x+y+2z^2+3t^3+5u^5\right)^{12} \times \left(1+u+t+2z^2+3y^3+5x^5\right)^{12}.
\end{equation*}
</div>
<p>Each multiplicand is a sparse multivariate polynomial with 6188 terms. The result, once fully expanded, will have 5821335 terms,
thus requiring circa 1000 times the storage space of each multiplicand. Additionally, storage schemes for multivariate polynomial
are typically sparse (dense storage is often appropriate for univariate polynomials, but it tends to be impractical
for multivariate polynomials). Efficient exploitation of the memory hierarchy is thus one of the primary focuses (and sources of
complications) in&nbsp;Piranha.</p>
<p>In this series of posts, I will detail some of the strategies adopted in Piranha in order to maximise spatial locality. Specifically,
I will be focusing on three foundational&nbsp;components:</p>
<ul class="simple">
<li>an arbitrary-precision integer&nbsp;class,</li>
<li>a small vector&nbsp;class,</li>
<li>a cache-friendly hash&nbsp;set.</li>
</ul>
<p>The main theme in all three cases is that of minimising dynamic memory&nbsp;allocation.</p>
</div>
<div class="section" id="the-integer-class">
<h2>The <tt class="docutils literal">integer</tt> class</h2>
<p>Piranha, like most computer algebra systems, provides an arbitrary-precision integral type, surprisingly called <tt class="docutils literal">integer</tt>.
As the name suggests, and contrary to the builtin C++ integral types, <tt class="docutils literal">integer</tt> can represent any finite signed integral value, provided
enough memory is&nbsp;available.</p>
<p>The gold standard in arbitrary-precision arithmetic is the <a class="reference external" href="https://gmplib.org/"><span class="caps">GMP</span> library</a>, and most computer algebra libraries end up wrapping the
<span class="caps">GMP</span> <tt class="docutils literal">mpz_t</tt> struct, in one form or another. Piranha is no exception, and <tt class="docutils literal">integer</tt> is indeed (at least in part) a wrapped <tt class="docutils literal">mpz_t</tt>.</p>
<p>One of the problems of the <tt class="docutils literal">mpz_t</tt> type is that <em>any</em> correctly initialised <tt class="docutils literal">mpz_t</tt> ends up allocating dynamic memory, even if the
stored value is zero or if it fits in one of the standard integral C++ types. This is not much of a concern when one is using <span class="caps">GMP</span> to do computations
on gigantic integers, but it can be a problem when <tt class="docutils literal">mpz_t</tt> is used to represent many not-so-large coefficients in a sparse multivariate
polynomial (a typical occurrence in celestial mechanics computations). As explained above, dynamic memory allocation can be very detrimental
to the performance of the memory&nbsp;subsystem.</p>
<p>The <tt class="docutils literal">integer</tt> class in Piranha adopts then a small-value optimisation: if the value stored in the <tt class="docutils literal">integer</tt> is not too large, it will be
stored directly in the static memory provided by the class itself, thus avoiding any dynamic allocation. When the stored value becomes large
enough, the storage will be switched to a normal <tt class="docutils literal">mpz_t</tt> struct.</p>
<p>There are many ways in which the small-value optimisation can be implemented, with different trade-offs between raw performance, memory utilisation
and standard compliance. The solution adopted in Piranha aims to be fully standard-conforming, and exploits the capabilities of the new <a class="reference external" href="https://en.wikipedia.org/wiki/C%2B%2B11#Unrestricted_unions">unrestricted unions</a>
available in&nbsp;C++11.</p>
<div class="section" id="anatomy-of-an-mpz-t">
<h3>Anatomy of an <tt class="docutils literal">mpz_t</tt></h3>
<p>A <span class="caps">GMP</span> <tt class="docutils literal">mpz_t</tt> is, conceptually, rather simple. On my computer, the struct is defined&nbsp;as:</p>
<div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">_mp_alloc</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_mp_size</span><span class="p">;</span>
    <span class="kt">mp_limb_t</span> <span class="o">*</span><span class="n">_mp_d</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__mpz_struct</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">__mpz_struct</span> <span class="kt">mpz_t</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</pre></div>
<p>(so <tt class="docutils literal">mpz_t</tt> is actually an array of size 1 of <tt class="docutils literal">__mpz_struct</tt> - this is a common technique used to pass by reference in&nbsp;C)</p>
<p>The exact types contained in the structure will vary across platforms, but the general idea is the&nbsp;following:</p>
<ul class="simple">
<li><tt class="docutils literal">_mp_alloc</tt> is a non-negative integral representing how many limbs are allocated. In an initialised <tt class="docutils literal">mpz_t</tt>, <tt class="docutils literal">_mp_alloc</tt> is never&nbsp;zero;</li>
<li><tt class="docutils literal">_mp_size</tt> is an integral corresponding to the number of limbs used to represent the value. If <tt class="docutils literal">_mp_size</tt> is zero,
then the stored value is zero, if <tt class="docutils literal">_mp_size</tt> is positive then the stored value is positive, and if <tt class="docutils literal">_mp_size</tt> is negative then the stored value
is negative. The absolute value of <tt class="docutils literal">_mp_size</tt> is never greater than <tt class="docutils literal">_mp_alloc</tt>;</li>
<li><tt class="docutils literal">_mp_d</tt> is a pointer to a dynamically-allocated array of&nbsp;limbs.</li>
</ul>
<p>In the <span class="caps">GMP</span> jargon, a limb is an unsigned integral value (typically of type <tt class="docutils literal">unsigned long</tt> or <tt class="docutils literal">unsigned long long</tt>)
which represents a &quot;chunk&quot; of the number in binary form (exactly in the same way as a digit from 0 to 9 represents a chunk of a number in decimal form).
The least significant chunks of a number are stored first in an <tt class="docutils literal">mpz_t</tt>.</p>
<p>As an example, consider the number -173, which is represented in binary&nbsp;as</p>
<div class="math">
\begin{equation*}
-10101101.
\end{equation*}
</div>
<p>On a hypothetical 4-bit architecture, we can divide the absolute value of this number into the two 4-bit&nbsp;limbs:</p>
<div class="math">
\begin{equation*}
\left[ 1101, 1010 \right].
\end{equation*}
</div>
<p>Notice how the least-significant chunk, 1101, is stored first. Then a valid <tt class="docutils literal">mpz_t</tt> representation of this number will have <tt class="docutils literal">_mp_alloc</tt> set to at least 2, <tt class="docutils literal">_mp_size</tt>
will be set to -2 (as the number is negative), and <tt class="docutils literal">_mp_d</tt> will be a pointer to a dynamically allocated array of limbs of size <tt class="docutils literal">_mp_alloc</tt> containing the values 13
(which is 1101 in decimal form) and 10 (which is 1010 in decimal form). The absolute value of the number can be reconstructed from the limbs via additions and multiplications
by powers of&nbsp;two:</p>
<div class="math">
\begin{equation*}
173 = 13 + 10 \cdot 2^4.
\end{equation*}
</div>
</div>
<div class="section" id="a-static-counterpart-to-mpz-t">
<h3>A static counterpart to <tt class="docutils literal">mpz_t</tt></h3>
<p>In order to implement the small-value optimisation, Piranha first introduces a class called <tt class="docutils literal">static_integer</tt> which looks more or less like&nbsp;this:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">static_integer</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">_mp_alloc</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_mp_size</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">mp_limb_t</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">m_limbs</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>(this is a simplified version, the real logic in the selection of the types in the class is more complicated - but this is not relevant for this&nbsp;discussion)</p>
<p><tt class="docutils literal">static_integer</tt> looks very similar to <tt class="docutils literal">mpz_t</tt>: the first two members are the same, but the third member has now become an <tt class="docutils literal"><span class="pre">std::array</span></tt> of 2 limbs.
The <tt class="docutils literal">m_limbs</tt> member will be used to store values whose magnitude is not greater than two limbs (e.g., on a 64-bit architecture <tt class="docutils literal">static_integer</tt> can store
absolute values from <span class="math">\(0\)</span> to <span class="math">\(2^{128} - 1\)</span>). The important point  is that <tt class="docutils literal"><span class="pre">std::array</span></tt> does not allocate dynamic memory, and thus operating on a <tt class="docutils literal">static_integer</tt>
is more cache-friendly than operating on an <tt class="docutils literal">mpz_t</tt>: there is no pointer chasing, and a single memory load will probably be enough to transfer the data from <span class="caps">RAM</span>
into the&nbsp;cache.</p>
<p>On its own, the <tt class="docutils literal">static_integer</tt> class has a limited range and it is not very useful: we have merely extended the numerical range with respect to the
builtin C++ integral types. We will need to couple it to an <tt class="docutils literal">mpz_t</tt> in order to create a true multiprecision&nbsp;integer.</p>
</div>
<div class="section" id="merging-static-and-dynamic">
<h3>Merging static and&nbsp;dynamic</h3>
<p>Now comes the crucial part. We need to merge in a single entity the <tt class="docutils literal">mpz_t</tt> struct and <tt class="docutils literal">static_integer</tt>: as long as the value we are representing is sufficiently
small, we will be exploiting the inline storage of <tt class="docutils literal">static_integer</tt>; when the value becomes too large, we will switch to the dynamic storage of a standard <tt class="docutils literal">mpz_t</tt>.</p>
<p>The natural tool to implement this merged entity is, in C++, a <a class="reference external" href="https://en.wikipedia.org/wiki/Union_type">union</a>. Before C++11, unions used to be fairly limited. Specifically, it was not possible to store
in a union any non-<a class="reference external" href="http://en.cppreference.com/w/cpp/concept/PODType"><span class="caps">POD</span></a> (plain old data) type. In C++11, this restriction has been&nbsp;lifted.</p>
<p>The merged union in Piranha&#8217;s <tt class="docutils literal">integer</tt> type looks simply like&nbsp;this:</p>
<div class="highlight"><pre><span class="k">union</span> <span class="n">integer_union</span>
<span class="p">{</span>
    <span class="n">static_integer</span> <span class="n">m_st</span><span class="p">;</span>
    <span class="n">__mpz_struct</span> <span class="n">m_dy</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>The management of a union in C/C++ rests completely on the shoulders of the developer. For instance, the developer must manually call the constructors and destructors
of the union members whenever it is needed to switch from one active member to the other (in C, it is sufficient to write into a member to make that member&nbsp;active).</p>
<p>Additionally, there is no way specified by the language to detect which element
of the union is the active one. It is thus common to include the union as a member of a wrapping class which adds an extra member representing which element
of the union is currently active. According to this model, the <tt class="docutils literal">integer</tt> class would then look like&nbsp;this:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">integer</span>
<span class="p">{</span>
    <span class="n">integer_union</span> <span class="n">m_union</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">m_tag</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>The <tt class="docutils literal">m_tag</tt> member will be used to record which of the two members of the union is currently active. The developer has to take care of updating the tag each time
the active member of the union is&nbsp;switched.</p>
<p>It turns out that in this specific case we can avoid adding such a tagging member (which adds a noticeable size overhead due to padding).
The <tt class="docutils literal">integer</tt> class exploits a special rule in the standard (section 9.2) which essentially
states the following: if the members of a union share a common initial sequence of members, then it is legal to access such initial sequence from any member of the union (note
that the actual rule is slightly more complicated, but it does not matter here). <tt class="docutils literal">static_integer</tt> and the <tt class="docutils literal">mpz_t</tt> struct do indeed share such a common initial&nbsp;sequence:</p>
<div class="highlight"><pre><span class="kt">int</span> <span class="n">_mp_alloc</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">_mp_size</span><span class="p">;</span>
</pre></div>
<p>These two members are present at the beginning of both <tt class="docutils literal">static_integer</tt> and <tt class="docutils literal">mpz_t</tt>. Under the special rule quoted above, the following is then&nbsp;legal:</p>
<div class="highlight"><pre><span class="n">integer_union</span> <span class="n">u</span><span class="p">;</span> <span class="c1">// This will intialise either the static or the dynamic member,</span>
                 <span class="c1">// depending on the default constructor of the union.</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">u</span><span class="p">.</span><span class="n">m_st</span><span class="p">.</span><span class="n">_mp_alloc</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">u</span><span class="p">.</span><span class="n">m_dy</span><span class="p">.</span><span class="n">_mp_alloc</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</pre></div>
<p>That is, we can access the <tt class="docutils literal">_mp_alloc</tt> member common to both elements of the union either from <tt class="docutils literal">m_st</tt> or <tt class="docutils literal">m_dy</tt>, and we will fetch exactly the same&nbsp;value.</p>
<p>If now we recall that <tt class="docutils literal">_mp_alloc</tt> is guaranteed to be nonzero in a correctly initialised <tt class="docutils literal">mpz_t</tt>, it should be evident that we can
use the <tt class="docutils literal">_mp_alloc</tt> member as our tagging mechanism, instead of an ad-hoc <tt class="docutils literal">m_tag</tt> member: if <tt class="docutils literal">_mp_alloc</tt> is zero, then the active member of the union is
the <tt class="docutils literal">static_integer</tt>, otherwise the active member is the <tt class="docutils literal">mpz_t</tt>. This allows us to roll the tagging mechanism directly into the union, and to save memory&nbsp;space.</p>
</div>
<div class="section" id="bells-and-whistles">
<h3>Bells and&nbsp;whistles</h3>
<p>Now that the basic principles are laid out, we can take a brief look at some of the basic functionality in the <tt class="docutils literal">integer_union</tt> object. Let us start by introducing
a convenience method to determine which union member is currently&nbsp;active:</p>
<div class="highlight"><pre><span class="kt">bool</span> <span class="n">is_static</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">m_st</span><span class="p">.</span><span class="n">_mp_alloc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>As explained above, we have adopted the convention that if the <tt class="docutils literal">_mp_alloc</tt> member is zero then <tt class="docutils literal">static_integer</tt> is active. We can inspect the <tt class="docutils literal">_mp_alloc</tt> member
via both <tt class="docutils literal">m_st</tt> and <tt class="docutils literal">m_dy</tt>, thanks to the special rule involving common initial sequences in union members. Easy&nbsp;peasy.</p>
<p>It is convenient to provide two getters that check, via assertions on <tt class="docutils literal">is_static()</tt>, whether we are accessing the active member or&nbsp;not:</p>
<div class="highlight"><pre><span class="n">static_integer</span> <span class="o">&amp;</span><span class="n">g_st</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">is_static</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">m_st</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__mpz_struct</span> <span class="o">&amp;</span><span class="n">g_dy</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">is_static</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">m_dy</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>(I have omitted the <tt class="docutils literal">const</tt> counterparts for brevity) Now, in debug builds, the assertions will fire if we are accessing the inactive union member via
<tt class="docutils literal">g_st()</tt> or <tt class="docutils literal">g_dy()</tt>.</p>
<p>Next, the default constructor for the&nbsp;union:</p>
<div class="highlight"><pre><span class="n">integer_union</span><span class="p">()</span><span class="o">:</span><span class="n">m_st</span><span class="p">()</span> <span class="p">{}</span>
</pre></div>
<p>Pretty straightforward: a default-constructed union will activate the static member via the default constructor of <tt class="docutils literal">static_integer</tt>.</p>
<p>The copy constructor is more&nbsp;interesting:</p>
<div class="highlight"><pre><span class="n">integer_union</span><span class="p">(</span><span class="k">const</span> <span class="n">integer_union</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">is_static</span><span class="p">())</span> <span class="p">{</span>
        <span class="o">::</span><span class="k">new</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_st</span><span class="p">))</span> <span class="n">static_integer</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">g_st</span><span class="p">());</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="o">::</span><span class="k">new</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_dy</span><span class="p">))</span> <span class="n">__mpz_struct</span><span class="p">;</span>
        <span class="o">::</span><span class="n">mpz_init_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_dy</span><span class="p">,</span><span class="o">&amp;</span><span class="n">other</span><span class="p">.</span><span class="n">g_dy</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Here we need first to determine whether <tt class="docutils literal">other</tt> is stored in static storage or not, and then we initialise the union accordingly. We need to use the placement <tt class="docutils literal">new</tt> syntax
in order to construct either a <tt class="docutils literal">static_integer</tt> or an <tt class="docutils literal">__mpz_struct</tt> at the address of either union member. In case <tt class="docutils literal">other</tt> is storing an <tt class="docutils literal">__mpz_struct</tt>, we also need
to call the <span class="caps">GMP</span> function <tt class="docutils literal">mpz_init_set()</tt> in order to copy-initialise the dynamic member with the contents of <tt class="docutils literal">other</tt>. Note that here the&nbsp;line</p>
<div class="highlight"><pre><span class="o">::</span><span class="k">new</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_dy</span><span class="p">))</span> <span class="n">__mpz_struct</span><span class="p">;</span>
</pre></div>
<p>is most likely superfluous: <tt class="docutils literal">__mpz_struct</tt> is a C struct, thus its lifetime officially begins in the following line, where we write
into <tt class="docutils literal">m_dy</tt> via the <span class="caps">GMP</span> function. The line above will be optimised out by the compiler, but I like to keep it in the source code for consistency and to remind myself
of how unrestricted unions are supposed to work in the general&nbsp;case.</p>
<p>The move&nbsp;constructor:</p>
<div class="highlight"><pre><span class="n">integer_union</span><span class="p">(</span><span class="n">integer_union</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">is_static</span><span class="p">())</span> <span class="p">{</span>
        <span class="o">::</span><span class="k">new</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_st</span><span class="p">))</span> <span class="n">static_integer</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">g_st</span><span class="p">()));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="o">::</span><span class="k">new</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_dy</span><span class="p">))</span> <span class="n">__mpz_struct</span><span class="p">;</span>
        <span class="n">move_ctor_mpz</span><span class="p">(</span><span class="n">m_dy</span><span class="p">,</span><span class="n">other</span><span class="p">.</span><span class="n">g_dy</span><span class="p">());</span>
        <span class="c1">// Downgrade the other to an empty static.</span>
        <span class="n">other</span><span class="p">.</span><span class="n">g_dy</span><span class="p">().</span><span class="o">~</span><span class="n">__mpz_struct</span><span class="p">();</span>
        <span class="o">::</span><span class="k">new</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="p">.</span><span class="n">m_st</span><span class="p">))</span> <span class="n">static_integer</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Here <tt class="docutils literal">move_ctor_mpz()</tt> is a helper function that performs a shallow copy from one <tt class="docutils literal">__mpz_struct</tt> to&nbsp;another:</p>
<div class="highlight"><pre><span class="kt">void</span> <span class="nf">move_ctor_mpz</span><span class="p">(</span><span class="n">__mpz_struct</span> <span class="o">&amp;</span><span class="n">to</span><span class="p">,</span> <span class="n">__mpz_struct</span> <span class="o">&amp;</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">to</span><span class="p">.</span><span class="n">_mp_alloc</span> <span class="o">=</span> <span class="n">from</span><span class="p">.</span><span class="n">_mp_alloc</span><span class="p">;</span>
    <span class="n">to</span><span class="p">.</span><span class="n">_mp_size</span> <span class="o">=</span> <span class="n">from</span><span class="p">.</span><span class="n">_mp_size</span><span class="p">;</span>
    <span class="n">to</span><span class="p">.</span><span class="n">_mp_d</span> <span class="o">=</span> <span class="n">from</span><span class="p">.</span><span class="n">_mp_d</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>The move constructor follows the same pattern as the copy constructor. One difference is that if <tt class="docutils literal">other</tt> is dynamic, then we must make
sure that, after the move, <tt class="docutils literal">other</tt> is still in a valid state (in this context, we consider an object in a <em>valid</em> state if it is destructible
and assignable). Indeed the members of <tt class="docutils literal">other.m_dy</tt> have been copied over to <tt class="docutils literal">this</tt>, which, in particular, is now managing the pointer to the
dynamically allocated array of limbs in the <tt class="docutils literal">__mpz_struct</tt> of <tt class="docutils literal">other</tt>. In order to leave <tt class="docutils literal">other</tt> in a valid state, we first destroy its dynamic member&nbsp;with</p>
<div class="highlight"><pre><span class="n">other</span><span class="p">.</span><span class="n">g_dy</span><span class="p">().</span><span class="o">~</span><span class="n">__mpz_struct</span><span class="p">();</span>
</pre></div>
<p>and then we construct an empty <tt class="docutils literal">static_integer</tt> with</p>
<div class="highlight"><pre><span class="o">::</span><span class="k">new</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="p">.</span><span class="n">m_st</span><span class="p">))</span> <span class="n">static_integer</span><span class="p">();</span>
</pre></div>
<p>Now <tt class="docutils literal">other</tt> has been switched over to static storage and it is in a well-defined valid&nbsp;state.</p>
<p>The destructor of <tt class="docutils literal">integer_union</tt> is straightforwardly implemented&nbsp;as:</p>
<div class="highlight"><pre><span class="o">~</span><span class="n">integer_union</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_static</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">g_st</span><span class="p">().</span><span class="o">~</span><span class="n">static_integer</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="o">::</span><span class="n">mpz_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_dy</span><span class="p">());</span>
        <span class="n">m_dy</span><span class="p">.</span><span class="o">~</span><span class="n">__mpz_struct</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>That is, if the storage is static, call the destructor of <tt class="docutils literal">static_integer</tt>, otherwise first clear (via <tt class="docutils literal">mpz_clear()</tt>) and then destroy the <tt class="docutils literal">__mpz_struct</tt>.
Here, again, the&nbsp;line</p>
<div class="highlight"><pre><span class="n">m_dy</span><span class="p">.</span><span class="o">~</span><span class="n">__mpz_struct</span><span class="p">();</span>
</pre></div>
<p>is superfluous and it will be optimised out by the&nbsp;compiler.</p>
<p>As a last example, let us take a look at the copy assignment&nbsp;operator:</p>
<div class="highlight"><pre><span class="n">integer_union</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">integer_union</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="kt">bool</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">is_static</span><span class="p">(),</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">is_static</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s1</span> <span class="o">&amp;&amp;</span> <span class="n">s2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">g_st</span><span class="p">()</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">g_st</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">s2</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Destroy static.</span>
        <span class="n">g_st</span><span class="p">().</span><span class="o">~</span><span class="n">static_integer</span><span class="p">();</span>
        <span class="c1">// Construct the dynamic struct.</span>
        <span class="o">::</span><span class="k">new</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_dy</span><span class="p">))</span> <span class="n">__mpz_struct</span><span class="p">;</span>
        <span class="c1">// Init + assign the mpz.</span>
        <span class="o">::</span><span class="n">mpz_init_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_dy</span><span class="p">,</span><span class="o">&amp;</span><span class="n">other</span><span class="p">.</span><span class="n">g_dy</span><span class="p">());</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s1</span> <span class="o">&amp;&amp;</span> <span class="n">s2</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Destroy the dynamic this.</span>
        <span class="o">::</span><span class="n">mpz_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_dy</span><span class="p">());</span>
        <span class="n">m_dy</span><span class="p">.</span><span class="o">~</span><span class="n">__mpz_struct</span><span class="p">();</span>
        <span class="c1">// Init-copy the static from other.</span>
        <span class="o">::</span><span class="k">new</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_st</span><span class="p">))</span> <span class="n">static_integer</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">g_st</span><span class="p">());</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="o">::</span><span class="n">mpz_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_dy</span><span class="p">(),</span><span class="o">&amp;</span><span class="n">other</span><span class="p">.</span><span class="n">g_dy</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>This code is noticeably more complex than the constructors. After the customary check for self-assignment, we need to distinguish four&nbsp;cases:</p>
<ol class="arabic simple">
<li>both <tt class="docutils literal">this</tt> and <tt class="docutils literal">other</tt> use static&nbsp;storage,</li>
<li><tt class="docutils literal">this</tt> uses static storage, <tt class="docutils literal">other</tt> uses dynamic&nbsp;storage,</li>
<li><tt class="docutils literal">this</tt> uses dynamic storage, <tt class="docutils literal">other</tt> uses static&nbsp;storage,</li>
<li>both <tt class="docutils literal">this</tt> and <tt class="docutils literal">other</tt> use dynamic&nbsp;storage.</li>
</ol>
<p>When the storage types differ, we will need to switch <tt class="docutils literal">this</tt> to the storage type of <tt class="docutils literal">other</tt>.
This is accomplished by manually calling the destructors and constructors of the union members, similarly to how it is done in the constructors
of the union. Otherwise, we can perform a direct assignment, either via the copy assignment operator of <tt class="docutils literal">static_integer</tt> or the <span class="caps">GMP</span> function
<tt class="docutils literal">mpz_set()</tt>.</p>
<p>The complexity in the assignment operator derives from the fact that it is a binary operation. If we had to code a ternary operation,
we would need to handle <span class="math">\(2^3=8\)</span> different cases. Thankfully, ternary operations are exceedingly&nbsp;rare.</p>
</div>
<div class="section" id="performance-measurements">
<h3>Performance&nbsp;measurements</h3>
<p>In order to evaluate the performance impact of the small integer optimisation, I will use a slightly modified version of a <a class="reference external" href="https://github.com/bluescarni/piranha/blob/master/tests/pearce2_perf.cpp">benchmark</a> available
in Piranha&#8217;s test suite.&nbsp;Given</p>
<div class="math">
\begin{equation*}
f = \left(1+x+y+2z^2+3t^3+5u^5\right)^{16}
\end{equation*}
</div>
<p>and</p>
<div class="math">
\begin{equation*}
g = \left(1+u+t+2z^2+3y^3+5x^5\right)^{16},
\end{equation*}
</div>
<p>we will calculate the fully-expanded form&nbsp;of</p>
<div class="math">
\begin{equation*}
f\times g.
\end{equation*}
</div>
<p>The result will contain 28398035 (that is, circa 28 million) terms. The test will be run in three different&nbsp;configurations:</p>
<ol class="arabic simple">
<li>with <tt class="docutils literal">integer</tt> coefficients,</li>
<li>with <tt class="docutils literal">integer</tt> coefficients forcibly switched to dynamic&nbsp;storage,</li>
<li>with <tt class="docutils literal">mpz_t</tt> coefficients, via the wrapper provided by the <a class="reference external" href="http://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/index.html">Boost.Multiprecision</a> (<span class="caps">BMP</span>)&nbsp;library.</li>
</ol>
<p>On my machine, all the coefficients of the result will fit in a <tt class="docutils literal">static_integer</tt>. The idea of the first test is thus
to measure the performance of <tt class="docutils literal">integer</tt> in the best possible scenario, where dynamic storage will never be used. The second test
is instead meant to measure the performance of dynamic storage. Finally, the last test is meant to provide
a comparison with respect to a vanilla <tt class="docutils literal">mpz_t</tt> wrapper.
All tests were run in single-threaded mode (although Piranha does support parallel
polynomial multiplication, I preferred to leave parallelisation out for this test). The tests were run on a 64-bit Linux workstation
at maximum priority and with the system at rest. The processor is a quad-core Intel i5 2500, supported by <span class="caps">16GB</span> of <span class="caps">DDR3</span> <span class="caps">RAM</span>.</p>
<p>The results, averaged over three separate runs for each test, are the&nbsp;following:</p>
<table border="1" class="docutils">
<colgroup>
<col width="60%" />
<col width="17%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Configuration</th>
<th class="head">Time (s)</th>
<th class="head">Memory (<span class="caps">GB</span>)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">integer</tt> (static storage)</td>
<td>9.94</td>
<td>2.86</td>
</tr>
<tr><td><tt class="docutils literal">integer</tt> (dynamic storage)</td>
<td>20.41</td>
<td>3.66</td>
</tr>
<tr><td><tt class="docutils literal">mpz_t</tt> wrapper</td>
<td>20.51</td>
<td>3.20</td>
</tr>
</tbody>
</table>
<p>We can see how the static storage <tt class="docutils literal">integer</tt> provides a runtime speedup of about 2x with respect to the <tt class="docutils literal">mpz_t</tt> wrapper. It also uses
about 10% less memory. The runtime performance of the dynamic storage <tt class="docutils literal">integer</tt> is essentially equivalent to the performance of the <tt class="docutils literal">mpz_t</tt> wrapper
(~0.5% difference), but the memory utilisation goes up by about 14%. In this sense the test is not completely fair, as the forced conversion
to dynamic storage in the second <tt class="docutils literal">integer</tt> test results in the unnecessary waste of the inline static storage. In a more realistic scenario,
dynamic storage would kick in when at least 3 limbs are necessary to represent the value and thus the waste of the static storage would be
proportionally smaller (one wasted static limb vs 3 dynamically allocated&nbsp;limbs).</p>
<p>Another important point of caution in this type of test is that we are measuring not only the impact of the small integer optimisation on the memory subsystem, but,
to some extent, also the performance of the multiprecision arithmetic implemented in <tt class="docutils literal">static_integer</tt>. <tt class="docutils literal">static_integer</tt> indeed cannot use <span class="caps">GMP</span> routines, and the basic
multiprecision arithmetic operations have thus been implemented from scratch. With respect to the <span class="caps">GMP</span> routines, the arithmetic functions for <tt class="docutils literal">static_integer</tt>
are somewhat simplified: they just employ &quot;naive&quot; (i.e., schoolbook) multiprecision arithmetic, and they exploit the fact that, by construction, the number of limbs can never
exceed 2. These simplifications are likely to have a non-negligible impact on the&nbsp;timings.</p>
</div>
<div class="section" id="conclusions">
<h3>Conclusions</h3>
<p>The small value optimisation in Piranha&#8217;s <tt class="docutils literal">integer</tt> class can lead to substantial improvements, both in runtime and in memory utilisation, over a straightforward
<tt class="docutils literal">mpz_t</tt> wrapper when multiplying very large and very sparse multivariate polynomials. The implementation employs the newly-introduced C++11 unrestricted unions,
and it exploits a special ruling in the standard that allows to embed the tagging logic directly in the members, thus avoiding the memory overhead
typically associated to the runtime management of unions. The management of the lifetime of the union members happens via explicit calls to constructors and destructors,
and it needs to be carefully orchestrated in order to avoid accessing the inactive member of the union (thus incurring in undefined behaviour).
The full source code the the <tt class="docutils literal">integer</tt> class is available <a class="reference external" href="https://github.com/bluescarni/piranha/blob/master/src/mp_integer.hpp">here</a>.</p>
<p>In the next installment of this series, I will focus on a <tt class="docutils literal">small_vector</tt> class used in Piranha to represent vectors of integral exponents in&nbsp;monomials.</p>
</div>
</div>
<script type='text/javascript'>if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
            <a href="#" class="go-top">Go Top</a>
<footer class="footer">
    <p>&copy; 2015 Francesco Biscani &ndash;
        Built with <a href="https://github.com/PurePelicanTheme/pure-single">Pure Theme</a>
        for <a href="http://blog.getpelican.com/">Pelican</a>
        <br />
        <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
    </p>
</footer>        </div>
    </div>
    </div>
    <script>
        var $top = $('.go-top');

        // Show or hide the sticky footer button
        $(window).scroll(function() {
            if ($(this).scrollTop() > 200) {
                $top.fadeIn(200);
            } else {
                $top.fadeOut(200);
            }
        });

        // Animate the scroll to top
        $top.click(function(event) {
            event.preventDefault();
            $('html, body').animate({scrollTop: 0}, 300);
        })

        // Makes sure that the href="#" attached to the <a> elements
        // don't scroll you back up the page.
        $('body').on('click', 'a[href="#"]', function(event) {
            event.preventDefault();
        });
    </script>

</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>piranha: piranha::math Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">piranha
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepiranha.html">piranha</a></li><li class="navelem"><a class="el" href="namespacepiranha_1_1math.html">math</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">piranha::math Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Math namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1abs__impl.html">abs_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a9fad3b6f8a6178867eeac66f69531397" title="Absolute value. ">piranha::math::abs()</a>.  <a href="structpiranha_1_1math_1_1abs__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1abs__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1is__mp253eef59264953658e3ef2df9e11d5d2.html">abs_impl&lt; T, typename std::enable_if&lt; detail::is_mp_integer&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a9fad3b6f8a6178867eeac66f69531397" title="Absolute value. ">piranha::math::abs()</a> functor for <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>.  <a href="structpiranha_1_1math_1_1abs__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1is__mp253eef59264953658e3ef2df9e11d5d2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1abs__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1is__mp0d1bbafb27f44854ac486088f8b36d6b.html">abs_impl&lt; T, typename std::enable_if&lt; detail::is_mp_rational&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a9fad3b6f8a6178867eeac66f69531397" title="Absolute value. ">piranha::math::abs()</a> functor for <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="structpiranha_1_1math_1_1abs__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1is__mp0d1bbafb27f44854ac486088f8b36d6b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1abs__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__same_64b42996f6b094c3e973d702c791c900.html">abs_impl&lt; T, typename std::enable_if&lt; std::is_same&lt; T, real &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a9fad3b6f8a6178867eeac66f69531397" title="Absolute value. ">piranha::math::abs()</a> functor for <a class="el" href="classpiranha_1_1real.html" title="Arbitrary precision floating-point class. ">piranha::real</a>.  <a href="structpiranha_1_1math_1_1abs__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__same_64b42996f6b094c3e973d702c791c900.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1abs__impl_3_01_t_00_01typename_01std_1_1enable__if_3_07std_1_1is__signe4ff60f7513fe56b5428c017f252f28d6.html">abs_impl&lt; T, typename std::enable_if&lt;(std::is_signed&lt; T &gt;::value &amp;&amp;std::is_integral&lt; T &gt;::value)||(std::is_unsigned&lt; T &gt;::value &amp;&amp;std::is_integral&lt; T &gt;::value)||std::is_floating_point&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a9fad3b6f8a6178867eeac66f69531397" title="Absolute value. ">piranha::math::abs()</a> functor for signed and unsigned integer types, and floating-point types.  <a href="structpiranha_1_1math_1_1abs__impl_3_01_t_00_01typename_01std_1_1enable__if_3_07std_1_1is__signe4ff60f7513fe56b5428c017f252f28d6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1binomial__impl.html">binomial_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a5a44533ef3963c6c96f4aca746c92d07" title="Generalised binomial coefficient. ">piranha::math::binomial()</a>.  <a href="structpiranha_1_1math_1_1binomial__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1binomial__impl_3_01_t_00_01_u_00_01detail_1_1integer__binomial__enabler_3_01_t_00_01_u_01_4_01_4.html">binomial_impl&lt; T, U, detail::integer_binomial_enabler&lt; T, U &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a5a44533ef3963c6c96f4aca746c92d07" title="Generalised binomial coefficient. ">piranha::math::binomial()</a> functor for <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>.  <a href="structpiranha_1_1math_1_1binomial__impl_3_01_t_00_01_u_00_01detail_1_1integer__binomial__enabler_3_01_t_00_01_u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1binomial__impl_3_01_t_00_01_u_00_01detail_1_1rational__binomial__enabler_3_01_t_00_01_u_01_4_01_4.html">binomial_impl&lt; T, U, detail::rational_binomial_enabler&lt; T, U &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a5a44533ef3963c6c96f4aca746c92d07" title="Generalised binomial coefficient. ">piranha::math::binomial()</a> functor for <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="structpiranha_1_1math_1_1binomial__impl_3_01_t_00_01_u_00_01detail_1_1rational__binomial__enabler_3_01_t_00_01_u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1binomial__impl_3_01_t_00_01_u_00_01detail_1_1real__binomial__enabler_3_01_t_00_01_u_01_4_01_4.html">binomial_impl&lt; T, U, detail::real_binomial_enabler&lt; T, U &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a5a44533ef3963c6c96f4aca746c92d07" title="Generalised binomial coefficient. ">piranha::math::binomial()</a> functor for <a class="el" href="classpiranha_1_1real.html" title="Arbitrary precision floating-point class. ">piranha::real</a>.  <a href="structpiranha_1_1math_1_1binomial__impl_3_01_t_00_01_u_00_01detail_1_1real__binomial__enabler_3_01_t_00_01_u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1binomial__impl_3_01_t_00_01_u_00_01typename_01std_1_1enable__if_3_01stdca731437099aa84c18e857850e6471b7.html">binomial_impl&lt; T, U, typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value &amp;&amp;std::is_arithmetic&lt; U &gt;::value &amp;&amp;(std::is_floating_point&lt; T &gt;::value||std::is_floating_point&lt; U &gt;::value)&gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a5a44533ef3963c6c96f4aca746c92d07" title="Generalised binomial coefficient. ">piranha::math::binomial()</a> functor for floating-point and arithmetic arguments.  <a href="structpiranha_1_1math_1_1binomial__impl_3_01_t_00_01_u_00_01typename_01std_1_1enable__if_3_01stdca731437099aa84c18e857850e6471b7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1cos__impl.html">cos_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a88eb0469177875f0133594816a8ba382" title="Cosine. ">piranha::math::cos()</a>.  <a href="structpiranha_1_1math_1_1cos__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1cos__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__series_be3b9c8ba1e7ea205aad3736bf2dce63.html">cos_impl&lt; Series, typename std::enable_if&lt; is_series&lt; Series &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a88eb0469177875f0133594816a8ba382" title="Cosine. ">piranha::math::cos()</a> functor for <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>.  <a href="structpiranha_1_1math_1_1cos__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__series_be3b9c8ba1e7ea205aad3736bf2dce63.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1cos__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1is__mp31895da5939bf6fe1ac83d48023ea22b.html">cos_impl&lt; T, typename std::enable_if&lt; detail::is_mp_integer&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a88eb0469177875f0133594816a8ba382" title="Cosine. ">piranha::math::cos()</a> functor for <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>.  <a href="structpiranha_1_1math_1_1cos__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1is__mp31895da5939bf6fe1ac83d48023ea22b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1cos__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1is__mp1855e5349f54f1190f2aed1f69b58247.html">cos_impl&lt; T, typename std::enable_if&lt; detail::is_mp_rational&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a88eb0469177875f0133594816a8ba382" title="Cosine. ">piranha::math::cos()</a> functor for <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="structpiranha_1_1math_1_1cos__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1is__mp1855e5349f54f1190f2aed1f69b58247.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1cos__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__floatf4f236ad8bf40cd7845fb14616d6f642.html">cos_impl&lt; T, typename std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a88eb0469177875f0133594816a8ba382" title="Cosine. ">piranha::math::cos()</a> functor for floating-point types.  <a href="structpiranha_1_1math_1_1cos__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__floatf4f236ad8bf40cd7845fb14616d6f642.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1cos__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__integ48a769cf6d1a2d076c37cd9e814c5a74.html">cos_impl&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a88eb0469177875f0133594816a8ba382" title="Cosine. ">piranha::math::cos()</a> functor for integral types.  <a href="structpiranha_1_1math_1_1cos__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__integ48a769cf6d1a2d076c37cd9e814c5a74.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1cos__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__same_94693c6a6e2c113fa8c70612155aebe1.html">cos_impl&lt; T, typename std::enable_if&lt; std::is_same&lt; T, real &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a88eb0469177875f0133594816a8ba382" title="Cosine. ">piranha::math::cos()</a> functor for <a class="el" href="classpiranha_1_1real.html" title="Arbitrary precision floating-point class. ">piranha::real</a>.  <a href="structpiranha_1_1math_1_1cos__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__same_94693c6a6e2c113fa8c70612155aebe1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1degree__impl.html">degree_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a934cd86d1c6bd2c1f40d307a093010bd" title="Total degree. ">piranha::math::degree()</a>.  <a href="structpiranha_1_1math_1_1degree__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1degree__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__inst8fa9c1a068e0a1a327656ae6be6e000b.html">degree_impl&lt; Series, typename std::enable_if&lt; is_instance_of&lt; Series, power_series &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a934cd86d1c6bd2c1f40d307a093010bd" title="Total degree. ">piranha::math::degree()</a> functor for instances of <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a>.  <a href="structpiranha_1_1math_1_1degree__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__inst8fa9c1a068e0a1a327656ae6be6e000b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1evaluate__impl.html">evaluate_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a4fd50fafb56550387b3b2dab67cdffcf" title="Evaluation. ">piranha::math::evaluate()</a>.  <a href="structpiranha_1_1math_1_1evaluate__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1evaluate__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__se4e3c16a0bc7acc2c74cd6ce09e8a06ed.html">evaluate_impl&lt; Series, typename std::enable_if&lt; is_series&lt; Series &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a4fd50fafb56550387b3b2dab67cdffcf" title="Evaluation. ">piranha::math::evaluate()</a> functor for series types.  <a href="structpiranha_1_1math_1_1evaluate__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__se4e3c16a0bc7acc2c74cd6ce09e8a06ed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1integrate__impl.html">integrate_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a989976cf0e0e1637ea0cd176cc87f0dc" title="Integration. ">piranha::math::integrate()</a>.  <a href="structpiranha_1_1math_1_1integrate__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1integrate__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__i1f3320f7bb3b8ce2bad9533b67777193.html">integrate_impl&lt; Series, typename std::enable_if&lt; is_instance_of&lt; Series, poisson_series &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a989976cf0e0e1637ea0cd176cc87f0dc" title="Integration. ">piranha::math::integrate()</a> functor for Poisson series.  <a href="structpiranha_1_1math_1_1integrate__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__i1f3320f7bb3b8ce2bad9533b67777193.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1integrate__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01std_125dd8d17cac1f645dda1a8714e8e241e.html">integrate_impl&lt; Series, typename std::enable_if&lt; std::is_base_of&lt; detail::polynomial_tag, Series &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a989976cf0e0e1637ea0cd176cc87f0dc" title="Integration. ">piranha::math::integrate()</a> functor for polynomial types.  <a href="structpiranha_1_1math_1_1integrate__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01std_125dd8d17cac1f645dda1a8714e8e241e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1ipow__subs__impl.html">ipow_subs_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#acc11ac62c76344c10610b3b8e3326764" title="Substitution of integral power. ">piranha::math::ipow_subs()</a>.  <a href="structpiranha_1_1math_1_1ipow__subs__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1ipow__subs__impl_3_01_series_00_01_t_00_01detail_1_1ipow__subs__impl__i05512f754a96e06f7f436d1e41d65424.html">ipow_subs_impl&lt; Series, T, detail::ipow_subs_impl_ipow_subs_series_enabler&lt; Series, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="structpiranha_1_1math_1_1ipow__subs__impl.html" title="Default functor for the implementation of piranha::math::ipow_subs(). ">piranha::math::ipow_subs_impl</a> functor for instances of <a class="el" href="classpiranha_1_1ipow__substitutable__series.html" title="Toolbox for series suitable for integral power substitution. ">piranha::ipow_substitutable_series</a>.  <a href="structpiranha_1_1math_1_1ipow__subs__impl_3_01_series_00_01_t_00_01detail_1_1ipow__subs__impl__i05512f754a96e06f7f436d1e41d65424.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1is__unitary__impl.html">is_unitary_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#ad23994843ee00b36960ab6b8a20962dd" title="Unitary test. ">piranha::math::is_unitary()</a>.  <a href="structpiranha_1_1math_1_1is__unitary__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1is__unitary__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_13f4aea92cc4f31a8e425a5fc9a750e1d.html">is_unitary_impl&lt; T, typename std::enable_if&lt; detail::is_mp_integer&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#ad23994843ee00b36960ab6b8a20962dd" title="Unitary test. ">piranha::math::is_unitary()</a> functor for <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>.  <a href="structpiranha_1_1math_1_1is__unitary__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_13f4aea92cc4f31a8e425a5fc9a750e1d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1is__unitary__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1a9769f3de9b1eafbee43b11f5a809a1c.html">is_unitary_impl&lt; T, typename std::enable_if&lt; detail::is_mp_rational&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#ad23994843ee00b36960ab6b8a20962dd" title="Unitary test. ">piranha::math::is_unitary()</a> functor for <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="structpiranha_1_1math_1_1is__unitary__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1a9769f3de9b1eafbee43b11f5a809a1c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1is__zero__impl.html">is_zero_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a00db2c62bd93a48258dd8545c6fb468c" title="Zero test. ">piranha::math::is_zero()</a>.  <a href="structpiranha_1_1math_1_1is__zero__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1is__zero__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__sedde2b95e1c3c348c590a053259c997ba.html">is_zero_impl&lt; Series, typename std::enable_if&lt; is_series&lt; Series &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a00db2c62bd93a48258dd8545c6fb468c" title="Zero test. ">piranha::math::is_zero()</a> functor for <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>.  <a href="structpiranha_1_1math_1_1is__zero__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__sedde2b95e1c3c348c590a053259c997ba.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1is__zero__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1ie169d5fa427548f1fa38674390f3d55a.html">is_zero_impl&lt; T, typename std::enable_if&lt; detail::is_mp_integer&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a00db2c62bd93a48258dd8545c6fb468c" title="Zero test. ">piranha::math::is_zero()</a> functor for <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>.  <a href="structpiranha_1_1math_1_1is__zero__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1ie169d5fa427548f1fa38674390f3d55a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1is__zero__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1i51477f6724cf5005cf9552208fa61d99.html">is_zero_impl&lt; T, typename std::enable_if&lt; detail::is_mp_rational&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a00db2c62bd93a48258dd8545c6fb468c" title="Zero test. ">piranha::math::is_zero()</a> functor for <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="structpiranha_1_1math_1_1is__zero__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1i51477f6724cf5005cf9552208fa61d99.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1is__zero__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__0f5293ccea14433d6d670df85edcd144.html">is_zero_impl&lt; T, typename std::enable_if&lt; std::is_same&lt; T, real &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a00db2c62bd93a48258dd8545c6fb468c" title="Zero test. ">piranha::math::is_zero()</a> functor for <a class="el" href="classpiranha_1_1real.html" title="Arbitrary precision floating-point class. ">piranha::real</a>.  <a href="structpiranha_1_1math_1_1is__zero__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__0f5293ccea14433d6d670df85edcd144.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1is__zero__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__c2a594b30a383849deb284bec036738e.html">is_zero_impl&lt; T, typename std::enable_if&lt; std::is_same&lt; T, std::complex&lt; float &gt; &gt;::value||std::is_same&lt; T, std::complex&lt; double &gt; &gt;::value||std::is_same&lt; T, std::complex&lt; long double &gt; &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a00db2c62bd93a48258dd8545c6fb468c" title="Zero test. ">piranha::math::is_zero()</a> functor for C++ complex floating-point types.  <a href="structpiranha_1_1math_1_1is__zero__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__c2a594b30a383849deb284bec036738e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1ldegree__impl.html">ldegree_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a05ad27dfa7dce556237f837c5c317890" title="Total low degree. ">piranha::math::ldegree()</a>.  <a href="structpiranha_1_1math_1_1ldegree__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1ldegree__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__insb70ddeda0d7a1f3822f273e89fb8eb57.html">ldegree_impl&lt; Series, typename std::enable_if&lt; is_instance_of&lt; Series, power_series &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a05ad27dfa7dce556237f837c5c317890" title="Total low degree. ">piranha::math::ldegree()</a> functor for instances of <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a>.  <a href="structpiranha_1_1math_1_1ldegree__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__insb70ddeda0d7a1f3822f273e89fb8eb57.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1multiply__accumulate__impl.html">multiply_accumulate_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a904f85d9a1ef8c95384bcb89ff0795e7" title="Multiply-accumulate. ">piranha::math::multiply_accumulate()</a>.  <a href="structpiranha_1_1math_1_1multiply__accumulate__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1multiply__accumulate__impl_3_01_t_00_01_t_00_01_t_00_01typename_01std_13d62277ec0e216ebc3d6b20fa3104fdd.html">multiply_accumulate_impl&lt; T, T, T, typename std::enable_if&lt; detail::is_mp_integer&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#a904f85d9a1ef8c95384bcb89ff0795e7" title="Multiply-accumulate. ">piranha::math::multiply_accumulate()</a> for <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>.  <a href="structpiranha_1_1math_1_1multiply__accumulate__impl_3_01_t_00_01_t_00_01_t_00_01typename_01std_13d62277ec0e216ebc3d6b20fa3104fdd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1multiply__accumulate__impl_3_01_t_00_01_t_00_01_t_00_01typename_01std_13d33b3d9279e2757b01accdf0f4ab177.html">multiply_accumulate_impl&lt; T, T, T, typename std::enable_if&lt; std::is_same&lt; T, real &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the implementation of <a class="el" href="namespacepiranha_1_1math.html#a904f85d9a1ef8c95384bcb89ff0795e7" title="Multiply-accumulate. ">piranha::math::multiply_accumulate()</a> for <a class="el" href="classpiranha_1_1real.html" title="Arbitrary precision floating-point class. ">piranha::real</a>.  <a href="structpiranha_1_1math_1_1multiply__accumulate__impl_3_01_t_00_01_t_00_01_t_00_01typename_01std_13d33b3d9279e2757b01accdf0f4ab177.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1negate__impl.html">negate_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a7ec2303772eab00a1ca75c11106c60b9" title="In-place negation. ">piranha::math::negate()</a>.  <a href="structpiranha_1_1math_1_1negate__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1negate__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1is_9b02cb8b33b0d99ab7a26ce86ea2442f.html">negate_impl&lt; T, typename std::enable_if&lt; detail::is_mp_integer&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a7ec2303772eab00a1ca75c11106c60b9" title="In-place negation. ">piranha::math::negate()</a> functor for <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>.  <a href="structpiranha_1_1math_1_1negate__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1is_9b02cb8b33b0d99ab7a26ce86ea2442f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1negate__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1is_bbea2002903163ec3614fda14a071bf4.html">negate_impl&lt; T, typename std::enable_if&lt; detail::is_mp_rational&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a7ec2303772eab00a1ca75c11106c60b9" title="In-place negation. ">piranha::math::negate()</a> functor for <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="structpiranha_1_1math_1_1negate__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1is_bbea2002903163ec3614fda14a071bf4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1negate__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01is__series_3_961a47b4cbfa205db4994c14d12bdfe4.html">negate_impl&lt; T, typename std::enable_if&lt; is_series&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a7ec2303772eab00a1ca75c11106c60b9" title="In-place negation. ">piranha::math::negate()</a> functor for <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>.  <a href="structpiranha_1_1math_1_1negate__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01is__series_3_961a47b4cbfa205db4994c14d12bdfe4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1negate__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__sa0c299022750663470c1226628bce710f.html">negate_impl&lt; T, typename std::enable_if&lt; std::is_same&lt; T, real &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a7ec2303772eab00a1ca75c11106c60b9" title="In-place negation. ">piranha::math::negate()</a> functor for <a class="el" href="classpiranha_1_1real.html" title="Arbitrary precision floating-point class. ">piranha::real</a>.  <a href="structpiranha_1_1math_1_1negate__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__sa0c299022750663470c1226628bce710f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1partial__impl.html">partial_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#ac3959494f64044823fd4c4545a5f3e4a" title="Partial derivative. ">piranha::math::partial()</a>.  <a href="structpiranha_1_1math_1_1partial__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1partial__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__serd5e73fceba9998bdc95402dcd3b8a713.html">partial_impl&lt; Series, typename std::enable_if&lt; is_series&lt; Series &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#ac3959494f64044823fd4c4545a5f3e4a" title="Partial derivative. ">piranha::math::partial()</a> functor for series types.  <a href="structpiranha_1_1math_1_1partial__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__serd5e73fceba9998bdc95402dcd3b8a713.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1partial__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1is2a63a03869b0956000397e003991eccf.html">partial_impl&lt; T, typename std::enable_if&lt; detail::is_mp_integer&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#ac3959494f64044823fd4c4545a5f3e4a" title="Partial derivative. ">piranha::math::partial()</a> functor for <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>.  <a href="structpiranha_1_1math_1_1partial__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1is2a63a03869b0956000397e003991eccf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1partial__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1is033840fbcf27df510cef1375231f717c.html">partial_impl&lt; T, typename std::enable_if&lt; detail::is_mp_rational&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#ac3959494f64044823fd4c4545a5f3e4a" title="Partial derivative. ">piranha::math::partial()</a> functor for <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="structpiranha_1_1math_1_1partial__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1is033840fbcf27df510cef1375231f717c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1partial__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__a932a86beb58173e9e98ed77b68c78e2b.html">partial_impl&lt; T, typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#ac3959494f64044823fd4c4545a5f3e4a" title="Partial derivative. ">piranha::math::partial()</a> functor for arithmetic types.  <a href="structpiranha_1_1math_1_1partial__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__a932a86beb58173e9e98ed77b68c78e2b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1partial__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__s84a8d9181bfd7f11229ba677189d6635.html">partial_impl&lt; T, typename std::enable_if&lt; std::is_same&lt; T, real &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#ac3959494f64044823fd4c4545a5f3e4a" title="Partial derivative. ">piranha::math::partial()</a> functor for <a class="el" href="classpiranha_1_1real.html" title="Arbitrary precision floating-point class. ">piranha::real</a>.  <a href="structpiranha_1_1math_1_1partial__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__s84a8d9181bfd7f11229ba677189d6635.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1pow__impl.html">pow_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#afbd1041a6f6d37325b55a66b7a84c016" title="Exponentiation. ">piranha::math::pow()</a>.  <a href="structpiranha_1_1math_1_1pow__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1pow__impl_3_01_series_00_01_t_00_01typename_01std_1_1enable__if_3_01is_0f3fcd19edefb397de775c8cb78cb562.html">pow_impl&lt; Series, T, typename std::enable_if&lt; is_series&lt; Series &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#afbd1041a6f6d37325b55a66b7a84c016" title="Exponentiation. ">piranha::math::pow()</a> functor for <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>.  <a href="structpiranha_1_1math_1_1pow__impl_3_01_series_00_01_t_00_01typename_01std_1_1enable__if_3_01is_0f3fcd19edefb397de775c8cb78cb562.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1pow__impl_3_01_t_00_01_u_00_01detail_1_1integer__pow__enabler_3_01_t_00_01_u_01_4_01_4.html">pow_impl&lt; T, U, detail::integer_pow_enabler&lt; T, U &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#afbd1041a6f6d37325b55a66b7a84c016" title="Exponentiation. ">piranha::math::pow()</a> functor for <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a> and integral types.  <a href="structpiranha_1_1math_1_1pow__impl_3_01_t_00_01_u_00_01detail_1_1integer__pow__enabler_3_01_t_00_01_u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1pow__impl_3_01_t_00_01_u_00_01detail_1_1rational__pow__enabler_3_01_t_00_01_u_01_4_01_4.html">pow_impl&lt; T, U, detail::rational_pow_enabler&lt; T, U &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1pow__impl_3_01_t_00_01_u_00_01detail_1_1real__pow__enabler_3_01_t_00_01_u_01_4_01_4.html">pow_impl&lt; T, U, detail::real_pow_enabler&lt; T, U &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#afbd1041a6f6d37325b55a66b7a84c016" title="Exponentiation. ">piranha::math::pow()</a> functor for <a class="el" href="classpiranha_1_1real.html" title="Arbitrary precision floating-point class. ">piranha::real</a>.  <a href="structpiranha_1_1math_1_1pow__impl_3_01_t_00_01_u_00_01detail_1_1real__pow__enabler_3_01_t_00_01_u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1pow__impl_3_01_t_00_01_u_00_01typename_01std_1_1enable__if_3_01std_1_1i75e75692b50ba0a416b80696ee7ae102.html">pow_impl&lt; T, U, typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value &amp;&amp;std::is_arithmetic&lt; U &gt;::value &amp;&amp;(std::is_floating_point&lt; T &gt;::value||std::is_floating_point&lt; U &gt;::value)&gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#afbd1041a6f6d37325b55a66b7a84c016" title="Exponentiation. ">piranha::math::pow()</a> functor for arithmetic and floating-point types.  <a href="structpiranha_1_1math_1_1pow__impl_3_01_t_00_01_u_00_01typename_01std_1_1enable__if_3_01std_1_1i75e75692b50ba0a416b80696ee7ae102.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1sin__impl.html">sin_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#afbe681443ac448d0eec22376992be475" title="Sine. ">piranha::math::sin()</a>.  <a href="structpiranha_1_1math_1_1sin__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1sin__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__series_a6b5f9ea9e1b7e9b8916242f9fe3c9d9.html">sin_impl&lt; Series, typename std::enable_if&lt; is_series&lt; Series &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#afbe681443ac448d0eec22376992be475" title="Sine. ">piranha::math::sin()</a> functor for <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>.  <a href="structpiranha_1_1math_1_1sin__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__series_a6b5f9ea9e1b7e9b8916242f9fe3c9d9.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1sin__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1is__mpceefb84b538850d20b56e0a7be3534fe.html">sin_impl&lt; T, typename std::enable_if&lt; detail::is_mp_integer&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#afbe681443ac448d0eec22376992be475" title="Sine. ">piranha::math::sin()</a> functor for <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>.  <a href="structpiranha_1_1math_1_1sin__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1is__mpceefb84b538850d20b56e0a7be3534fe.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1sin__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1is__mp9f4d7ff1cf28dd8bf5a3ac24295a141b.html">sin_impl&lt; T, typename std::enable_if&lt; detail::is_mp_rational&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#afbe681443ac448d0eec22376992be475" title="Sine. ">piranha::math::sin()</a> functor for <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="structpiranha_1_1math_1_1sin__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1is__mp9f4d7ff1cf28dd8bf5a3ac24295a141b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1sin__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__float7cae8112752e060a2327e5b460d34870.html">sin_impl&lt; T, typename std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#afbe681443ac448d0eec22376992be475" title="Sine. ">piranha::math::sin()</a> functor for floating-point types.  <a href="structpiranha_1_1math_1_1sin__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__float7cae8112752e060a2327e5b460d34870.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1sin__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__integ49b44ca1249b78a6db0acdaca721d670.html">sin_impl&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#afbe681443ac448d0eec22376992be475" title="Sine. ">piranha::math::sin()</a> functor for integral types.  <a href="structpiranha_1_1math_1_1sin__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__integ49b44ca1249b78a6db0acdaca721d670.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1sin__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__same_3232b8e745899f431b03676fbfb865b4.html">sin_impl&lt; T, typename std::enable_if&lt; std::is_same&lt; T, real &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#afbe681443ac448d0eec22376992be475" title="Sine. ">piranha::math::sin()</a> functor for <a class="el" href="classpiranha_1_1real.html" title="Arbitrary precision floating-point class. ">piranha::real</a>.  <a href="structpiranha_1_1math_1_1sin__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__same_3232b8e745899f431b03676fbfb865b4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1subs__impl.html">subs_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a5a6cafb8a41a9d777debf7213a7f6da4" title="Substitution. ">piranha::math::subs()</a>.  <a href="structpiranha_1_1math_1_1subs__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1subs__impl_3_01_series_00_01_t_00_01detail_1_1subs__impl__subs__series_6dd9288dcb2ac77e6637b29f9090c18e.html">subs_impl&lt; Series, T, detail::subs_impl_subs_series_enabler&lt; Series, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="structpiranha_1_1math_1_1subs__impl.html" title="Default functor for the implementation of piranha::math::subs(). ">piranha::math::subs_impl</a> functor for instances of <a class="el" href="classpiranha_1_1substitutable__series.html" title="Toolbox for substitutable series. ">piranha::substitutable_series</a>.  <a href="structpiranha_1_1math_1_1subs__impl_3_01_series_00_01_t_00_01detail_1_1subs__impl__subs__series_6dd9288dcb2ac77e6637b29f9090c18e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1t__degree__impl.html">t_degree_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a9cb790b56c7e9e146af38442d0aa21e7" title="Total trigonometric degree. ">piranha::math::t_degree()</a>.  <a href="structpiranha_1_1math_1_1t__degree__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1t__degree__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__ie4b022f9f0461eac231814b69a5d7b04.html">t_degree_impl&lt; Series, typename std::enable_if&lt; is_instance_of&lt; Series, trigonometric_series &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a9cb790b56c7e9e146af38442d0aa21e7" title="Total trigonometric degree. ">piranha::math::t_degree()</a> functor for instances of <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a>.  <a href="structpiranha_1_1math_1_1t__degree__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__ie4b022f9f0461eac231814b69a5d7b04.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1t__ldegree__impl.html">t_ldegree_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#ad2b8b1f80aee0a381281198ff64365cf" title="Total trigonometric low degree. ">piranha::math::t_ldegree()</a>.  <a href="structpiranha_1_1math_1_1t__ldegree__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1t__ldegree__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__c7aa420c7dde3596d36507b90ce3b0b5.html">t_ldegree_impl&lt; Series, typename std::enable_if&lt; is_instance_of&lt; Series, trigonometric_series &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#ad2b8b1f80aee0a381281198ff64365cf" title="Total trigonometric low degree. ">piranha::math::t_ldegree()</a> functor for instances of <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a>.  <a href="structpiranha_1_1math_1_1t__ldegree__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__c7aa420c7dde3596d36507b90ce3b0b5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1t__lorder__impl.html">t_lorder_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#af2332cb80565e16bd33b18556e526e09" title="Total trigonometric low order. ">piranha::math::t_lorder()</a>.  <a href="structpiranha_1_1math_1_1t__lorder__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1t__lorder__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__if7de5c2f1d1a1b541cfb2185f918de3d.html">t_lorder_impl&lt; Series, typename std::enable_if&lt; is_instance_of&lt; Series, trigonometric_series &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#af2332cb80565e16bd33b18556e526e09" title="Total trigonometric low order. ">piranha::math::t_lorder()</a> functor for instances of <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a>.  <a href="structpiranha_1_1math_1_1t__lorder__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__if7de5c2f1d1a1b541cfb2185f918de3d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1t__order__impl.html">t_order_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a0bbc2ff5743dc9f7a7bb7a78d0bea14a" title="Total trigonometric order. ">piranha::math::t_order()</a>.  <a href="structpiranha_1_1math_1_1t__order__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1t__order__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__in9a4127af6036767964db83b9990b67f7.html">t_order_impl&lt; Series, typename std::enable_if&lt; is_instance_of&lt; Series, trigonometric_series &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a0bbc2ff5743dc9f7a7bb7a78d0bea14a" title="Total trigonometric order. ">piranha::math::t_order()</a> functor for instances of <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a>.  <a href="structpiranha_1_1math_1_1t__order__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__in9a4127af6036767964db83b9990b67f7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1t__subs__impl.html">t_subs_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha_1_1math.html#a8a1eb57d2b0e2adb24433e9fe86377f5" title="Trigonometric substitution. ">piranha::math::t_subs()</a>.  <a href="structpiranha_1_1math_1_1t__subs__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1t__subs__impl_3_01_series_00_01_u_00_01_v_00_01detail_1_1t__subs__impl_7ad9c986dc1d74d55bde4986687ea40b.html">t_subs_impl&lt; Series, U, V, detail::t_subs_impl_t_subs_series_enabler&lt; Series, U, V &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#a8a1eb57d2b0e2adb24433e9fe86377f5" title="Trigonometric substitution. ">piranha::math::t_subs()</a> functor for instances of <a class="el" href="classpiranha_1_1t__substitutable__series.html" title="Toolbox for series that support trigonometric substitution. ">piranha::t_substitutable_series</a>.  <a href="structpiranha_1_1math_1_1t__subs__impl_3_01_series_00_01_u_00_01_v_00_01detail_1_1t__subs__impl_7ad9c986dc1d74d55bde4986687ea40b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1truncate__degree__impl.html">truncate_degree_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the <a class="el" href="namespacepiranha_1_1math.html#ab529e82af5b6a2f2a87d7c4f2c4268a8" title="Truncation based on the total degree. ">piranha::math::truncate_degree()</a> functor.  <a href="structpiranha_1_1math_1_1truncate__degree__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1math_1_1truncate__degree__impl_3_01_series_00_01_t_00_01typename_01std_1_1enabl8fda5e377cce0f9bb635852a4966a083.html">truncate_degree_impl&lt; Series, T, typename std::enable_if&lt; is_instance_of&lt; Series, power_series &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha_1_1math.html#ab529e82af5b6a2f2a87d7c4f2c4268a8" title="Truncation based on the total degree. ">piranha::math::truncate_degree()</a> functor for instances of <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a>.  <a href="structpiranha_1_1math_1_1truncate__degree__impl_3_01_series_00_01_t_00_01typename_01std_1_1enabl8fda5e377cce0f9bb635852a4966a083.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5a44533ef3963c6c96f4aca746c92d07"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a5a44533ef3963c6c96f4aca746c92d07"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a5a44533ef3963c6c96f4aca746c92d07">binomial</a> (const T &amp;x, const U &amp;y) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1binomial__impl.html">binomial_impl</a>&lt; T, U &gt;()(x, y))</td></tr>
<tr class="memdesc:a5a44533ef3963c6c96f4aca746c92d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalised binomial coefficient.  <a href="#a5a44533ef3963c6c96f4aca746c92d07">More...</a><br /></td></tr>
<tr class="separator:a5a44533ef3963c6c96f4aca746c92d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00db2c62bd93a48258dd8545c6fb468c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a00db2c62bd93a48258dd8545c6fb468c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a00db2c62bd93a48258dd8545c6fb468c">is_zero</a> (const T &amp;x) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1is__zero__impl.html">is_zero_impl</a>&lt; T &gt;()(x))</td></tr>
<tr class="memdesc:a00db2c62bd93a48258dd8545c6fb468c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero test.  <a href="#a00db2c62bd93a48258dd8545c6fb468c">More...</a><br /></td></tr>
<tr class="separator:a00db2c62bd93a48258dd8545c6fb468c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23994843ee00b36960ab6b8a20962dd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad23994843ee00b36960ab6b8a20962dd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#ad23994843ee00b36960ab6b8a20962dd">is_unitary</a> (const T &amp;x) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1is__unitary__impl.html">is_unitary_impl</a>&lt; T &gt;()(x))</td></tr>
<tr class="memdesc:ad23994843ee00b36960ab6b8a20962dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unitary test.  <a href="#ad23994843ee00b36960ab6b8a20962dd">More...</a><br /></td></tr>
<tr class="separator:ad23994843ee00b36960ab6b8a20962dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec2303772eab00a1ca75c11106c60b9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;!std::is_const&lt;typename std::remove_reference&lt;T&gt;::type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a7ec2303772eab00a1ca75c11106c60b9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a7ec2303772eab00a1ca75c11106c60b9">negate</a> (T &amp;x) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1negate__impl.html">negate_impl</a>&lt; T &gt;()(x))</td></tr>
<tr class="memdesc:a7ec2303772eab00a1ca75c11106c60b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place negation.  <a href="#a7ec2303772eab00a1ca75c11106c60b9">More...</a><br /></td></tr>
<tr class="separator:a7ec2303772eab00a1ca75c11106c60b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904f85d9a1ef8c95384bcb89ff0795e7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename V , typename  = typename std::enable_if&lt;	!std::is_const&lt;typename std::remove_reference&lt;T&gt;::type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a904f85d9a1ef8c95384bcb89ff0795e7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a904f85d9a1ef8c95384bcb89ff0795e7">multiply_accumulate</a> (T &amp;x, U &amp;&amp;y, V &amp;&amp;z) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1multiply__accumulate__impl.html">multiply_accumulate_impl</a>&lt; typename std::decay&lt; T &gt;::type, typename std::decay&lt; U &gt;::type, typename std::decay&lt; V &gt;::type &gt;()(x, std::forward&lt; U &gt;(y), std::forward&lt; V &gt;(z)))</td></tr>
<tr class="memdesc:a904f85d9a1ef8c95384bcb89ff0795e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate.  <a href="#a904f85d9a1ef8c95384bcb89ff0795e7">More...</a><br /></td></tr>
<tr class="separator:a904f85d9a1ef8c95384bcb89ff0795e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88eb0469177875f0133594816a8ba382"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a88eb0469177875f0133594816a8ba382"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a88eb0469177875f0133594816a8ba382">cos</a> (const T &amp;x) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1cos__impl.html">cos_impl</a>&lt; T &gt;()(x))</td></tr>
<tr class="memdesc:a88eb0469177875f0133594816a8ba382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cosine.  <a href="#a88eb0469177875f0133594816a8ba382">More...</a><br /></td></tr>
<tr class="separator:a88eb0469177875f0133594816a8ba382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe681443ac448d0eec22376992be475"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afbe681443ac448d0eec22376992be475"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#afbe681443ac448d0eec22376992be475">sin</a> (const T &amp;x) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1sin__impl.html">sin_impl</a>&lt; T &gt;()(x))</td></tr>
<tr class="memdesc:afbe681443ac448d0eec22376992be475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sine.  <a href="#afbe681443ac448d0eec22376992be475">More...</a><br /></td></tr>
<tr class="separator:afbe681443ac448d0eec22376992be475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3959494f64044823fd4c4545a5f3e4a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac3959494f64044823fd4c4545a5f3e4a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#ac3959494f64044823fd4c4545a5f3e4a">partial</a> (const T &amp;x, const std::string &amp;str) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1partial__impl.html">partial_impl</a>&lt; T &gt;()(x, str))</td></tr>
<tr class="memdesc:ac3959494f64044823fd4c4545a5f3e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial derivative.  <a href="#ac3959494f64044823fd4c4545a5f3e4a">More...</a><br /></td></tr>
<tr class="separator:ac3959494f64044823fd4c4545a5f3e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989976cf0e0e1637ea0cd176cc87f0dc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a989976cf0e0e1637ea0cd176cc87f0dc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a989976cf0e0e1637ea0cd176cc87f0dc">integrate</a> (const T &amp;x, const std::string &amp;str) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1integrate__impl.html">integrate_impl</a>&lt; T &gt;()(x, str))</td></tr>
<tr class="memdesc:a989976cf0e0e1637ea0cd176cc87f0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integration.  <a href="#a989976cf0e0e1637ea0cd176cc87f0dc">More...</a><br /></td></tr>
<tr class="separator:a989976cf0e0e1637ea0cd176cc87f0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd50fafb56550387b3b2dab67cdffcf"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T &gt; </td></tr>
<tr class="memitem:a4fd50fafb56550387b3b2dab67cdffcf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a4fd50fafb56550387b3b2dab67cdffcf">evaluate</a> (const T &amp;x, const std::unordered_map&lt; std::string, U &gt; &amp;dict) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1evaluate__impl.html">evaluate_impl</a>&lt; T &gt;()(x, dict))</td></tr>
<tr class="memdesc:a4fd50fafb56550387b3b2dab67cdffcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation.  <a href="#a4fd50fafb56550387b3b2dab67cdffcf">More...</a><br /></td></tr>
<tr class="separator:a4fd50fafb56550387b3b2dab67cdffcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6cafb8a41a9d777debf7213a7f6da4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a5a6cafb8a41a9d777debf7213a7f6da4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a5a6cafb8a41a9d777debf7213a7f6da4">subs</a> (const T &amp;x, const std::string &amp;name, const U &amp;y) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1subs__impl.html">subs_impl</a>&lt; T, U &gt;()(x, name, y))</td></tr>
<tr class="memdesc:a5a6cafb8a41a9d777debf7213a7f6da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution.  <a href="#a5a6cafb8a41a9d777debf7213a7f6da4">More...</a><br /></td></tr>
<tr class="separator:a5a6cafb8a41a9d777debf7213a7f6da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1eb57d2b0e2adb24433e9fe86377f5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename V &gt; </td></tr>
<tr class="memitem:a8a1eb57d2b0e2adb24433e9fe86377f5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a8a1eb57d2b0e2adb24433e9fe86377f5">t_subs</a> (const T &amp;x, const std::string &amp;name, const U &amp;c, const V &amp;s) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__subs__impl.html">t_subs_impl</a>&lt; T, U, V &gt;()(x, name, c, s))</td></tr>
<tr class="memdesc:a8a1eb57d2b0e2adb24433e9fe86377f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigonometric substitution.  <a href="#a8a1eb57d2b0e2adb24433e9fe86377f5">More...</a><br /></td></tr>
<tr class="separator:a8a1eb57d2b0e2adb24433e9fe86377f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fad3b6f8a6178867eeac66f69531397"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9fad3b6f8a6178867eeac66f69531397"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a9fad3b6f8a6178867eeac66f69531397">abs</a> (const T &amp;x) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1abs__impl.html">abs_impl</a>&lt; T &gt;()(x))</td></tr>
<tr class="memdesc:a9fad3b6f8a6178867eeac66f69531397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute value.  <a href="#a9fad3b6f8a6178867eeac66f69531397">More...</a><br /></td></tr>
<tr class="separator:a9fad3b6f8a6178867eeac66f69531397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac3a41bda6c458a8a4280badc7fcf17"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ac3a41bda6c458a8a4280badc7fcf17"><td class="memTemplItemLeft" align="right" valign="top">detail::pbracket_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a7ac3a41bda6c458a8a4280badc7fcf17">pbracket</a> (const T &amp;f, const T &amp;g, const std::vector&lt; std::string &gt; &amp;p_list, const std::vector&lt; std::string &gt; &amp;q_list)</td></tr>
<tr class="memdesc:a7ac3a41bda6c458a8a4280badc7fcf17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poisson bracket.  <a href="#a7ac3a41bda6c458a8a4280badc7fcf17">More...</a><br /></td></tr>
<tr class="separator:a7ac3a41bda6c458a8a4280badc7fcf17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652df25527486c9c55b365dd62e74e64"><td class="memTemplParams" colspan="2">template&lt;typename T , detail::is_canonical_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a652df25527486c9c55b365dd62e74e64"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a652df25527486c9c55b365dd62e74e64">transformation_is_canonical</a> (const std::vector&lt; T &gt; &amp;new_p, const std::vector&lt; T &gt; &amp;new_q, const std::vector&lt; std::string &gt; &amp;p_list, const std::vector&lt; std::string &gt; &amp;q_list)</td></tr>
<tr class="memdesc:a652df25527486c9c55b365dd62e74e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a transformation is canonical.  <a href="#a652df25527486c9c55b365dd62e74e64">More...</a><br /></td></tr>
<tr class="separator:a652df25527486c9c55b365dd62e74e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfb369fc27fce5b5d3c6bf4847b9f34"><td class="memTemplParams" colspan="2"><a class="anchor" id="aebfb369fc27fce5b5d3c6bf4847b9f34"></a>
template&lt;typename T , detail::is_canonical_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:aebfb369fc27fce5b5d3c6bf4847b9f34"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#aebfb369fc27fce5b5d3c6bf4847b9f34">transformation_is_canonical</a> (std::initializer_list&lt; T &gt; new_p, std::initializer_list&lt; T &gt; new_q, const std::vector&lt; std::string &gt; &amp;p_list, const std::vector&lt; std::string &gt; &amp;q_list)</td></tr>
<tr class="memdesc:aebfb369fc27fce5b5d3c6bf4847b9f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a transformation is canonical (alternative overload). <br /></td></tr>
<tr class="separator:aebfb369fc27fce5b5d3c6bf4847b9f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934cd86d1c6bd2c1f40d307a093010bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a934cd86d1c6bd2c1f40d307a093010bd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a934cd86d1c6bd2c1f40d307a093010bd">degree</a> (const T &amp;x) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1degree__impl.html">degree_impl</a>&lt; T &gt;()(x))</td></tr>
<tr class="memdesc:a934cd86d1c6bd2c1f40d307a093010bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total degree.  <a href="#a934cd86d1c6bd2c1f40d307a093010bd">More...</a><br /></td></tr>
<tr class="separator:a934cd86d1c6bd2c1f40d307a093010bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e42e3294b0b6bd50f75ac0e45ffc9f8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e42e3294b0b6bd50f75ac0e45ffc9f8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a9e42e3294b0b6bd50f75ac0e45ffc9f8">degree</a> (const T &amp;x, const std::vector&lt; std::string &gt; &amp;names) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1degree__impl.html">degree_impl</a>&lt; T &gt;()(x, names))</td></tr>
<tr class="memdesc:a9e42e3294b0b6bd50f75ac0e45ffc9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial degree.  <a href="#a9e42e3294b0b6bd50f75ac0e45ffc9f8">More...</a><br /></td></tr>
<tr class="separator:a9e42e3294b0b6bd50f75ac0e45ffc9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ad27dfa7dce556237f837c5c317890"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a05ad27dfa7dce556237f837c5c317890"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a05ad27dfa7dce556237f837c5c317890">ldegree</a> (const T &amp;x) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1ldegree__impl.html">ldegree_impl</a>&lt; T &gt;()(x))</td></tr>
<tr class="memdesc:a05ad27dfa7dce556237f837c5c317890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total low degree.  <a href="#a05ad27dfa7dce556237f837c5c317890">More...</a><br /></td></tr>
<tr class="separator:a05ad27dfa7dce556237f837c5c317890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2178fa50985be7fd6a4a846cf38cc58"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab2178fa50985be7fd6a4a846cf38cc58"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#ab2178fa50985be7fd6a4a846cf38cc58">ldegree</a> (const T &amp;x, const std::vector&lt; std::string &gt; &amp;names) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1ldegree__impl.html">ldegree_impl</a>&lt; T &gt;()(x, names))</td></tr>
<tr class="memdesc:ab2178fa50985be7fd6a4a846cf38cc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial low degree.  <a href="#ab2178fa50985be7fd6a4a846cf38cc58">More...</a><br /></td></tr>
<tr class="separator:ab2178fa50985be7fd6a4a846cf38cc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb790b56c7e9e146af38442d0aa21e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9cb790b56c7e9e146af38442d0aa21e7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a9cb790b56c7e9e146af38442d0aa21e7">t_degree</a> (const T &amp;x) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__degree__impl.html">t_degree_impl</a>&lt; T &gt;()(x))</td></tr>
<tr class="memdesc:a9cb790b56c7e9e146af38442d0aa21e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total trigonometric degree.  <a href="#a9cb790b56c7e9e146af38442d0aa21e7">More...</a><br /></td></tr>
<tr class="separator:a9cb790b56c7e9e146af38442d0aa21e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d83fd1c32d2533ac6ec8ab3b9b2390"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad0d83fd1c32d2533ac6ec8ab3b9b2390"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#ad0d83fd1c32d2533ac6ec8ab3b9b2390">t_degree</a> (const T &amp;x, const std::vector&lt; std::string &gt; &amp;names) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__degree__impl.html">t_degree_impl</a>&lt; T &gt;()(x, names))</td></tr>
<tr class="memdesc:ad0d83fd1c32d2533ac6ec8ab3b9b2390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trigonometric degree.  <a href="#ad0d83fd1c32d2533ac6ec8ab3b9b2390">More...</a><br /></td></tr>
<tr class="separator:ad0d83fd1c32d2533ac6ec8ab3b9b2390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b8b1f80aee0a381281198ff64365cf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2b8b1f80aee0a381281198ff64365cf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#ad2b8b1f80aee0a381281198ff64365cf">t_ldegree</a> (const T &amp;x) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__ldegree__impl.html">t_ldegree_impl</a>&lt; T &gt;()(x))</td></tr>
<tr class="memdesc:ad2b8b1f80aee0a381281198ff64365cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total trigonometric low degree.  <a href="#ad2b8b1f80aee0a381281198ff64365cf">More...</a><br /></td></tr>
<tr class="separator:ad2b8b1f80aee0a381281198ff64365cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548360bd4049145e4eec938c2d1dbfe5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a548360bd4049145e4eec938c2d1dbfe5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a548360bd4049145e4eec938c2d1dbfe5">t_ldegree</a> (const T &amp;x, const std::vector&lt; std::string &gt; &amp;names) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__ldegree__impl.html">t_ldegree_impl</a>&lt; T &gt;()(x, names))</td></tr>
<tr class="memdesc:a548360bd4049145e4eec938c2d1dbfe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trigonometric low degree.  <a href="#a548360bd4049145e4eec938c2d1dbfe5">More...</a><br /></td></tr>
<tr class="separator:a548360bd4049145e4eec938c2d1dbfe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbc2ff5743dc9f7a7bb7a78d0bea14a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0bbc2ff5743dc9f7a7bb7a78d0bea14a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a0bbc2ff5743dc9f7a7bb7a78d0bea14a">t_order</a> (const T &amp;x) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__order__impl.html">t_order_impl</a>&lt; T &gt;()(x))</td></tr>
<tr class="memdesc:a0bbc2ff5743dc9f7a7bb7a78d0bea14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total trigonometric order.  <a href="#a0bbc2ff5743dc9f7a7bb7a78d0bea14a">More...</a><br /></td></tr>
<tr class="separator:a0bbc2ff5743dc9f7a7bb7a78d0bea14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34d31975ddec861842b368be8f0f2ca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab34d31975ddec861842b368be8f0f2ca"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#ab34d31975ddec861842b368be8f0f2ca">t_order</a> (const T &amp;x, const std::vector&lt; std::string &gt; &amp;names) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__order__impl.html">t_order_impl</a>&lt; T &gt;()(x, names))</td></tr>
<tr class="memdesc:ab34d31975ddec861842b368be8f0f2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trigonometric order.  <a href="#ab34d31975ddec861842b368be8f0f2ca">More...</a><br /></td></tr>
<tr class="separator:ab34d31975ddec861842b368be8f0f2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2332cb80565e16bd33b18556e526e09"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af2332cb80565e16bd33b18556e526e09"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#af2332cb80565e16bd33b18556e526e09">t_lorder</a> (const T &amp;x) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__lorder__impl.html">t_lorder_impl</a>&lt; T &gt;()(x))</td></tr>
<tr class="memdesc:af2332cb80565e16bd33b18556e526e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total trigonometric low order.  <a href="#af2332cb80565e16bd33b18556e526e09">More...</a><br /></td></tr>
<tr class="separator:af2332cb80565e16bd33b18556e526e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cbe510754525dde205678937eb0b7d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab7cbe510754525dde205678937eb0b7d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#ab7cbe510754525dde205678937eb0b7d">t_lorder</a> (const T &amp;x, const std::vector&lt; std::string &gt; &amp;names) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__lorder__impl.html">t_lorder_impl</a>&lt; T &gt;()(x, names))</td></tr>
<tr class="memdesc:ab7cbe510754525dde205678937eb0b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trigonometric low order.  <a href="#ab7cbe510754525dde205678937eb0b7d">More...</a><br /></td></tr>
<tr class="separator:ab7cbe510754525dde205678937eb0b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab529e82af5b6a2f2a87d7c4f2c4268a8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , detail::truncate_degree_enabler&lt; T, U &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab529e82af5b6a2f2a87d7c4f2c4268a8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#ab529e82af5b6a2f2a87d7c4f2c4268a8">truncate_degree</a> (const T &amp;x, const U &amp;max_degree)</td></tr>
<tr class="memdesc:ab529e82af5b6a2f2a87d7c4f2c4268a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncation based on the total degree.  <a href="#ab529e82af5b6a2f2a87d7c4f2c4268a8">More...</a><br /></td></tr>
<tr class="separator:ab529e82af5b6a2f2a87d7c4f2c4268a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076b8891d207ab8a65b0cb131722cb5c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , detail::truncate_pdegree_enabler&lt; T, U &gt;  = 0&gt; </td></tr>
<tr class="memitem:a076b8891d207ab8a65b0cb131722cb5c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a076b8891d207ab8a65b0cb131722cb5c">truncate_degree</a> (const T &amp;x, const U &amp;max_degree, const std::vector&lt; std::string &gt; &amp;names)</td></tr>
<tr class="memdesc:a076b8891d207ab8a65b0cb131722cb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncation based on the partial degree.  <a href="#a076b8891d207ab8a65b0cb131722cb5c">More...</a><br /></td></tr>
<tr class="separator:a076b8891d207ab8a65b0cb131722cb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7272af623e53be5c8e9c8fe1176cf5"><td class="memTemplParams" colspan="2">template&lt;int NBits&gt; </td></tr>
<tr class="memitem:aff7272af623e53be5c8e9c8fe1176cf5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1mp__integer.html">mp_integer</a>&lt; NBits &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#aff7272af623e53be5c8e9c8fe1176cf5">factorial</a> (const <a class="el" href="classpiranha_1_1mp__integer.html">mp_integer</a>&lt; NBits &gt; &amp;n)</td></tr>
<tr class="memdesc:aff7272af623e53be5c8e9c8fe1176cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorial.  <a href="#aff7272af623e53be5c8e9c8fe1176cf5">More...</a><br /></td></tr>
<tr class="separator:aff7272af623e53be5c8e9c8fe1176cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc11ac62c76344c10610b3b8e3326764"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:acc11ac62c76344c10610b3b8e3326764"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#acc11ac62c76344c10610b3b8e3326764">ipow_subs</a> (const T &amp;x, const std::string &amp;name, const <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b">integer</a> &amp;n, const U &amp;y) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1ipow__subs__impl.html">ipow_subs_impl</a>&lt; T, U &gt;()(x, name, n, y))</td></tr>
<tr class="memdesc:acc11ac62c76344c10610b3b8e3326764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution of integral power.  <a href="#acc11ac62c76344c10610b3b8e3326764">More...</a><br /></td></tr>
<tr class="separator:acc11ac62c76344c10610b3b8e3326764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66768e2b472fc5bbde0065200b454dc5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename Int , detail::ipow_subs_int_enabler&lt; Int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a66768e2b472fc5bbde0065200b454dc5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#a66768e2b472fc5bbde0065200b454dc5">ipow_subs</a> (const T &amp;x, const std::string &amp;name, const Int &amp;n, const U &amp;y) -&gt; decltype(ipow_subs(x, name, <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b">integer</a>(n), y))</td></tr>
<tr class="memdesc:a66768e2b472fc5bbde0065200b454dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution of integral power (convenience overload).  <a href="#a66768e2b472fc5bbde0065200b454dc5">More...</a><br /></td></tr>
<tr class="separator:a66768e2b472fc5bbde0065200b454dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd1041a6f6d37325b55a66b7a84c016"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:afbd1041a6f6d37325b55a66b7a84c016"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html#afbd1041a6f6d37325b55a66b7a84c016">pow</a> (const T &amp;x, const U &amp;y) -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1pow__impl.html">pow_impl</a>&lt; T, U &gt;()(x, y))</td></tr>
<tr class="memdesc:afbd1041a6f6d37325b55a66b7a84c016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponentiation.  <a href="#afbd1041a6f6d37325b55a66b7a84c016">More...</a><br /></td></tr>
<tr class="separator:afbd1041a6f6d37325b55a66b7a84c016"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Math namespace. </p>
<p>Namespace for general-purpose mathematical functions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a9fad3b6f8a6178867eeac66f69531397"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::abs </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1abs__impl.html">abs_impl</a>&lt;T&gt;()(x))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Absolute value. </p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1abs__impl.html" title="Default functor for the implementation of piranha::math::abs(). ">piranha::math::abs_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>quantity whose absolute value will be calculated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>absolute value of <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1abs__impl.html" title="Default functor for the implementation of piranha::math::abs(). ">piranha::math::abs_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l00704">704</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a44533ef3963c6c96f4aca746c92d07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::binomial </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1binomial__impl.html">binomial_impl</a>&lt;T,U&gt;()(x,y))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generalised binomial coefficient. </p>
<p>Will return the generalised binomial coefficient: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ {x \choose y}. \]" src="form_0.png"/>
</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1binomial__impl.html" title="Default functor for the implementation of piranha::math::binomial(). ">piranha::math::binomial_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>top number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>bottom number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> choose <code>y</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1binomial__impl.html" title="Default functor for the implementation of piranha::math::binomial(). ">piranha::math::binomial_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="binomial_8hpp_source.html#l00223">223</a> of file <a class="el" href="binomial_8hpp_source.html">binomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a88eb0469177875f0133594816a8ba382"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::cos </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1cos__impl.html">cos_impl</a>&lt;T&gt;()(x))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cosine. </p>
<p>Returns the cosine of <code>x</code>. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1cos__impl.html" title="Default functor for the implementation of piranha::math::cos(). ">piranha::math::cos_impl</a> functor's call operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>cosine argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cosine of <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of the <a class="el" href="structpiranha_1_1math_1_1cos__impl.html" title="Default functor for the implementation of piranha::math::cos(). ">piranha::math::cos_impl</a> functor. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l00385">385</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a934cd86d1c6bd2c1f40d307a093010bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::degree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1degree__impl.html">degree_impl</a>&lt;T&gt;()(x))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total degree. </p>
<p>Return the total degree (as in polynomial degree).</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1degree__impl.html" title="Default functor for the implementation of piranha::math::degree(). ">piranha::math::degree_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>object whose degree will be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>total degree.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1degree__impl.html" title="Default functor for the implementation of piranha::math::degree(). ">piranha::math::degree_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l00984">984</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9e42e3294b0b6bd50f75ac0e45ffc9f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::degree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1degree__impl.html">degree_impl</a>&lt;T&gt;()(x,names))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial degree. </p>
<p>Return the partial degree (as in polynomial degree, but only a set of variables is considered in the computation).</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1degree__impl.html" title="Default functor for the implementation of piranha::math::degree(). ">piranha::math::degree_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>object whose partial degree will be computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>names of the variables that will be considered in the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial degree.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1degree__impl.html" title="Default functor for the implementation of piranha::math::degree(). ">piranha::math::degree_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l01003">1003</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4fd50fafb56550387b3b2dab67cdffcf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::evaluate </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; std::string, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>dict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1evaluate__impl.html">evaluate_impl</a>&lt;T&gt;()(x,dict))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluation. </p>
<p>Evaluation is the simultaneous substitution of all symbolic arguments in an expression. The input dictionary <code>dict</code> specifies the quantity (value) that will be susbstituted for each argument (key), here represented as a string.</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1evaluate__impl.html" title="Default functor for the implementation of piranha::math::evaluate(). ">piranha::math::evaluate_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>quantity that will be evaluated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dict</td><td>dictionary that will be used to perform the substitution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> evaluated according to <code>dict</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1evaluate__impl.html" title="Default functor for the implementation of piranha::math::evaluate(). ">piranha::math::evaluate_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l00578">578</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aff7272af623e53be5c8e9c8fe1176cf5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1mp__integer.html">mp_integer</a>&lt;NBits&gt; piranha::math::factorial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1mp__integer.html">mp_integer</a>&lt; NBits &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factorial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>factorial argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output of <a class="el" href="classpiranha_1_1mp__integer.html#a905095889e0e70e8165760ec9c253394" title="Factorial. ">piranha::mp_integer::factorial()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classpiranha_1_1mp__integer.html#a905095889e0e70e8165760ec9c253394" title="Factorial. ">piranha::mp_integer::factorial()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__integer_8hpp_source.html#l03351">3351</a> of file <a class="el" href="mp__integer_8hpp_source.html">mp_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a989976cf0e0e1637ea0cd176cc87f0dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::integrate </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1integrate__impl.html">integrate_impl</a>&lt;T&gt;()(x,str))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integration. </p>
<p>Return the antiderivative of <code>x</code> with respect to the symbolic quantity named <code>str</code>. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1integrate__impl.html" title="Default functor for the implementation of piranha::math::integrate(). ">piranha::math::integrate_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>argument for the integration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>name of the symbolic quantity with respect to which the integration will be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>antiderivative of <code>x</code> with respect to <code>str</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1integrate__impl.html" title="Default functor for the implementation of piranha::math::integrate(). ">piranha::math::integrate_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l00529">529</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acc11ac62c76344c10610b3b8e3326764"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::ipow_subs </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b">integer</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1ipow__subs__impl.html">ipow_subs_impl</a>&lt;T,U&gt;()(x,name,n,y))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution of integral power. </p>
<p>Substitute the integral power of a symbolic variable with a generic object. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1ipow__subs__impl.html" title="Default functor for the implementation of piranha::math::ipow_subs(). ">piranha::math::ipow_subs_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>quantity that will be subject to substitution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of the symbolic variable that will be substituted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>power of <code>name</code> that will be substituted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>object that will substitute the variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> after substitution of <code>name</code> to the power of <code>n</code> with <code>y</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1subs__impl.html" title="Default functor for the implementation of piranha::math::subs(). ">piranha::math::subs_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__integer_8hpp_source.html#l03380">3380</a> of file <a class="el" href="mp__integer_8hpp_source.html">mp_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a66768e2b472fc5bbde0065200b454dc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename Int , detail::ipow_subs_int_enabler&lt; Int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::ipow_subs </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(ipow_subs(x,name,<a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b">integer</a>(n),y))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution of integral power (convenience overload). </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if <code>Int</code> is a C++ integral type.</dd></dl>
<p>This function is a convenience wrapper that will call the other <a class="el" href="namespacepiranha_1_1math.html#acc11ac62c76344c10610b3b8e3326764" title="Substitution of integral power. ">piranha::math::ipow_subs()</a> overload, with <code>n</code> converted to a <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b" title="Alias for piranha::mp_integer with default bit size. ">piranha::integer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>quantity that will be subject to substitution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of the symbolic variable that will be substituted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>power of <code>name</code> that will be substituted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>object that will substitute the variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> after substitution of <code>name</code> to the power of <code>n</code> with <code>y</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the other overload of <a class="el" href="namespacepiranha_1_1math.html#acc11ac62c76344c10610b3b8e3326764" title="Substitution of integral power. ">piranha::math::ipow_subs()</a> or by the construction of <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b" title="Alias for piranha::mp_integer with default bit size. ">piranha::integer</a> from an integral value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__integer_8hpp_source.html#l03418">3418</a> of file <a class="el" href="mp__integer_8hpp_source.html">mp_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad23994843ee00b36960ab6b8a20962dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::is_unitary </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1is__unitary__impl.html">is_unitary_impl</a>&lt;T&gt;()(x))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unitary test. </p>
<p>Test if value is equal to 1. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1is__unitary__impl.html" title="Default functor for the implementation of piranha::math::is_unitary(). ">piranha::math::is_unitary_impl</a> functor's call operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>value to be tested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if value is equal to 1, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of the <a class="el" href="structpiranha_1_1math_1_1is__unitary__impl.html" title="Default functor for the implementation of piranha::math::is_unitary(). ">piranha::math::is_unitary_impl</a> functor. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l00167">167</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a00db2c62bd93a48258dd8545c6fb468c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::is_zero </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1is__zero__impl.html">is_zero_impl</a>&lt;T&gt;()(x))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero test. </p>
<p>Test if value is zero. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1is__zero__impl.html" title="Default functor for the implementation of piranha::math::is_zero(). ">piranha::math::is_zero_impl</a> functor's call operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>value to be tested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if value is zero, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of the <a class="el" href="structpiranha_1_1math_1_1is__zero__impl.html" title="Default functor for the implementation of piranha::math::is_zero(). ">piranha::math::is_zero_impl</a> functor. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l00116">116</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a05ad27dfa7dce556237f837c5c317890"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::ldegree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1ldegree__impl.html">ldegree_impl</a>&lt;T&gt;()(x))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total low degree. </p>
<p>Return the total low degree (as in polynomial low degree).</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1ldegree__impl.html" title="Default functor for the implementation of piranha::math::ldegree(). ">piranha::math::ldegree_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>object whose low degree will be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>total low degree.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1ldegree__impl.html" title="Default functor for the implementation of piranha::math::ldegree(). ">piranha::math::ldegree_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l01034">1034</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab2178fa50985be7fd6a4a846cf38cc58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::ldegree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1ldegree__impl.html">ldegree_impl</a>&lt;T&gt;()(x,names))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial low degree. </p>
<p>Return the partial low degree (as in polynomial low degree, but only a set of variables is considered in the computation).</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1ldegree__impl.html" title="Default functor for the implementation of piranha::math::ldegree(). ">piranha::math::ldegree_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>object whose partial low degree will be computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>names of the variables that will be considered in the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial low degree.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1ldegree__impl.html" title="Default functor for the implementation of piranha::math::ldegree(). ">piranha::math::ldegree_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l01053">1053</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a904f85d9a1ef8c95384bcb89ff0795e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename V , typename  = typename std::enable_if&lt;	!std::is_const&lt;typename std::remove_reference&lt;T&gt;::type&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::multiply_accumulate </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1multiply__accumulate__impl.html">multiply_accumulate_impl</a>&lt;typename std::decay&lt;T&gt;::type,
		typename std::decay&lt;U&gt;::type,typename std::decay&lt;V&gt;::type&gt;()(x,std::forward&lt;U&gt;(y),std::forward&lt;V&gt;(z)))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply-accumulate. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if <code>T</code> is not const.</dd></dl>
<p>Will set <code>x</code> to <code>x + y * z</code>. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1multiply__accumulate__impl.html" title="Default functor for the implementation of piranha::math::multiply_accumulate(). ">piranha::math::multiply_accumulate_impl</a> functor's call operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>target value for accumulation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>first argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the return value of the call operator of <a class="el" href="structpiranha_1_1math_1_1multiply__accumulate__impl.html" title="Default functor for the implementation of piranha::math::multiply_accumulate(). ">piranha::math::multiply_accumulate_impl</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1multiply__accumulate__impl.html" title="Default functor for the implementation of piranha::math::multiply_accumulate(). ">piranha::math::multiply_accumulate_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l00311">311</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7ec2303772eab00a1ca75c11106c60b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;!std::is_const&lt;typename std::remove_reference&lt;T&gt;::type&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::negate </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1negate__impl.html">negate_impl</a>&lt;T&gt;()(x))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place negation. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if <code>T</code> is not const.</dd></dl>
<p>Negate value in-place. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1negate__impl.html" title="Default functor for the implementation of piranha::math::negate(). ">piranha::math::negate_impl</a> functor's call operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>value to be negated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value returned by the call operator of <a class="el" href="structpiranha_1_1math_1_1negate__impl.html" title="Default functor for the implementation of piranha::math::negate(). ">piranha::math::negate_impl</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1negate__impl.html" title="Default functor for the implementation of piranha::math::negate(). ">piranha::math::negate_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l00226">226</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac3959494f64044823fd4c4545a5f3e4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::partial </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1partial__impl.html">partial_impl</a>&lt;T&gt;()(x,str))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial derivative. </p>
<p>Return the partial derivative of <code>x</code> with respect to the symbolic quantity named <code>str</code>. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1partial__impl.html" title="Default functor for the implementation of piranha::math::partial(). ">piranha::math::partial_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>argument for the partial derivative. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>name of the symbolic quantity with respect to which the derivative will be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial derivative of <code>x</code> with respect to <code>str</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1partial__impl.html" title="Default functor for the implementation of piranha::math::partial(). ">piranha::math::partial_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l00502">502</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7ac3a41bda6c458a8a4280badc7fcf17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::pbracket_type&lt;T&gt; piranha::math::pbracket </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Poisson bracket. </p>
<dl class="section note"><dt>Note</dt><dd>This template function is enabled only if <code>T</code> is differentiable and the arithmetic operations needed to compute the brackets are supported by the types involved in the computation.</dd></dl>
<p>The Poisson bracket of <code>f</code> and <code>g</code> with respect to the list of momenta <code>p_list</code> and coordinates <code>q_list</code> is defined as: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left\{f,g\right\} = \sum_{i=1}^{N} \left[ \frac{\partial f}{\partial q_{i}} \frac{\partial g}{\partial p_{i}} - \frac{\partial f}{\partial p_{i}} \frac{\partial g}{\partial q_{i}} \right], \]" src="form_10.png"/>
</p>
<p> where <img class="formulaInl" alt="$ p_i $" src="form_11.png"/> and <img class="formulaInl" alt="$ q_i $" src="form_12.png"/> are the elements of <code>p_list</code> and <code>q_list</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>first argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>second argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_list</td><td>list of the names of momenta. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q_list</td><td>list of the names of coordinates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the poisson bracket of <code>f</code> and <code>g</code> with respect to <code>p_list</code> and <code>q_list</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the sizes of <code>p_list</code> and <code>q_list</code> differ or if <code>p_list</code> or <code>q_list</code> contain duplicate entries. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="namespacepiranha_1_1math.html#ac3959494f64044823fd4c4545a5f3e4a" title="Partial derivative. ">piranha::math::partial()</a> or by the invoked arithmetic operators, constructors and assignment operators. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l00812">812</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afbd1041a6f6d37325b55a66b7a84c016"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::pow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1pow__impl.html">pow_impl</a>&lt;T,U&gt;()(x,y))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exponentiation. </p>
<p>Return <code>x</code> to the power of <code>y</code>. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1pow__impl.html" title="Default functor for the implementation of piranha::math::pow(). ">piranha::math::pow_impl</a> functor's call operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>base. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>exponent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> to the power of <code>y</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of the <a class="el" href="structpiranha_1_1math_1_1pow__impl.html" title="Default functor for the implementation of piranha::math::pow(). ">piranha::math::pow_impl</a> functor. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pow_8hpp_source.html#l00102">102</a> of file <a class="el" href="pow_8hpp_source.html">pow.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afbe681443ac448d0eec22376992be475"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::sin </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1sin__impl.html">sin_impl</a>&lt;T&gt;()(x))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sine. </p>
<p>Returns the sine of <code>x</code>. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1sin__impl.html" title="Default functor for the implementation of piranha::math::sin(). ">piranha::math::sin_impl</a> functor's call operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>sine argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sine of <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of the <a class="el" href="structpiranha_1_1math_1_1sin__impl.html" title="Default functor for the implementation of piranha::math::sin(). ">piranha::math::sin_impl</a> functor. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l00457">457</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a6cafb8a41a9d777debf7213a7f6da4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::subs </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1subs__impl.html">subs_impl</a>&lt;T,U&gt;()(x,name,y))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution. </p>
<p>Substitute a symbolic variable with a generic object. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1subs__impl.html" title="Default functor for the implementation of piranha::math::subs(). ">piranha::math::subs_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>quantity that will be subject to substitution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of the symbolic variable that will be substituted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>object that will substitute the variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> after substitution of <code>name</code> with <code>y</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1subs__impl.html" title="Default functor for the implementation of piranha::math::subs(). ">piranha::math::subs_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l00606">606</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9cb790b56c7e9e146af38442d0aa21e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::t_degree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__degree__impl.html">t_degree_impl</a>&lt;T&gt;()(x))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total trigonometric degree. </p>
<p>A type exposing a trigonometric degree property, in analogy with the concept of polynomial degree, should be a linear combination of real or complex trigonometric functions. For instance, the Poisson series </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ 2\cos\left(3x+y\right) + 3\cos\left(2x-y\right) \]" src="form_13.png"/>
</p>
<p> has a trigonometric degree of 3+1=4.</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1t__degree__impl.html" title="Default functor for the implementation of piranha::math::t_degree(). ">piranha::math::t_degree_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>object whose trigonometric degree will be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>total trigonometric degree.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1t__degree__impl.html" title="Default functor for the implementation of piranha::math::t_degree(). ">piranha::math::t_degree_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l01089">1089</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad0d83fd1c32d2533ac6ec8ab3b9b2390"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::t_degree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__degree__impl.html">t_degree_impl</a>&lt;T&gt;()(x,names))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial trigonometric degree. </p>
<p>The partial trigonometric degree is the trigonometric degree when only certain variables are considered in the computation.</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1t__degree__impl.html" title="Default functor for the implementation of piranha::math::t_degree(). ">piranha::math::t_degree_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>object whose trigonometric degree will be computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>names of the variables that will be considered in the computation of the degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial trigonometric degree.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1t__degree__impl.html" title="Default functor for the implementation of piranha::math::t_degree(). ">piranha::math::t_degree_impl</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepiranha_1_1math.html#a9cb790b56c7e9e146af38442d0aa21e7" title="Total trigonometric degree. ">piranha::math::t_degree()</a>. </dd></dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l01111">1111</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad2b8b1f80aee0a381281198ff64365cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::t_ldegree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__ldegree__impl.html">t_ldegree_impl</a>&lt;T&gt;()(x))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total trigonometric low degree. </p>
<p>A type exposing a trigonometric low degree property, in analogy with the concept of polynomial low degree, should be a linear combination of real or complex trigonometric functions. For instance, the Poisson series </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ 2\cos\left(3x+y\right) + 3\cos\left(2x-y\right) \]" src="form_13.png"/>
</p>
<p> has a trigonometric low degree of 2-1=1.</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1t__ldegree__impl.html" title="Default functor for the implementation of piranha::math::t_ldegree(). ">piranha::math::t_ldegree_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>object whose trigonometric low degree will be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>total trigonometric low degree.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1t__ldegree__impl.html" title="Default functor for the implementation of piranha::math::t_ldegree(). ">piranha::math::t_ldegree_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l01147">1147</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a548360bd4049145e4eec938c2d1dbfe5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::t_ldegree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__ldegree__impl.html">t_ldegree_impl</a>&lt;T&gt;()(x,names))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial trigonometric low degree. </p>
<p>The partial trigonometric low degree is the trigonometric low degree when only certain variables are considered in the computation.</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1t__ldegree__impl.html" title="Default functor for the implementation of piranha::math::t_ldegree(). ">piranha::math::t_ldegree_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>object whose trigonometric low degree will be computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>names of the variables that will be considered in the computation of the degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial trigonometric low degree.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1t__ldegree__impl.html" title="Default functor for the implementation of piranha::math::t_ldegree(). ">piranha::math::t_ldegree_impl</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepiranha_1_1math.html#ad2b8b1f80aee0a381281198ff64365cf" title="Total trigonometric low degree. ">piranha::math::t_ldegree()</a>. </dd></dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l01169">1169</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af2332cb80565e16bd33b18556e526e09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::t_lorder </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__lorder__impl.html">t_lorder_impl</a>&lt;T&gt;()(x))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total trigonometric low order. </p>
<p>A type exposing a trigonometric low order property should be a linear combination of real or complex trigonometric functions. The low order is computed in a way similar to the trigonometric low degree, with the key difference that the absolute values of the trigonometric degrees of each variable are considered in the computation. For instance, the Poisson series </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ 2\cos\left(3x+y\right) + 3\cos\left(2x-y\right) \]" src="form_13.png"/>
</p>
<p> has a trigonometric low order of abs(2)+abs(1)=3.</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1t__lorder__impl.html" title="Default functor for the implementation of piranha::math::t_lorder(). ">piranha::math::t_lorder_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>object whose trigonometric low order will be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>total trigonometric low order.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1t__lorder__impl.html" title="Default functor for the implementation of piranha::math::t_lorder(). ">piranha::math::t_lorder_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l01265">1265</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab7cbe510754525dde205678937eb0b7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::t_lorder </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__lorder__impl.html">t_lorder_impl</a>&lt;T&gt;()(x,names))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial trigonometric low order. </p>
<p>The partial trigonometric low order is the trigonometric low order when only certain variables are considered in the computation.</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1t__lorder__impl.html" title="Default functor for the implementation of piranha::math::t_lorder(). ">piranha::math::t_lorder_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>object whose trigonometric low order will be computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>names of the variables that will be considered in the computation of the order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial trigonometric low order.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1t__lorder__impl.html" title="Default functor for the implementation of piranha::math::t_lorder(). ">piranha::math::t_lorder_impl</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepiranha_1_1math.html#af2332cb80565e16bd33b18556e526e09" title="Total trigonometric low order. ">piranha::math::t_lorder()</a>. </dd></dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l01287">1287</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0bbc2ff5743dc9f7a7bb7a78d0bea14a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::t_order </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__order__impl.html">t_order_impl</a>&lt;T&gt;()(x))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total trigonometric order. </p>
<p>A type exposing a trigonometric order property should be a linear combination of real or complex trigonometric functions. The order is computed in a way similar to the trigonometric degree, with the key difference that the absolute values of the trigonometric degrees of each variable are considered in the computation. For instance, the Poisson series </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ 2\cos\left(3x+y\right) + 3\cos\left(2x-y\right) \]" src="form_13.png"/>
</p>
<p> has a trigonometric order of abs(3)+abs(1)=4.</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1t__order__impl.html" title="Default functor for the implementation of piranha::math::t_order(). ">piranha::math::t_order_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>object whose trigonometric order will be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>total trigonometric order.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1t__order__impl.html" title="Default functor for the implementation of piranha::math::t_order(). ">piranha::math::t_order_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l01206">1206</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab34d31975ddec861842b368be8f0f2ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::t_order </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__order__impl.html">t_order_impl</a>&lt;T&gt;()(x,names))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial trigonometric order. </p>
<p>The partial trigonometric order is the trigonometric order when only certain variables are considered in the computation.</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1t__order__impl.html" title="Default functor for the implementation of piranha::math::t_order(). ">piranha::math::t_order_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>object whose trigonometric order will be computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>names of the variables that will be considered in the computation of the order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial trigonometric order.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1t__order__impl.html" title="Default functor for the implementation of piranha::math::t_order(). ">piranha::math::t_order_impl</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepiranha_1_1math.html#a0bbc2ff5743dc9f7a7bb7a78d0bea14a" title="Total trigonometric order. ">piranha::math::t_order()</a>. </dd></dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l01228">1228</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a1eb57d2b0e2adb24433e9fe86377f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::math::t_subs </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1math_1_1t__subs__impl.html">t_subs_impl</a>&lt;T,U,V&gt;()(x,name,c,s))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trigonometric substitution. </p>
<p>Substitute the cosine and sine of a symbolic variable with generic objects. The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1t__subs__impl.html" title="Default functor for the implementation of piranha::math::t_subs(). ">piranha::math::t_subs_impl</a> functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>quantity that will be subject to substitution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of the symbolic variable that will be substituted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>object that will substitute the cosine of the variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>object that will substitute the sine of the variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> after substitution of cosine and sine of <code>name</code> with <code>c</code> and <code>s</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1t__subs__impl.html" title="Default functor for the implementation of piranha::math::t_subs(). ">piranha::math::t_subs_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l00635">635</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a652df25527486c9c55b365dd62e74e64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , detail::is_canonical_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool piranha::math::transformation_is_canonical </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a transformation is canonical. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if all the following requirements are met:<ul>
<li><code>T</code> satisfies <a class="el" href="classpiranha_1_1has__pbracket.html" title="Detect piranha::math::pbracket(). ">piranha::has_pbracket</a>,</li>
<li>the output type of <a class="el" href="classpiranha_1_1has__pbracket.html" title="Detect piranha::math::pbracket(). ">piranha::has_pbracket</a> for <code>T</code> satisfies <a class="el" href="classpiranha_1_1has__is__zero.html" title="Type trait to detect the presence of the piranha::math::is_zero() function. ">piranha::has_is_zero</a>, it is constructible from <code>int</code> and it is equality comparable.</li>
</ul>
</dd></dl>
<p>This function will check if a transformation of Hamiltonian momenta and coordinates is canonical using the Poisson bracket test. The transformation is expressed as two separate collections of objects, <code>new_p</code> and <code>new_q</code>, representing the new momenta and coordinates as functions of the old momenta <code>p_list</code> and <code>q_list</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_p</td><td>list of objects representing the new momenta. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_q</td><td>list of objects representing the new coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_list</td><td>list of names of the old momenta. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q_list</td><td>list of names of the old coordinates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the transformation is canonical, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the sizes of the four input arguments are not the same or if either <code>p_list</code> or <code>q_list</code> contain duplicate entries. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="namespacepiranha_1_1math.html#a7ac3a41bda6c458a8a4280badc7fcf17" title="Poisson bracket. ">piranha::math::pbracket()</a>,</li>
<li>construction and comparison of objects of the type returned by <a class="el" href="namespacepiranha_1_1math.html#a7ac3a41bda6c458a8a4280badc7fcf17" title="Poisson bracket. ">piranha::math::pbracket()</a>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#a00db2c62bd93a48258dd8545c6fb468c" title="Zero test. ">piranha::math::is_zero()</a>,</li>
<li>memory errors in standard containers. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l00938">938</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab529e82af5b6a2f2a87d7c4f2c4268a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , detail::truncate_degree_enabler&lt; T, U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T piranha::math::truncate_degree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>max_degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncation based on the total degree. </p>
<p>This method is used to eliminate from the input argument <code>x</code> all the parts whose total degree is greater than <code>max_degree</code>.</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1truncate__degree__impl.html" title="Implementation of the piranha::math::truncate_degree() functor. ">piranha::math::truncate_degree_impl</a> functor.</p>
<p>The body of this function is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> truncate_degree_impl&lt;T,U&gt;()(x,max_degree);</div>
</div><!-- fragment --><p> The call operator of <a class="el" href="structpiranha_1_1math_1_1truncate__degree__impl.html" title="Implementation of the piranha::math::truncate_degree() functor. ">piranha::math::truncate_degree_impl</a> is required to return type <code>T</code>, otherwise this function will be disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>object which will be subject to truncation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_degree</td><td>maximum allowed total degree in the output.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the truncated counterpart of <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1truncate__degree__impl.html" title="Implementation of the piranha::math::truncate_degree() functor. ">piranha::math::truncate_degree_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l01340">1340</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a076b8891d207ab8a65b0cb131722cb5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , detail::truncate_pdegree_enabler&lt; T, U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T piranha::math::truncate_degree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>max_degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncation based on the partial degree. </p>
<p>This method is used to eliminate from the input argument <code>x</code> all the parts whose partial degree is greater than <code>max_degree</code>.</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1math_1_1truncate__degree__impl.html" title="Implementation of the piranha::math::truncate_degree() functor. ">piranha::math::truncate_degree_impl</a> functor.</p>
<p>The body of this function is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> truncate_degree_impl&lt;T,U&gt;()(x,max_degree,names);</div>
</div><!-- fragment --><p> The call operator of <a class="el" href="structpiranha_1_1math_1_1truncate__degree__impl.html" title="Implementation of the piranha::math::truncate_degree() functor. ">piranha::math::truncate_degree_impl</a> is required to return type <code>T</code>, otherwise this function will be disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>object which will be subject to truncation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_degree</td><td>maximum allowed partial degree in the output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>names of the variables that will be considered in the computation of the partial degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the truncated counterpart of <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1math_1_1truncate__degree__impl.html" title="Implementation of the piranha::math::truncate_degree() functor. ">piranha::math::truncate_degree_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_8hpp_source.html#l01368">1368</a> of file <a class="el" href="math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 18 2015 21:06:04 for piranha by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>piranha: piranha::poisson_series&lt; Cf &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">piranha
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepiranha.html">piranha</a></li><li class="navelem"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classpiranha_1_1poisson__series-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">piranha::poisson_series&lt; Cf &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Poisson series class.  
 <a href="classpiranha_1_1poisson__series.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="poisson__series_8hpp_source.html">poisson_series.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for piranha::poisson_series&lt; Cf &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classpiranha_1_1poisson__series__inherit__graph.png" border="0" usemap="#piranha_1_1poisson__series_3_01_cf_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="piranha_1_1poisson__series_3_01_cf_01_4_inherit__map" id="piranha_1_1poisson__series_3_01_cf_01_4_inherit__map">
<area shape="rect" id="node2" href="classpiranha_1_1power__series.html" title="piranha::power_series\l\&lt; ipow_substitutable\l_series\&lt; substitutable\l_series\&lt; t_substitutable\l_series\&lt; trigonometric_series\l\&lt; series\&lt; Cf, rtk_monomial,\l poisson_series\&lt; Cf \&gt; \&gt; \&gt;, poisson\l_series\&lt; Cf \&gt; \&gt;, poisson_series\&lt;\l Cf \&gt; \&gt;, poisson_series\&lt; Cf \&gt; \&gt;, poisson\l_series\&lt; Cf \&gt; \&gt;" alt="" coords="1555,5,1815,163"/><area shape="rect" id="node3" href="classpiranha_1_1ipow__substitutable__series.html" title="piranha::ipow_substitutable\l_series\&lt; substitutable_series\l\&lt; t_substitutable_series\&lt; trigonometric\l_series\&lt; series\&lt; Cf, rtk_monomial,\l poisson_series\&lt; Cf \&gt; \&gt; \&gt;, poisson_series\l\&lt; Cf \&gt; \&gt;, poisson_series\&lt; Cf \&gt; \&gt;, poisson\l_series\&lt; Cf \&gt; \&gt;" alt="" coords="1237,27,1507,141"/><area shape="rect" id="node4" href="classpiranha_1_1substitutable__series.html" title="piranha::substitutable\l_series\&lt; t_substitutable\l_series\&lt; trigonometric_series\l\&lt; series\&lt; Cf, rtk_monomial,\l poisson_series\&lt; Cf \&gt; \&gt; \&gt;, poisson\l_series\&lt; Cf \&gt; \&gt;, poisson_series\&lt; Cf \&gt; \&gt;" alt="" coords="931,34,1189,134"/><area shape="rect" id="node5" href="classpiranha_1_1t__substitutable__series.html" title="piranha::t_substitutable\l_series\&lt; trigonometric\l_series\&lt; series\&lt; Cf, rtk\l_monomial, poisson_series\l\&lt; Cf \&gt; \&gt; \&gt;, poisson_series\&lt; Cf \&gt; \&gt;" alt="" coords="656,41,883,127"/><area shape="rect" id="node6" href="classpiranha_1_1trigonometric__series.html" title="piranha::trigonometric\l_series\&lt; series\&lt; Cf, rtk\l_monomial, poisson_series\l\&lt; Cf \&gt; \&gt; \&gt;" alt="" coords="427,49,607,119"/><area shape="rect" id="node7" href="classpiranha_1_1series.html" title="piranha::series\&lt; Cf,\l rtk_monomial, poisson\l_series\&lt; Cf \&gt; \&gt;" alt="" coords="221,56,379,112"/><area shape="rect" id="node8" href="classpiranha_1_1series__operators.html" title="Series operators. " alt="" coords="5,71,173,97"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for piranha::poisson_series&lt; Cf &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classpiranha_1_1poisson__series__coll__graph.png" border="0" usemap="#piranha_1_1poisson__series_3_01_cf_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="piranha_1_1poisson__series_3_01_cf_01_4_coll__map" id="piranha_1_1poisson__series_3_01_cf_01_4_coll__map">
<area shape="rect" id="node2" href="classpiranha_1_1power__series.html" title="piranha::power_series\l\&lt; ipow_substitutable\l_series\&lt; substitutable\l_series\&lt; t_substitutable\l_series\&lt; trigonometric_series\l\&lt; series\&lt; Cf, rtk_monomial,\l poisson_series\&lt; Cf \&gt; \&gt; \&gt;, poisson\l_series\&lt; Cf \&gt; \&gt;, poisson_series\&lt;\l Cf \&gt; \&gt;, poisson_series\&lt; Cf \&gt; \&gt;, poisson\l_series\&lt; Cf \&gt; \&gt;" alt="" coords="1659,5,1919,163"/><area shape="rect" id="node3" href="classpiranha_1_1ipow__substitutable__series.html" title="piranha::ipow_substitutable\l_series\&lt; substitutable_series\l\&lt; t_substitutable_series\&lt; trigonometric\l_series\&lt; series\&lt; Cf, rtk_monomial,\l poisson_series\&lt; Cf \&gt; \&gt; \&gt;, poisson_series\l\&lt; Cf \&gt; \&gt;, poisson_series\&lt; Cf \&gt; \&gt;, poisson\l_series\&lt; Cf \&gt; \&gt;" alt="" coords="1339,27,1608,141"/><area shape="rect" id="node4" href="classpiranha_1_1substitutable__series.html" title="piranha::substitutable\l_series\&lt; t_substitutable\l_series\&lt; trigonometric_series\l\&lt; series\&lt; Cf, rtk_monomial,\l poisson_series\&lt; Cf \&gt; \&gt; \&gt;, poisson\l_series\&lt; Cf \&gt; \&gt;, poisson_series\&lt; Cf \&gt; \&gt;" alt="" coords="1030,34,1287,134"/><area shape="rect" id="node5" href="classpiranha_1_1t__substitutable__series.html" title="piranha::t_substitutable\l_series\&lt; trigonometric\l_series\&lt; series\&lt; Cf, rtk\l_monomial, poisson_series\l\&lt; Cf \&gt; \&gt; \&gt;, poisson_series\&lt; Cf \&gt; \&gt;" alt="" coords="752,41,979,127"/><area shape="rect" id="node6" href="classpiranha_1_1trigonometric__series.html" title="piranha::trigonometric\l_series\&lt; series\&lt; Cf, rtk\l_monomial, poisson_series\l\&lt; Cf \&gt; \&gt; \&gt;" alt="" coords="521,49,701,119"/><area shape="rect" id="node7" href="classpiranha_1_1series.html" title="piranha::series\&lt; Cf,\l rtk_monomial, poisson\l_series\&lt; Cf \&gt; \&gt;" alt="" coords="312,56,469,112"/><area shape="rect" id="node8" href="classpiranha_1_1series__operators.html" title="Series operators. " alt="" coords="5,45,173,72"/><area shape="rect" id="node9" href="classpiranha_1_1symbol__set.html" title="Symbol set. " alt="" coords="20,96,159,123"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abace7da8a87c85cd5fcab30bfc6b4aa3"><td class="memTemplParams" colspan="2"><a class="anchor" id="abace7da8a87c85cd5fcab30bfc6b4aa3"></a>
template&lt;typename Cf2 &gt; </td></tr>
<tr class="memitem:abace7da8a87c85cd5fcab30bfc6b4aa3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1poisson__series.html#abace7da8a87c85cd5fcab30bfc6b4aa3">rebind</a> = <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf2 &gt;</td></tr>
<tr class="memdesc:abace7da8a87c85cd5fcab30bfc6b4aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Series rebind alias. <br /></td></tr>
<tr class="separator:abace7da8a87c85cd5fcab30bfc6b4aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af0f49cc902d64a77cbaea64f0a2d24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1af0f49cc902d64a77cbaea64f0a2d24"></a>
typedef <a class="el" href="classpiranha_1_1term.html">term</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a1af0f49cc902d64a77cbaea64f0a2d24">term_type</a></td></tr>
<tr class="memdesc:a1af0f49cc902d64a77cbaea64f0a2d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for term type. <br /></td></tr>
<tr class="separator:a1af0f49cc902d64a77cbaea64f0a2d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd2e6c7089dee8f3d370eda2260013a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">container_type::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a3bd2e6c7089dee8f3d370eda2260013a">size_type</a></td></tr>
<tr class="memdesc:a3bd2e6c7089dee8f3d370eda2260013a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type.  <a href="#a3bd2e6c7089dee8f3d370eda2260013a">More...</a><br /></td></tr>
<tr class="separator:a3bd2e6c7089dee8f3d370eda2260013a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e56e9552fe250c2032580e2b7b9b722"><td class="memItemLeft" align="right" valign="top">typedef const_iterator_impl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a9e56e9552fe250c2032580e2b7b9b722">const_iterator</a></td></tr>
<tr class="memdesc:a9e56e9552fe250c2032580e2b7b9b722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator.  <a href="#a9e56e9552fe250c2032580e2b7b9b722">More...</a><br /></td></tr>
<tr class="separator:a9e56e9552fe250c2032580e2b7b9b722"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6414c786f3c31e9d7e656b3bc45559bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1poisson__series.html#a6414c786f3c31e9d7e656b3bc45559bf">poisson_series</a> ()=default</td></tr>
<tr class="memdesc:a6414c786f3c31e9d7e656b3bc45559bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted default constructor.  <a href="#a6414c786f3c31e9d7e656b3bc45559bf">More...</a><br /></td></tr>
<tr class="separator:a6414c786f3c31e9d7e656b3bc45559bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73bc881f00e4ff06743e2f853e5c95d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73bc881f00e4ff06743e2f853e5c95d4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1poisson__series.html#a73bc881f00e4ff06743e2f853e5c95d4">poisson_series</a> (const <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a> &amp;)=default</td></tr>
<tr class="memdesc:a73bc881f00e4ff06743e2f853e5c95d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted copy constructor. <br /></td></tr>
<tr class="separator:a73bc881f00e4ff06743e2f853e5c95d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662d18434011db46e6eadfe122ba6a95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a662d18434011db46e6eadfe122ba6a95"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1poisson__series.html#a662d18434011db46e6eadfe122ba6a95">poisson_series</a> (<a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a662d18434011db46e6eadfe122ba6a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted move constructor. <br /></td></tr>
<tr class="separator:a662d18434011db46e6eadfe122ba6a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5d9694f2ed8d158be2dfa26b30e24e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add5d9694f2ed8d158be2dfa26b30e24e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1poisson__series.html#add5d9694f2ed8d158be2dfa26b30e24e">~poisson_series</a> ()</td></tr>
<tr class="memdesc:add5d9694f2ed8d158be2dfa26b30e24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trivial destructor. <br /></td></tr>
<tr class="separator:add5d9694f2ed8d158be2dfa26b30e24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e92da28208fcc30e585ded41b376dfe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e92da28208fcc30e585ded41b376dfe"></a>
<a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1poisson__series.html#a6e92da28208fcc30e585ded41b376dfe">operator=</a> (const <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a> &amp;)=default</td></tr>
<tr class="memdesc:a6e92da28208fcc30e585ded41b376dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted copy assignment operator. <br /></td></tr>
<tr class="separator:a6e92da28208fcc30e585ded41b376dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77357840ce143c200c45ac50b182e7c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77357840ce143c200c45ac50b182e7c1"></a>
<a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1poisson__series.html#a77357840ce143c200c45ac50b182e7c1">operator=</a> (<a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a77357840ce143c200c45ac50b182e7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted move assignment operator. <br /></td></tr>
<tr class="separator:a77357840ce143c200c45ac50b182e7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592243b5a76e2acfaa4abad4b8795ab1"><td class="memTemplParams" colspan="2">template&lt;typename T  = poisson_series, sin_cos_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a592243b5a76e2acfaa4abad4b8795ab1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1poisson__series.html#a592243b5a76e2acfaa4abad4b8795ab1">sin</a> () const </td></tr>
<tr class="memdesc:a592243b5a76e2acfaa4abad4b8795ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override sine implementation.  <a href="#a592243b5a76e2acfaa4abad4b8795ab1">More...</a><br /></td></tr>
<tr class="separator:a592243b5a76e2acfaa4abad4b8795ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911ea7ce5211800869e6e7964e83536e"><td class="memTemplParams" colspan="2">template&lt;typename T  = poisson_series, sin_cos_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a911ea7ce5211800869e6e7964e83536e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1poisson__series.html#a911ea7ce5211800869e6e7964e83536e">cos</a> () const </td></tr>
<tr class="memdesc:a911ea7ce5211800869e6e7964e83536e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override cosine implementation.  <a href="#a911ea7ce5211800869e6e7964e83536e">More...</a><br /></td></tr>
<tr class="separator:a911ea7ce5211800869e6e7964e83536e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4f77e9e1d967c5ce6754464839cd17"><td class="memTemplParams" colspan="2">template&lt;typename T  = poisson_series, integrate_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1f4f77e9e1d967c5ce6754464839cd17"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1poisson__series.html#a1f4f77e9e1d967c5ce6754464839cd17">integrate</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a1f4f77e9e1d967c5ce6754464839cd17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integration.  <a href="#a1f4f77e9e1d967c5ce6754464839cd17">More...</a><br /></td></tr>
<tr class="separator:a1f4f77e9e1d967c5ce6754464839cd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac54ad7a9473b7c9820fb64a261a173"><td class="memTemplParams" colspan="2">template&lt;typename T  = poisson_series&gt; </td></tr>
<tr class="memitem:a1ac54ad7a9473b7c9820fb64a261a173"><td class="memTemplItemLeft" align="right" valign="top">ti_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1poisson__series.html#a1ac54ad7a9473b7c9820fb64a261a173">t_integrate</a> () const </td></tr>
<tr class="memdesc:a1ac54ad7a9473b7c9820fb64a261a173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time integration.  <a href="#a1ac54ad7a9473b7c9820fb64a261a173">More...</a><br /></td></tr>
<tr class="separator:a1ac54ad7a9473b7c9820fb64a261a173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ceadbb37c9f10543e8859af0a759814"><td class="memItemLeft" align="right" valign="top">degree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a6ceadbb37c9f10543e8859af0a759814">degree</a> () const</td></tr>
<tr class="memdesc:a6ceadbb37c9f10543e8859af0a759814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total degree.  <a href="#a6ceadbb37c9f10543e8859af0a759814">More...</a><br /></td></tr>
<tr class="separator:a6ceadbb37c9f10543e8859af0a759814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab4e2b580bf23c2f903123be13c9d15"><td class="memItemLeft" align="right" valign="top">pdegree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#abab4e2b580bf23c2f903123be13c9d15">degree</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:abab4e2b580bf23c2f903123be13c9d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial degree.  <a href="#abab4e2b580bf23c2f903123be13c9d15">More...</a><br /></td></tr>
<tr class="separator:abab4e2b580bf23c2f903123be13c9d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b69ae8e0fc896120a45464fc59c4cc2"><td class="memItemLeft" align="right" valign="top">ldegree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a5b69ae8e0fc896120a45464fc59c4cc2">ldegree</a> () const</td></tr>
<tr class="memdesc:a5b69ae8e0fc896120a45464fc59c4cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total low degree.  <a href="#a5b69ae8e0fc896120a45464fc59c4cc2">More...</a><br /></td></tr>
<tr class="separator:a5b69ae8e0fc896120a45464fc59c4cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90a2cecef949780b42d47aaf699c65b"><td class="memItemLeft" align="right" valign="top">pldegree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#ad90a2cecef949780b42d47aaf699c65b">ldegree</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:ad90a2cecef949780b42d47aaf699c65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial low degree.  <a href="#ad90a2cecef949780b42d47aaf699c65b">More...</a><br /></td></tr>
<tr class="separator:ad90a2cecef949780b42d47aaf699c65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c426d939bc75a2ba8365a6f82c91196"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a3c426d939bc75a2ba8365a6f82c91196">truncate_degree</a> (const T &amp;max_degree) const</td></tr>
<tr class="memdesc:a3c426d939bc75a2ba8365a6f82c91196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total degree truncation.  <a href="#a3c426d939bc75a2ba8365a6f82c91196">More...</a><br /></td></tr>
<tr class="separator:a3c426d939bc75a2ba8365a6f82c91196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c335e9114a9be65cc447eed2605c43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#ab6c335e9114a9be65cc447eed2605c43">truncate_degree</a> (const T &amp;max_degree, const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:ab6c335e9114a9be65cc447eed2605c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial degree truncation.  <a href="#ab6c335e9114a9be65cc447eed2605c43">More...</a><br /></td></tr>
<tr class="separator:ab6c335e9114a9be65cc447eed2605c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7c4667e6e9e527e744479cb8baf06c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a6b7c4667e6e9e527e744479cb8baf06c">auto_truncate</a> ()</td></tr>
<tr class="memdesc:a6b7c4667e6e9e527e744479cb8baf06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform automatic truncation.  <a href="#a6b7c4667e6e9e527e744479cb8baf06c">More...</a><br /></td></tr>
<tr class="separator:a6b7c4667e6e9e527e744479cb8baf06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e34001559b2062e811d52dfee2b065"><td class="memItemLeft" align="right" valign="top">ipow_subs_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1ipow__substitutable__series.html#a65e34001559b2062e811d52dfee2b065">ipow_subs</a> (const std::string &amp;name, const <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b">integer</a> &amp;n, const T &amp;x) const</td></tr>
<tr class="memdesc:a65e34001559b2062e811d52dfee2b065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution.  <a href="#a65e34001559b2062e811d52dfee2b065">More...</a><br /></td></tr>
<tr class="separator:a65e34001559b2062e811d52dfee2b065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08e5b170f2161bdca8c6129dcb51025"><td class="memItemLeft" align="right" valign="top">ipow_subs_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1ipow__substitutable__series.html#ae08e5b170f2161bdca8c6129dcb51025">ipow_subs</a> (const std::string &amp;name, const Int &amp;n, const T &amp;x) const</td></tr>
<tr class="memdesc:ae08e5b170f2161bdca8c6129dcb51025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution.  <a href="#ae08e5b170f2161bdca8c6129dcb51025">More...</a><br /></td></tr>
<tr class="separator:ae08e5b170f2161bdca8c6129dcb51025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ec2b3885daaadf883e88322b4c3c46"><td class="memItemLeft" align="right" valign="top">subs_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1substitutable__series.html#a16ec2b3885daaadf883e88322b4c3c46">subs</a> (const std::string &amp;name, const T &amp;x) const</td></tr>
<tr class="memdesc:a16ec2b3885daaadf883e88322b4c3c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution.  <a href="#a16ec2b3885daaadf883e88322b4c3c46">More...</a><br /></td></tr>
<tr class="separator:a16ec2b3885daaadf883e88322b4c3c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041ef69409050af66478c0cc7c15419e"><td class="memItemLeft" align="right" valign="top">t_subs_type&lt; T, U &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1t__substitutable__series.html#a041ef69409050af66478c0cc7c15419e">t_subs</a> (const std::string &amp;name, const T &amp;c, const U &amp;s) const</td></tr>
<tr class="memdesc:a041ef69409050af66478c0cc7c15419e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigonometric substitution.  <a href="#a041ef69409050af66478c0cc7c15419e">More...</a><br /></td></tr>
<tr class="separator:a041ef69409050af66478c0cc7c15419e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca20577870a846a98b720c97656dc592"><td class="memItemLeft" align="right" valign="top">t_degree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html#aca20577870a846a98b720c97656dc592">t_degree</a> () const</td></tr>
<tr class="memdesc:aca20577870a846a98b720c97656dc592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigonometric degree.  <a href="#aca20577870a846a98b720c97656dc592">More...</a><br /></td></tr>
<tr class="separator:aca20577870a846a98b720c97656dc592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2894c982307df448677b21ae86f4a0"><td class="memItemLeft" align="right" valign="top">pt_degree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html#aac2894c982307df448677b21ae86f4a0">t_degree</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:aac2894c982307df448677b21ae86f4a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trigonometric degree.  <a href="#aac2894c982307df448677b21ae86f4a0">More...</a><br /></td></tr>
<tr class="separator:aac2894c982307df448677b21ae86f4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2773cd4458563ff78836ed7fa93679d1"><td class="memItemLeft" align="right" valign="top">t_ldegree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html#a2773cd4458563ff78836ed7fa93679d1">t_ldegree</a> () const</td></tr>
<tr class="memdesc:a2773cd4458563ff78836ed7fa93679d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigonometric low degree.  <a href="#a2773cd4458563ff78836ed7fa93679d1">More...</a><br /></td></tr>
<tr class="separator:a2773cd4458563ff78836ed7fa93679d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed013f36e3f618201159d40955cd019"><td class="memItemLeft" align="right" valign="top">pt_ldegree_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html#a3ed013f36e3f618201159d40955cd019">t_ldegree</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:a3ed013f36e3f618201159d40955cd019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trigonometric low degree.  <a href="#a3ed013f36e3f618201159d40955cd019">More...</a><br /></td></tr>
<tr class="separator:a3ed013f36e3f618201159d40955cd019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3cdb9b1100b27d76623eafbfb4e949a"><td class="memItemLeft" align="right" valign="top">t_order_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html#ab3cdb9b1100b27d76623eafbfb4e949a">t_order</a> () const</td></tr>
<tr class="memdesc:ab3cdb9b1100b27d76623eafbfb4e949a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigonometric order.  <a href="#ab3cdb9b1100b27d76623eafbfb4e949a">More...</a><br /></td></tr>
<tr class="separator:ab3cdb9b1100b27d76623eafbfb4e949a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84131d0a7471e675675f100a83cc353"><td class="memItemLeft" align="right" valign="top">pt_order_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html#af84131d0a7471e675675f100a83cc353">t_order</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:af84131d0a7471e675675f100a83cc353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trigonometric order.  <a href="#af84131d0a7471e675675f100a83cc353">More...</a><br /></td></tr>
<tr class="separator:af84131d0a7471e675675f100a83cc353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0708c4fa669662d35636e08d21c1de4"><td class="memItemLeft" align="right" valign="top">t_lorder_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html#ab0708c4fa669662d35636e08d21c1de4">t_lorder</a> () const</td></tr>
<tr class="memdesc:ab0708c4fa669662d35636e08d21c1de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigonometric low order.  <a href="#ab0708c4fa669662d35636e08d21c1de4">More...</a><br /></td></tr>
<tr class="separator:ab0708c4fa669662d35636e08d21c1de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3c65cf42926a27bb47a449911ecc76"><td class="memItemLeft" align="right" valign="top">pt_lorder_type&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html#aca3c65cf42926a27bb47a449911ecc76">t_lorder</a> (const std::vector&lt; std::string &gt; &amp;names) const</td></tr>
<tr class="memdesc:aca3c65cf42926a27bb47a449911ecc76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trigonometric low order.  <a href="#aca3c65cf42926a27bb47a449911ecc76">More...</a><br /></td></tr>
<tr class="separator:aca3c65cf42926a27bb47a449911ecc76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae02a113d00a1cd291ac2d8052e1efd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html#a3bd2e6c7089dee8f3d370eda2260013a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#acae02a113d00a1cd291ac2d8052e1efd">size</a> () const</td></tr>
<tr class="memdesc:acae02a113d00a1cd291ac2d8052e1efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Series size.  <a href="#acae02a113d00a1cd291ac2d8052e1efd">More...</a><br /></td></tr>
<tr class="separator:acae02a113d00a1cd291ac2d8052e1efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d693909213b238270bd4687a196bbb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a6d693909213b238270bd4687a196bbb5">empty</a> () const</td></tr>
<tr class="memdesc:a6d693909213b238270bd4687a196bbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty test.  <a href="#a6d693909213b238270bd4687a196bbb5">More...</a><br /></td></tr>
<tr class="separator:a6d693909213b238270bd4687a196bbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04adb9b939dda140547a027e461a4384"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a04adb9b939dda140547a027e461a4384">is_single_coefficient</a> () const</td></tr>
<tr class="memdesc:a04adb9b939dda140547a027e461a4384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for single-coefficient series.  <a href="#a04adb9b939dda140547a027e461a4384">More...</a><br /></td></tr>
<tr class="separator:a04adb9b939dda140547a027e461a4384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac049565106ddee1881fedf6481de9458"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458">insert</a> (T &amp;&amp;<a class="el" href="classpiranha_1_1term.html">term</a>)</td></tr>
<tr class="memdesc:ac049565106ddee1881fedf6481de9458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert term.  <a href="#ac049565106ddee1881fedf6481de9458">More...</a><br /></td></tr>
<tr class="separator:ac049565106ddee1881fedf6481de9458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1924707f1dbc3c82284e48bdaf87f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a2d1924707f1dbc3c82284e48bdaf87f1">insert</a> (T &amp;&amp;<a class="el" href="classpiranha_1_1term.html">term</a>)</td></tr>
<tr class="memdesc:a2d1924707f1dbc3c82284e48bdaf87f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert generic term with <code>Sign = true</code>.  <a href="#a2d1924707f1dbc3c82284e48bdaf87f1">More...</a><br /></td></tr>
<tr class="separator:a2d1924707f1dbc3c82284e48bdaf87f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7999e7a1d36a9519ca4b373f8886ed40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a7999e7a1d36a9519ca4b373f8886ed40">operator+</a> () const</td></tr>
<tr class="memdesc:a7999e7a1d36a9519ca4b373f8886ed40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity operator.  <a href="#a7999e7a1d36a9519ca4b373f8886ed40">More...</a><br /></td></tr>
<tr class="separator:a7999e7a1d36a9519ca4b373f8886ed40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6835fa85739cf3f53bea993964b3b80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#af6835fa85739cf3f53bea993964b3b80">operator-</a> () const</td></tr>
<tr class="memdesc:af6835fa85739cf3f53bea993964b3b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negation operator.  <a href="#af6835fa85739cf3f53bea993964b3b80">More...</a><br /></td></tr>
<tr class="separator:af6835fa85739cf3f53bea993964b3b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dce8005ee4919ce2f68b508e6292118"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a3dce8005ee4919ce2f68b508e6292118">negate</a> ()</td></tr>
<tr class="memdesc:a3dce8005ee4919ce2f68b508e6292118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate series in-place.  <a href="#a3dce8005ee4919ce2f68b508e6292118">More...</a><br /></td></tr>
<tr class="separator:a3dce8005ee4919ce2f68b508e6292118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ddd34099884d45825b72155d1d6e48"><td class="memItemLeft" align="right" valign="top">pow_ret_type&lt; T, U &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a76ddd34099884d45825b72155d1d6e48">pow</a> (const T &amp;x) const</td></tr>
<tr class="memdesc:a76ddd34099884d45825b72155d1d6e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponentiation.  <a href="#a76ddd34099884d45825b72155d1d6e48">More...</a><br /></td></tr>
<tr class="separator:a76ddd34099884d45825b72155d1d6e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97624cbcc7139b6f70682d908f759656"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a97624cbcc7139b6f70682d908f759656">apply_cf_functor</a> (std::function&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>(const typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a> &amp;)&gt; f) const</td></tr>
<tr class="memdesc:a97624cbcc7139b6f70682d908f759656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply functor to single-coefficient series.  <a href="#a97624cbcc7139b6f70682d908f759656">More...</a><br /></td></tr>
<tr class="separator:a97624cbcc7139b6f70682d908f759656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816a2a0ef41921df71a9c0f518ddd653"><td class="memItemLeft" align="right" valign="top">partial_type&lt; Series &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a816a2a0ef41921df71a9c0f518ddd653">partial</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a816a2a0ef41921df71a9c0f518ddd653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial derivative.  <a href="#a816a2a0ef41921df71a9c0f518ddd653">More...</a><br /></td></tr>
<tr class="separator:a816a2a0ef41921df71a9c0f518ddd653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfeae53f7a213c8aa8c29e9d3f65e4d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html#a9e56e9552fe250c2032580e2b7b9b722">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#acfeae53f7a213c8aa8c29e9d3f65e4d0">begin</a> () const</td></tr>
<tr class="memdesc:acfeae53f7a213c8aa8c29e9d3f65e4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin iterator.  <a href="#acfeae53f7a213c8aa8c29e9d3f65e4d0">More...</a><br /></td></tr>
<tr class="separator:acfeae53f7a213c8aa8c29e9d3f65e4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08dd51abc504168912f97e7569d7fb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html#a9e56e9552fe250c2032580e2b7b9b722">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#af08dd51abc504168912f97e7569d7fb0">end</a> () const</td></tr>
<tr class="memdesc:af08dd51abc504168912f97e7569d7fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">End iterator.  <a href="#af08dd51abc504168912f97e7569d7fb0">More...</a><br /></td></tr>
<tr class="separator:af08dd51abc504168912f97e7569d7fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2bc7a506a97ab87d1013abafec409c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a4c2bc7a506a97ab87d1013abafec409c">filter</a> (std::function&lt; bool(const std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &amp;)&gt; func) const</td></tr>
<tr class="memdesc:a4c2bc7a506a97ab87d1013abafec409c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Term filtering.  <a href="#a4c2bc7a506a97ab87d1013abafec409c">More...</a><br /></td></tr>
<tr class="separator:a4c2bc7a506a97ab87d1013abafec409c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2be8f9cd018cea990d8d33ff74b34e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a4d2be8f9cd018cea990d8d33ff74b34e">transform</a> (std::function&lt; std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;(const std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &amp;)&gt; func) const</td></tr>
<tr class="memdesc:a4d2be8f9cd018cea990d8d33ff74b34e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Term transformation.  <a href="#a4d2be8f9cd018cea990d8d33ff74b34e">More...</a><br /></td></tr>
<tr class="separator:a4d2be8f9cd018cea990d8d33ff74b34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa040344d49db37a9a4bf9d2c32c7221b"><td class="memItemLeft" align="right" valign="top">eval_type&lt; Series, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#aa040344d49db37a9a4bf9d2c32c7221b">evaluate</a> (const std::unordered_map&lt; std::string, T &gt; &amp;dict) const</td></tr>
<tr class="memdesc:aa040344d49db37a9a4bf9d2c32c7221b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation.  <a href="#aa040344d49db37a9a4bf9d2c32c7221b">More...</a><br /></td></tr>
<tr class="separator:aa040344d49db37a9a4bf9d2c32c7221b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92d728b975d0dfda12ad7ddb168c984"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ad92d728b975d0dfda12ad7ddb168c984">trim</a> () const</td></tr>
<tr class="memdesc:ad92d728b975d0dfda12ad7ddb168c984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim.  <a href="#ad92d728b975d0dfda12ad7ddb168c984">More...</a><br /></td></tr>
<tr class="separator:ad92d728b975d0dfda12ad7ddb168c984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fc18640bdfa5d96217434a533e0567"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ad2fc18640bdfa5d96217434a533e0567">print_tex</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:ad2fc18640bdfa5d96217434a533e0567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print in TeX mode.  <a href="#ad2fc18640bdfa5d96217434a533e0567">More...</a><br /></td></tr>
<tr class="separator:ad2fc18640bdfa5d96217434a533e0567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7e68abc23ec8d71664d463cf83c8e3"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a4f7e68abc23ec8d71664d463cf83c8e3">hash</a> () const</td></tr>
<tr class="memdesc:a4f7e68abc23ec8d71664d463cf83c8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash value.  <a href="#a4f7e68abc23ec8d71664d463cf83c8e3">More...</a><br /></td></tr>
<tr class="separator:a4f7e68abc23ec8d71664d463cf83c8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3303c0cfd2399b9f71570f43e85f8ee3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a3303c0cfd2399b9f71570f43e85f8ee3">is_identical</a> (const <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &amp;other) const</td></tr>
<tr class="memdesc:a3303c0cfd2399b9f71570f43e85f8ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for identical series.  <a href="#a3303c0cfd2399b9f71570f43e85f8ee3">More...</a><br /></td></tr>
<tr class="separator:a3303c0cfd2399b9f71570f43e85f8ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4a9e7100d9842f3dbc6e7fdd04ee49"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a7c4a9e7100d9842f3dbc6e7fdd04ee49">get_symbol_set</a> () const</td></tr>
<tr class="memdesc:a7c4a9e7100d9842f3dbc6e7fdd04ee49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol set getter.  <a href="#a7c4a9e7100d9842f3dbc6e7fdd04ee49">More...</a><br /></td></tr>
<tr class="separator:a7c4a9e7100d9842f3dbc6e7fdd04ee49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3752460cc7a4c4cc0bea3330b31bcc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ac3752460cc7a4c4cc0bea3330b31bcc9">set_symbol_set</a> (const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a> &amp;args)</td></tr>
<tr class="memdesc:ac3752460cc7a4c4cc0bea3330b31bcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol set setter.  <a href="#ac3752460cc7a4c4cc0bea3330b31bcc9">More...</a><br /></td></tr>
<tr class="separator:ac3752460cc7a4c4cc0bea3330b31bcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Table-querying methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods to query the properties of the internal container used to store the terms. </p>
</div></td></tr>
<tr class="memitem:a57b8b94d7b67c5e91ec9bab039a37f73"><td class="memItemLeft" align="right" valign="top">sparsity_info_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a57b8b94d7b67c5e91ec9bab039a37f73">table_sparsity</a> () const</td></tr>
<tr class="memdesc:a57b8b94d7b67c5e91ec9bab039a37f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table sparsity.  <a href="#a57b8b94d7b67c5e91ec9bab039a37f73">More...</a><br /></td></tr>
<tr class="separator:a57b8b94d7b67c5e91ec9bab039a37f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc5c9b27d9dbf3cdca9102eabb09003"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a8cc5c9b27d9dbf3cdca9102eabb09003">table_load_factor</a> () const</td></tr>
<tr class="memdesc:a8cc5c9b27d9dbf3cdca9102eabb09003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table load factor.  <a href="#a8cc5c9b27d9dbf3cdca9102eabb09003">More...</a><br /></td></tr>
<tr class="separator:a8cc5c9b27d9dbf3cdca9102eabb09003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259a3dfca6849c5097246a4a0235cc61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html#a3bd2e6c7089dee8f3d370eda2260013a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a259a3dfca6849c5097246a4a0235cc61">table_bucket_count</a> () const</td></tr>
<tr class="memdesc:a259a3dfca6849c5097246a4a0235cc61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table bucket count.  <a href="#a259a3dfca6849c5097246a4a0235cc61">More...</a><br /></td></tr>
<tr class="separator:a259a3dfca6849c5097246a4a0235cc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abc967cd40e03ec98f1036506be9aaba0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#abc967cd40e03ec98f1036506be9aaba0">set_auto_truncate_degree</a> (const U &amp;max_degree)</td></tr>
<tr class="memdesc:abc967cd40e03ec98f1036506be9aaba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set total-degree-based auto-truncation.  <a href="#abc967cd40e03ec98f1036506be9aaba0">More...</a><br /></td></tr>
<tr class="separator:abc967cd40e03ec98f1036506be9aaba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf63eaabd12a4442ef8db73d6408e0e4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#adf63eaabd12a4442ef8db73d6408e0e4">set_auto_truncate_degree</a> (const U &amp;max_degree, const std::vector&lt; std::string &gt; &amp;names)</td></tr>
<tr class="memdesc:adf63eaabd12a4442ef8db73d6408e0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set partial-degree-based auto-truncation.  <a href="#adf63eaabd12a4442ef8db73d6408e0e4">More...</a><br /></td></tr>
<tr class="separator:adf63eaabd12a4442ef8db73d6408e0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c74bd5642d0acd2cb40697f67502266"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a9c74bd5642d0acd2cb40697f67502266">unset_auto_truncate_degree</a> ()</td></tr>
<tr class="memdesc:a9c74bd5642d0acd2cb40697f67502266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable degree-based auto-truncation.  <a href="#a9c74bd5642d0acd2cb40697f67502266">More...</a><br /></td></tr>
<tr class="separator:a9c74bd5642d0acd2cb40697f67502266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c21ffcb7def44fda1f2f50dacc9f3ae"><td class="memItemLeft" align="right" valign="top">static std::tuple&lt; int, degree_type&lt; T &gt;, std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html#a9c21ffcb7def44fda1f2f50dacc9f3ae">get_auto_truncate_degree</a> ()</td></tr>
<tr class="memdesc:a9c21ffcb7def44fda1f2f50dacc9f3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the status of the degree-based auto-truncation mechanism.  <a href="#a9c21ffcb7def44fda1f2f50dacc9f3ae">More...</a><br /></td></tr>
<tr class="separator:a9c21ffcb7def44fda1f2f50dacc9f3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7da3b838cc92a235785ae4e339a1e97"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ae7da3b838cc92a235785ae4e339a1e97">clear_pow_cache</a> ()</td></tr>
<tr class="memdesc:ae7da3b838cc92a235785ae4e339a1e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the internal cache of natural powers.  <a href="#ae7da3b838cc92a235785ae4e339a1e97">More...</a><br /></td></tr>
<tr class="separator:ae7da3b838cc92a235785ae4e339a1e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee2cef7972c1ed1a410351c9f3e175e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a5ee2cef7972c1ed1a410351c9f3e175e">register_custom_derivative</a> (const std::string &amp;name, F func)</td></tr>
<tr class="memdesc:a5ee2cef7972c1ed1a410351c9f3e175e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register custom partial derivative.  <a href="#a5ee2cef7972c1ed1a410351c9f3e175e">More...</a><br /></td></tr>
<tr class="separator:a5ee2cef7972c1ed1a410351c9f3e175e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041b2099313fa16a9b13d55ce7c0d930"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a041b2099313fa16a9b13d55ce7c0d930">unregister_custom_derivative</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a041b2099313fa16a9b13d55ce7c0d930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister custom partial derivative.  <a href="#a041b2099313fa16a9b13d55ce7c0d930">More...</a><br /></td></tr>
<tr class="separator:a041b2099313fa16a9b13d55ce7c0d930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40680bb3e8f2801b3754f0b03abb0633"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a40680bb3e8f2801b3754f0b03abb0633">unregister_all_custom_derivatives</a> ()</td></tr>
<tr class="memdesc:a40680bb3e8f2801b3754f0b03abb0633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister all custom partial derivatives.  <a href="#a40680bb3e8f2801b3754f0b03abb0633">More...</a><br /></td></tr>
<tr class="separator:a40680bb3e8f2801b3754f0b03abb0633"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ad2bf73c31b49054d58efbc11b34883dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2bf73c31b49054d58efbc11b34883dc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ad2bf73c31b49054d58efbc11b34883dc">container_type</a> = <a class="el" href="classpiranha_1_1hash__set.html">hash_set</a>&lt; <a class="el" href="classpiranha_1_1series.html#a1af0f49cc902d64a77cbaea64f0a2d24">term_type</a>, detail::term_hasher&lt; <a class="el" href="classpiranha_1_1series.html#a1af0f49cc902d64a77cbaea64f0a2d24">term_type</a> &gt;&gt;</td></tr>
<tr class="memdesc:ad2bf73c31b49054d58efbc11b34883dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container type for terms. <br /></td></tr>
<tr class="separator:ad2bf73c31b49054d58efbc11b34883dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4c1d33d3d9ed04b935e3024db2e46f04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c1d33d3d9ed04b935e3024db2e46f04"></a>
<a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a4c1d33d3d9ed04b935e3024db2e46f04">m_symbol_set</a></td></tr>
<tr class="memdesc:a4c1d33d3d9ed04b935e3024db2e46f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol set. <br /></td></tr>
<tr class="separator:a4c1d33d3d9ed04b935e3024db2e46f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ac93f383a79c3325197d6a951e9dd5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68ac93f383a79c3325197d6a951e9dd5"></a>
<a class="el" href="classpiranha_1_1series.html#ad2bf73c31b49054d58efbc11b34883dc">container_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a68ac93f383a79c3325197d6a951e9dd5">m_container</a></td></tr>
<tr class="memdesc:a68ac93f383a79c3325197d6a951e9dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terms container. <br /></td></tr>
<tr class="separator:a68ac93f383a79c3325197d6a951e9dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Cf&gt;<br />
class piranha::poisson_series&lt; Cf &gt;</h3>

<p>Poisson series class. </p>
<p>This class represents multivariate Poisson series as collections of multivariate Poisson series terms, in which the trigonometric monomials are represented by <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805" title="Alias for piranha::real_trigonometric_kronecker_monomial with default type. ">piranha::rtk_monomial</a>. <code>Cf</code> represents the ring over which the Poisson series is defined.</p>
<p>This class satisfies the <a class="el" href="classpiranha_1_1is__series.html" title="Type trait to detect series types. ">piranha::is_series</a> type trait.</p>
<h2>Type requirements</h2>
<p><code>Cf</code> must be suitable for use in <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a> as first template argument.</p>
<h2>Exception safety guarantee</h2>
<p>This class provides the same guarantee as the base series type it derives from.</p>
<h2>Move semantics</h2>
<p>Move semantics is equivalent to the move semantics of the base series type it derives from.</p>
<h2>Serialization</h2>
<p>This class supports serialization if the underlying coefficient type does.</p>
<dl class="section author"><dt>Author</dt><dd>Francesco Biscani (<a href="#" onclick="location.href='mai'+'lto:'+'blu'+'es'+'car'+'ni'+'@gm'+'ai'+'l.c'+'om'; return false;">blues<span style="display: none;">.nosp@m.</span>carn<span style="display: none;">.nosp@m.</span>i@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a>) </dd></dl>

<p>Definition at line <a class="el" href="poisson__series__fwd_8hpp_source.html#l00030">30</a> of file <a class="el" href="poisson__series__fwd_8hpp_source.html">poisson_series_fwd.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a9e56e9552fe250c2032580e2b7b9b722"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef const_iterator_impl <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::<a class="el" href="classpiranha_1_1series.html#a9e56e9552fe250c2032580e2b7b9b722">const_iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const iterator. </p>
<p>Iterator type that can be used to iterate over the terms of the series. The object returned upon dereferentiation is an <code>std::pair</code> in which the first element is a copy of the coefficient of the term, the second element a single-term instance of <code>Derived</code> constructed from the term's key and a unitary coefficient.</p>
<p>This iterator is an input iterator which additionally offers the multi-pass guarantee.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpiranha_1_1series.html#acfeae53f7a213c8aa8c29e9d3f65e4d0" title="Begin iterator. ">piranha::series::begin()</a> and <a class="el" href="classpiranha_1_1series.html#af08dd51abc504168912f97e7569d7fb0" title="End iterator. ">piranha::series::end()</a>. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l01801">1801</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3bd2e6c7089dee8f3d370eda2260013a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">container_type::size_type</a> <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::<a class="el" href="classpiranha_1_1series.html#a3bd2e6c7089dee8f3d370eda2260013a">size_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size type. </p>
<p>Used to represent the number of terms in the series. Equivalent to <a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591" title="Size type. ">piranha::hash_set::size_type</a>. </p>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l01789">1789</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6414c786f3c31e9d7e656b3bc45559bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1poisson__series.html">piranha::poisson_series</a>&lt; Cf &gt;::<a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defaulted default constructor. </p>
<p>Will construct a Poisson series with zero terms. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a97624cbcc7139b6f70682d908f759656"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::apply_cf_functor </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>(const typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply functor to single-coefficient series. </p>
<p>This method can be called successfully only on single-coefficient series.</p>
<p>If the series is empty, the return value will be a series with single term and unitary key in which the coefficient is the result of applying the functor <code>f</code> on a coefficient instance constructed from the integral constant "0".</p>
<p>If the series has a single term with unitary key, the return value will be a series with single term and unitary key in which the coefficient is the result of applying the functor <code>f</code> to the only coefficient of <code>this</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>coefficient functor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a series constructed via the application of <code>f</code> to a coefficient instance as described above.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the series is not single-coefficient. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the call operator of <code>f</code>,</li>
<li>construction of coefficient, key and term instances,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li><a class="el" href="classpiranha_1_1series.html#a04adb9b939dda140547a027e461a4384" title="Test for single-coefficient series. ">is_single_coefficient()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02151">2151</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b7c4667e6e9e527e744479cb8baf06c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::auto_truncate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform automatic truncation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>This method will truncate <code>this</code> according to the truncation settings from <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a>. Additionally, it will also call the <code>auto_truncate()</code> method from the parent series type, if it exists.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>threading primitives,</li>
<li>construction and/or assignment of the degree type,</li>
<li>memory errors in standard containers,</li>
<li><a class="el" href="classpiranha_1_1power__series.html#a3c426d939bc75a2ba8365a6f82c91196" title="Total degree truncation. ">truncate_degree()</a>,</li>
<li>the <code>auto_truncate()</code> method from the parent series type, if it exists. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="power__series_8hpp_source.html#l00585">585</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acfeae53f7a213c8aa8c29e9d3f65e4d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html#a9e56e9552fe250c2032580e2b7b9b722">const_iterator</a> <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin iterator. </p>
<p>Return an iterator to the first term of the series. The returned iterator will provide, when dereferenced, an <code>std::pair</code> in which the first element is a copy of the coefficient of the term, whereas the second element is a single-term instance of <code>Derived</code> built from the term's key and a unitary coefficient.</p>
<p>Note that terms are stored unordered in the series, hence it is not defined which particular term will be returned by calling this method. The only guarantee is that the iterator can be used to transverse all the series' terms until <a class="el" href="classpiranha_1_1series.html#af08dd51abc504168912f97e7569d7fb0" title="End iterator. ">piranha::series::end()</a> is eventually reached.</p>
<p>Calling any non-const method on the series will invalidate the iterators obtained via <a class="el" href="classpiranha_1_1series.html#acfeae53f7a213c8aa8c29e9d3f65e4d0" title="Begin iterator. ">piranha::series::begin()</a> and <a class="el" href="classpiranha_1_1series.html#af08dd51abc504168912f97e7569d7fb0" title="End iterator. ">piranha::series::end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the first term of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>construction and assignment of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>construction of term, coefficient and key instances. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02287">2287</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae7da3b838cc92a235785ae4e339a1e97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::clear_pow_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the internal cache of natural powers. </p>
<p>This method can be used to clear the cache of natural powers of series maintained by <a class="el" href="classpiranha_1_1series.html#a76ddd34099884d45825b72155d1d6e48" title="Exponentiation. ">piranha::series::pow()</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by threading primitives. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02125">2125</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a911ea7ce5211800869e6e7964e83536e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf &gt; </div>
<div class="memtemplate">
template&lt;typename T  = poisson_series, sin_cos_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a> <a class="el" href="classpiranha_1_1poisson__series.html">piranha::poisson_series</a>&lt; Cf &gt;::cos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override cosine implementation. </p>
<dl class="section note"><dt>Note</dt><dd>This template method is enabled only if either:<ul>
<li>the coefficient type is a <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a> whose coefficient type supports <a class="el" href="namespacepiranha.html#a712714b1e1348f73ec01687d5d5c9b2d" title="Safe cast. ">piranha::safe_cast()</a> to <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b" title="Alias for piranha::mp_integer with default bit size. ">piranha::integer</a>, or</li>
<li>the coefficient type has a <a class="el" href="namespacepiranha_1_1math.html#a88eb0469177875f0133594816a8ba382" title="Cosine. ">math::cos()</a> implementation whose return type is the coefficient type.</li>
</ul>
</dd></dl>
<p>The procedure is the same as explained in <a class="el" href="classpiranha_1_1poisson__series.html#a592243b5a76e2acfaa4abad4b8795ab1" title="Override sine implementation. ">sin()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>cosine of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classpiranha_1_1poisson__series.html#a592243b5a76e2acfaa4abad4b8795ab1" title="Override sine implementation. ">sin()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="poisson__series_8hpp_source.html#l00457">457</a> of file <a class="el" href="poisson__series_8hpp_source.html">poisson_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6ceadbb37c9f10543e8859af0a759814"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">degree_type&lt;T&gt; <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>The degree of the series is the maximum degree of its terms. If the series is empty, zero will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>the total degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the construction of return type,</li>
<li>the calculation of the degree of each term,</li>
<li>the assignment and less-than operators for the return type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="power__series_8hpp_source.html#l00313">313</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abab4e2b580bf23c2f903123be13c9d15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pdegree_type&lt;T&gt; <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::degree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>The partial degree of the series is the maximum partial degree of its terms. If the series is empty, zero will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>names of the variables to be considered in the computation of the degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the partial degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the construction of return type,</li>
<li>the calculation of the degree of each term,</li>
<li>the assignment and less-than operators for the return type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="power__series_8hpp_source.html#l00361">361</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d693909213b238270bd4687a196bbb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty test. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <a class="el" href="classpiranha_1_1series.html#acae02a113d00a1cd291ac2d8052e1efd" title="Series size. ">size()</a> is nonzero, <code>false</code> otherwise. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l01903">1903</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af08dd51abc504168912f97e7569d7fb0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html#a9e56e9552fe250c2032580e2b7b9b722">const_iterator</a> <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End iterator. </p>
<p>Return an iterator one past the last term of the series. See the documentation of <a class="el" href="classpiranha_1_1series.html#acfeae53f7a213c8aa8c29e9d3f65e4d0" title="Begin iterator. ">piranha::series::begin()</a> on how the returned iterator can be used.</p>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the end of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>construction and assignment of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>construction of term, coefficient and key instances. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02308">2308</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa040344d49db37a9a4bf9d2c32c7221b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">eval_type&lt;Series,T&gt; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; std::string, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dict</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if:<ul>
<li>both the coefficient and the key types are evaluable,</li>
<li>the evaluated types are suitable for use in <a class="el" href="namespacepiranha_1_1math.html#a904f85d9a1ef8c95384bcb89ff0795e7" title="Multiply-accumulate. ">piranha::math::multiply_accumulate()</a>,</li>
<li>the return type is constructible from <code>int</code>.</li>
</ul>
</dd></dl>
<p>Series evaluation starts with a zero-initialised instance of the return type, which is determined according to the evaluation types of coefficient and key. The return value accumulates the evaluation of all terms in the series via the product of the evaluations of the coefficient-key pairs in each term. The input dictionary <code>dict</code> specifies with which value each symbolic quantity will be evaluated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dict</td><td>dictionary of that will be used for evaluation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>evaluation of the series according to the evaluation dictionary <code>dict</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>coefficient and key evaluation,</li>
<li>insertion operations on <code>std::unordered_map</code>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#a904f85d9a1ef8c95384bcb89ff0795e7" title="Multiply-accumulate. ">piranha::math::multiply_accumulate()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02409">2409</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4c2bc7a506a97ab87d1013abafec409c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(const std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Term filtering. </p>
<p>This method will apply the functor <code>func</code> to each term in the series, and produce a return series containing all terms in <code>this</code> for which <code>func</code> returns <code>true</code>. Terms are passed to <code>func</code> in the format resulting from dereferencing the iterators obtained via <a class="el" href="classpiranha_1_1series.html#acfeae53f7a213c8aa8c29e9d3f65e4d0" title="Begin iterator. ">piranha::series::begin()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>filtering functor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>filtered series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the call operator of <code>func</code>,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>the assignment operator of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>term, coefficient, key construction. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02334">2334</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c21ffcb7def44fda1f2f50dacc9f3ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::tuple&lt;int,degree_type&lt;T&gt;,std::vector&lt;std::string&gt; &gt; <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::get_auto_truncate_degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the status of the degree-based auto-truncation mechanism. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>This method will return a tuple of three elements describing the status of the degree-based auto-truncation mechanism. The elements of the tuple have the following meaning:</p><ul>
<li>truncation mode (0 if disabled, 1 for total-degree truncation and 2 for partial-degree truncation),</li>
<li>the maximum degree allowed,</li>
<li>the list of names to be considered for partial truncation.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a tuple representing the status of the degree-based auto-truncation mechanism.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by threading primitives or by the involved constructors. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="power__series_8hpp_source.html#l00564">564</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c4a9e7100d9842f3dbc6e7fdd04ee49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a>&amp; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::get_symbol_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Symbol set getter. </p>
<dl class="section return"><dt>Returns</dt><dd>const reference to the <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a> associated to the series. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02586">2586</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f7e68abc23ec8d71664d463cf83c8e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::hash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hash value. </p>
<p>The hash value for a series is zero if the series is empty, otherwise it is computed by adding the hash values of all terms. This ensures that two identical series in which the terms are stored in different order still produce the same hash value.</p>
<p>Note, however, that the arguments of the series are not considered in the hash value and that, in general, two series that compare equal according to <a class="el" href="classpiranha_1_1series__operators.html#a685319221f4aba841a9cbf9d1980b7f8" title="Equality operator involving piranha::series. ">operator==()</a> will <b>not</b> have the same hash value (as the equality operator merges the arguments of two series before actually performing the comparison). Instead of <a class="el" href="classpiranha_1_1series__operators.html#a685319221f4aba841a9cbf9d1980b7f8" title="Equality operator involving piranha::series. ">operator==()</a>, <a class="el" href="classpiranha_1_1series.html#a3303c0cfd2399b9f71570f43e85f8ee3" title="Check for identical series. ">is_identical()</a> should be used for storing series as keys in associative containers.</p>
<dl class="section return"><dt>Returns</dt><dd>a hash value for the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by computing the hash of a term. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02554">2554</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac049565106ddee1881fedf6481de9458"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>term</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert term. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the decay type of <code>T</code> is <a class="el" href="classpiranha_1_1series.html#a1af0f49cc902d64a77cbaea64f0a2d24" title="Alias for term type. ">piranha::series::term_type</a>.</dd></dl>
<p>This method will insert <code>term</code> into the series using internally <a class="el" href="classpiranha_1_1hash__set.html#a1932a69f1c81715ad76a182f7eca9d9f" title="Insert element. ">piranha::hash_set::insert</a>.</p>
<p>The insertion algorithm proceeds as follows:</p><ul>
<li>if the term is not compatible for insertion, an <code>std::invalid_argument</code> exception is thrown;</li>
<li>if the term is ignorable, the method will return without performing any insertion;</li>
<li>if the term is already in the series, then:<ul>
<li>its coefficient is added (if <code>Sign</code> is <code>true</code>) or subtracted (if <code>Sign</code> is <code>false</code>) to the existing term's coefficient;</li>
<li>if, after the addition/subtraction the existing term is ignorable, it will be erased;</li>
</ul>
</li>
<li>else:<ul>
<li>the term is inserted into the term container and, if <code>Sign</code> is <code>false</code>, its coefficient is negated.</li>
</ul>
</li>
</ul>
<p>After any modification to an existing term in the series (e.g., via insertion with negative <code>Sign</code> or via in-place addition or subtraction of existing coefficients), the term will be checked again for compatibility and ignorability, and, in case the term has become incompatible or ignorable, it will be erased from the series.</p>
<p>The exception safety guarantee upon insertion is that the series will be left in an undefined but valid state. Such a guarantee relies on the fact that the addition/subtraction and negation methods of the coefficient type will leave the coefficient in a valid (possibly undefined) state in face of exceptions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">term</td><td>term to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1hash__set.html#a1932a69f1c81715ad76a182f7eca9d9f" title="Insert element. ">piranha::hash_set::insert()</a>,</li>
<li><a class="el" href="classpiranha_1_1hash__set.html#a455c154b0614dc4d86112550ed3e4346" title="Find element. ">piranha::hash_set::find()</a>,</li>
<li><a class="el" href="classpiranha_1_1hash__set.html#a02e4d798ba7678f8874e5ca09696feed" title="Erase element. ">piranha::hash_set::erase()</a>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#a7ec2303772eab00a1ca75c11106c60b9" title="In-place negation. ">piranha::math::negate()</a>, in-place addition/subtraction on coefficient types. </li>
</ul>
</td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>term</code> is incompatible. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l01957">1957</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d1924707f1dbc3c82284e48bdaf87f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>term</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert generic term with <code>Sign = true</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the decay type of <code>T</code> is <a class="el" href="classpiranha_1_1series.html#a1af0f49cc902d64a77cbaea64f0a2d24" title="Alias for term type. ">piranha::series::term_type</a>.</dd></dl>
<p>Convenience wrapper for the generic <a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a> method, with <code>Sign</code> set to <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">term</td><td>term to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by generic <a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l01973">1973</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f4f77e9e1d967c5ce6754464839cd17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf &gt; </div>
<div class="memtemplate">
template&lt;typename T  = poisson_series, integrate_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a> <a class="el" href="classpiranha_1_1poisson__series.html">piranha::poisson_series</a>&lt; Cf &gt;::integrate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integration. </p>
<p>This method will attempt to compute the antiderivative of the Poisson series term by term using the following procedure:</p><ul>
<li>if the term's monomial does not depend on the integration variable, the integration will be deferred to the coefficient;</li>
<li>otherwise:<ul>
<li>if the coefficient does not depend on the integration variable, the monomial is integrated;</li>
<li>if the coefficient is a polynomial, a strategy of integration by parts is attempted, its success depending on whether the degree of the polynomial is a non-negative integral value;</li>
<li>otherwise, an error will be produced.</li>
</ul>
</li>
</ul>
<p>This method requires the coefficient type to be differentiable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>integration variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the antiderivative of <code>this</code> with respect to <code>name</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the integration procedure fails. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1symbol.html" title="Literal symbol class. ">piranha::symbol</a> construction,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#ac3959494f64044823fd4c4545a5f3e4a" title="Partial derivative. ">piranha::math::partial()</a>, <a class="el" href="namespacepiranha_1_1math.html#a00db2c62bd93a48258dd8545c6fb468c" title="Zero test. ">piranha::math::is_zero()</a>, <a class="el" href="namespacepiranha_1_1math.html#a989976cf0e0e1637ea0cd176cc87f0dc" title="Integration. ">piranha::math::integrate()</a>, <a class="el" href="namespacepiranha.html#a712714b1e1348f73ec01687d5d5c9b2d" title="Safe cast. ">piranha::safe_cast()</a> and <a class="el" href="namespacepiranha_1_1math.html#a7ec2303772eab00a1ca75c11106c60b9" title="In-place negation. ">piranha::math::negate()</a>,</li>
<li>the assignment operator of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>term construction,</li>
<li>coefficient construction, assignment and arithmetics,</li>
<li>integration, construction and assignment of the key type,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li><a class="el" href="classpiranha_1_1power__series.html#a6ceadbb37c9f10543e8859af0a759814" title="Total degree. ">piranha::polynomial::degree()</a>,</li>
<li>series arithmetics.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>requirements on dividability by multiplier type (or integer), safe_cast, etc. </dd></dl>

<p>Definition at line <a class="el" href="poisson__series_8hpp_source.html#l00497">497</a> of file <a class="el" href="poisson__series_8hpp_source.html">poisson_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a65e34001559b2062e811d52dfee2b065"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipow_subs_type&lt;T&gt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">piranha::ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::ipow_subs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b">integer</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the coefficient and/or key types support integral power substitution, and if the types involved in the substitution support the necessary arithmetic operations to compute the result.</dd></dl>
<p>This method will return an object resulting from the substitution of the integral power of the symbol called <code>name</code> in <code>this</code> with the generic object <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of the symbol to be substituted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>integral power of the symbol to be substituted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>object used for the substitution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the substitution.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from:<ul>
<li>the substitution routines for the coefficients and/or keys,</li>
<li>the computation of the return value,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ipow__substitutable__series_8hpp_source.html#l00196">196</a> of file <a class="el" href="ipow__substitutable__series_8hpp_source.html">ipow_substitutable_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae08e5b170f2161bdca8c6129dcb51025"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipow_subs_type&lt;T&gt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">piranha::ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::ipow_subs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the other <a class="el" href="classpiranha_1_1ipow__substitutable__series.html#a65e34001559b2062e811d52dfee2b065" title="Substitution. ">ipow_subs()</a> overload is enabled, and <code>Int</code> is a C++ integral type.</dd></dl>
<p>This is a convenience method that will call the other <a class="el" href="classpiranha_1_1ipow__substitutable__series.html#a65e34001559b2062e811d52dfee2b065" title="Substitution. ">ipow_subs()</a> overload after converting <code>n</code> to <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b" title="Alias for piranha::mp_integer with default bit size. ">piranha::integer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of the symbol to be substituted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>integral power of the symbol to be substituted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>object used for the substitution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the substitution.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from calling the other <a class="el" href="classpiranha_1_1ipow__substitutable__series.html#a65e34001559b2062e811d52dfee2b065" title="Substitution. ">ipow_subs()</a> overload, or by constructing a <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b" title="Alias for piranha::mp_integer with default bit size. ">piranha::integer</a> from a C++ integral type. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ipow__substitutable__series_8hpp_source.html#l00223">223</a> of file <a class="el" href="ipow__substitutable__series_8hpp_source.html">ipow_substitutable_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3303c0cfd2399b9f71570f43e85f8ee3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::is_identical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for identical series. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <code>Derived</code> is equality-comparable.</dd></dl>
<p>This method will return <code>true</code> if the symbol sets of <code>this</code> and <code>other</code> are the same, and <code>other == *this</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>argument for the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>this</code> and <code>other</code> are identical, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the comparison operator of <code>Derived</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02578">2578</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a04adb9b939dda140547a027e461a4384"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::is_single_coefficient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for single-coefficient series. </p>
<p>A series is considered to be <em>single-coefficient</em> when it is symbolically equivalent to a coefficient. That is, the series is either empty (in which case it is considered to be equivalent to a coefficient constructed from zero) or consisting of a single term with unitary key (in which case the series is considered equivalent to its only coefficient).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> in case of single-coefficient series, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the <code>is_unitary()</code> method of the key type. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l01918">1918</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5b69ae8e0fc896120a45464fc59c4cc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ldegree_type&lt;T&gt; <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::ldegree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total low degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>The low degree of the series is the minimum low degree of its terms. If the series is empty, zero will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>the total low degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the construction of return type,</li>
<li>the calculation of the low degree of each term,</li>
<li>the assignment and less-than operators for the return type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="power__series_8hpp_source.html#l00336">336</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad90a2cecef949780b42d47aaf699c65b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pldegree_type&lt;T&gt; <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::ldegree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial low degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>The partial low degree of the series is the minimum partial low degree of its terms. If the series is empty, zero will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>names of the variables to be considered in the computation of the low degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the partial low degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the construction of return type,</li>
<li>the calculation of the low degree of each term,</li>
<li>the assignment and less-than operators for the return type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="power__series_8hpp_source.html#l00387">387</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3dce8005ee4919ce2f68b508e6292118"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::negate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negate series in-place. </p>
<p>This method will call math::negate() on the coefficients of all terms. In case of exceptions, the basic exception safety guarantee is provided.</p>
<p>If any term becomes ignorable or incompatible after negation, it will be erased from the series.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by math::negate() on the coefficient type. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02010">2010</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7999e7a1d36a9519ca4b373f8886ed40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::operator+ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identity operator. </p>
<dl class="section return"><dt>Returns</dt><dd>copy of <code>this</code>, cast to <code>Derived</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the copy constructor. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l01983">1983</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6835fa85739cf3f53bea993964b3b80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negation operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a copy of <code>this</code> on which <a class="el" href="classpiranha_1_1series.html#a3dce8005ee4919ce2f68b508e6292118" title="Negate series in-place. ">negate()</a> has been called.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1series.html#a3dce8005ee4919ce2f68b508e6292118" title="Negate series in-place. ">negate()</a>,</li>
<li>the copy constructor of <code>Derived</code>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l01995">1995</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a816a2a0ef41921df71a9c0f518ddd653"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">partial_type&lt;Series&gt; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::partial </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial derivative. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the coefficient and key are differentiable (i.e., they satisfy the <a class="el" href="classpiranha_1_1is__differentiable.html" title="Type trait for differentiable types. ">piranha::is_differentiable</a> and <a class="el" href="classpiranha_1_1key__is__differentiable.html" title="Type trait to detect differentiable keys. ">piranha::key_is_differentiable</a> type traits), and if the arithmetic operations needed to compute the partial derivative are supported by all the involved types.</dd></dl>
<p>This method will return the partial derivative of <code>this</code> with respect to the variable called <code>name</code>. The method will construct the return value from the output of the differentiation methods of coefficient and key, and via arithmetic and/or term insertion operations.</p>
<p>Note that, contrary to the specialisation of <a class="el" href="namespacepiranha_1_1math.html#ac3959494f64044823fd4c4545a5f3e4a" title="Partial derivative. ">piranha::math::partial()</a> for series types, this method will not take into account custom derivatives registered via <a class="el" href="classpiranha_1_1series.html#a5ee2cef7972c1ed1a410351c9f3e175e" title="Register custom partial derivative. ">piranha::series::register_custom_derivative()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of the argument with respect to which the derivative will be calculated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial derivative of <code>this</code> with respect to the symbol named <code>name</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the differentiation methods of coefficient and key,</li>
<li>term construction and insertion,</li>
<li>arithmetic operations on the involved types,</li>
<li>construction of the return type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02191">2191</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a76ddd34099884d45825b72155d1d6e48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pow_ret_type&lt;T,U&gt; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::pow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exponentiation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if:<ul>
<li>the coefficient type is exponentiable to the power of <code>x</code>, and the return type is the coefficient type itself,</li>
<li><code>T</code> can be used as argument for <a class="el" href="namespacepiranha_1_1math.html#a00db2c62bd93a48258dd8545c6fb468c" title="Zero test. ">piranha::math::is_zero()</a> and <a class="el" href="namespacepiranha.html#a712714b1e1348f73ec01687d5d5c9b2d" title="Safe cast. ">piranha::safe_cast()</a> to <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b" title="Alias for piranha::mp_integer with default bit size. ">piranha::integer</a>,</li>
<li><code>Derived</code> is multipliable and the result of the multiplication is <code>Derived</code>,</li>
<li>the <a class="el" href="classpiranha_1_1series.html#a3303c0cfd2399b9f71570f43e85f8ee3" title="Check for identical series. ">is_identical()</a> method can be called on <code>Derived</code>.</li>
</ul>
</dd></dl>
<p>Return <code>this</code> raised to the <code>x</code>-th power. The exponentiation algorithm proceeds as follows:</p><ul>
<li>if the series is single-coefficient, a call to <a class="el" href="classpiranha_1_1series.html#a97624cbcc7139b6f70682d908f759656" title="Apply functor to single-coefficient series. ">apply_cf_functor()</a> is attempted, using a functor that calls <a class="el" href="namespacepiranha_1_1math.html#afbd1041a6f6d37325b55a66b7a84c016" title="Exponentiation. ">piranha::math::pow()</a> on the coefficient. Otherwise, the algorithm proceeds;</li>
<li>if <code>x</code> is zero (as established by <a class="el" href="namespacepiranha_1_1math.html#a00db2c62bd93a48258dd8545c6fb468c" title="Zero test. ">piranha::math::is_zero()</a>), a series with a single term with unitary key and coefficient constructed from the integer numeral "1" is returned (i.e., any series raised to the power of zero is 1 - including empty series);</li>
<li>if <code>x</code> represents a non-negative integral value, the return value is constructed via repeated multiplications;</li>
<li>otherwise, an exception will be raised.</li>
</ul>
<p>An internal thread-safe cache of natural powers of series is maintained in order to improve performance during, e.g., substitution operations. This cache can be cleared with <a class="el" href="classpiranha_1_1series.html#ae7da3b838cc92a235785ae4e339a1e97" title="Clear the internal cache of natural powers. ">clear_pow_cache()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>exponent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>this</code> raised to the power of <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if exponentiation is computed via repeated series multiplications and <code>x</code> does not represent a non-negative integer. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>series, term, coefficient and key construction,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li><a class="el" href="classpiranha_1_1series.html#a04adb9b939dda140547a027e461a4384" title="Test for single-coefficient series. ">is_single_coefficient()</a>,</li>
<li><a class="el" href="classpiranha_1_1series.html#a97624cbcc7139b6f70682d908f759656" title="Apply functor to single-coefficient series. ">apply_cf_functor()</a>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#afbd1041a6f6d37325b55a66b7a84c016" title="Exponentiation. ">piranha::math::pow()</a>, <a class="el" href="namespacepiranha_1_1math.html#a00db2c62bd93a48258dd8545c6fb468c" title="Zero test. ">piranha::math::is_zero()</a> and <a class="el" href="namespacepiranha.html#a712714b1e1348f73ec01687d5d5c9b2d" title="Safe cast. ">piranha::safe_cast()</a>,</li>
<li>series multiplication,</li>
<li>memory errors in standard containers,</li>
<li>threading primitives,</li>
<li><a class="el" href="classpiranha_1_1series.html#a4f7e68abc23ec8d71664d463cf83c8e3" title="Hash value. ">hash()</a> or <a class="el" href="classpiranha_1_1series.html#a3303c0cfd2399b9f71570f43e85f8ee3" title="Check for identical series. ">is_identical()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02103">2103</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad2fc18640bdfa5d96217434a533e0567"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::print_tex </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print in TeX mode. </p>
<p>Print series to stream <code>os</code> in TeX mode. The representation is constructed in the same way as explained in <a class="el" href="classpiranha_1_1series.html#a9f4b6250352b1657f36a0f90e021b6ce" title="Overloaded stream operator for piranha::series. ">piranha::series::operator&lt;&lt;()</a>, but using <a class="el" href="namespacepiranha.html#ac5f03dab82a8f92ec7c42ab6e8bbf735" title="Print series coefficient in TeX mode. ">piranha::print_tex_coefficient()</a> and the key's TeX printing method instead of the plain printing functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>target stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="namespacepiranha.html#ac5f03dab82a8f92ec7c42ab6e8bbf735" title="Print series coefficient in TeX mode. ">piranha::print_tex_coefficient()</a>,</li>
<li>the TeX printing method of the key type,</li>
<li>memory allocation errors in standard containers,</li>
<li><a class="el" href="classpiranha_1_1settings.html#aa493e503accf25b56608b239ba8e9a6f" title="Get max term output. ">piranha::settings::get_max_term_output()</a>,</li>
<li>streaming to <code>os</code> or to instances of <code>std::ostringstream</code>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpiranha_1_1series.html#a9f4b6250352b1657f36a0f90e021b6ce" title="Overloaded stream operator for piranha::series. ">operator&lt;&lt;()</a>. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02481">2481</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5ee2cef7972c1ed1a410351c9f3e175e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::register_custom_derivative </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register custom partial derivative. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <a class="el" href="classpiranha_1_1series.html#a816a2a0ef41921df71a9c0f518ddd653" title="Partial derivative. ">piranha::series::partial()</a> is enabled for <code>Derived</code>, and if <code>F</code> is a type that can be used to construct <code>std::function&lt;partial_type(const Derived &amp;)</code>, where <code>partial_type</code> is the type resulting from the partial derivative of <code>Derived</code>.</dd></dl>
<p>Register a copy of a callable <code>func</code> associated to the symbol called <code>name</code> for use by <a class="el" href="namespacepiranha_1_1math.html#ac3959494f64044823fd4c4545a5f3e4a" title="Partial derivative. ">piranha::math::partial()</a>. <code>func</code> will be used to compute the partial derivative of instances of type <code>Derived</code> with respect to <code>name</code> in place of the default partial differentiation algorithm.</p>
<p>It is safe to call this method from multiple threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>symbol for which the custom partial derivative function will be registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>custom partial derivative function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>failure(s) in threading primitives,</li>
<li>lookup and insertion operations on <code>std::unordered_map</code>,</li>
<li>construction and move-assignment of <code>std::function</code>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02217">2217</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc967cd40e03ec98f1036506be9aaba0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::set_auto_truncate_degree </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>max_degree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set total-degree-based auto-truncation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied, and if <code>U</code> can be safely cast to the degree type.</dd></dl>
<p>Setup the degree-based auto-truncation mechanism to truncate according to the total maximum degree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_degree</td><td>maximum total degree that will be retained during automatic truncation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>threading primitives,</li>
<li><a class="el" href="namespacepiranha.html#a712714b1e1348f73ec01687d5d5c9b2d" title="Safe cast. ">piranha::safe_cast()</a>,</li>
<li>the constructor of the degree type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="power__series_8hpp_source.html#l00482">482</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adf63eaabd12a4442ef8db73d6408e0e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::set_auto_truncate_degree </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>max_degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set partial-degree-based auto-truncation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied, and if <code>U</code> can be safely cast to the degree type.</dd></dl>
<p>Setup the degree-based auto-truncation mechanism to truncate according to the partial degree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_degree</td><td>maximum partial degree that will be retained during automatic truncation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>names of the variables that will be considered during the computation of the partial degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>threading primitives,</li>
<li><a class="el" href="namespacepiranha.html#a712714b1e1348f73ec01687d5d5c9b2d" title="Safe cast. ">piranha::safe_cast()</a>,</li>
<li>the constructor of the degree type,</li>
<li>memory allocation errors in standard containers. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="power__series_8hpp_source.html#l00515">515</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac3752460cc7a4c4cc0bea3330b31bcc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::set_symbol_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Symbol set setter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td><a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a> that will be associated to the series.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the series is not empty. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the copy assignment operator of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02597">2597</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a592243b5a76e2acfaa4abad4b8795ab1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf &gt; </div>
<div class="memtemplate">
template&lt;typename T  = poisson_series, sin_cos_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a> <a class="el" href="classpiranha_1_1poisson__series.html">piranha::poisson_series</a>&lt; Cf &gt;::sin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override sine implementation. </p>
<dl class="section note"><dt>Note</dt><dd>This template method is enabled only if either:<ul>
<li>the coefficient type is a <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a> whose coefficient type supports <a class="el" href="namespacepiranha.html#a712714b1e1348f73ec01687d5d5c9b2d" title="Safe cast. ">piranha::safe_cast()</a>, or</li>
<li>the coefficient type has a <a class="el" href="namespacepiranha_1_1math.html#afbe681443ac448d0eec22376992be475" title="Sine. ">math::sin()</a> implementation whose return type is the coefficient type.</li>
</ul>
</dd></dl>
<p>This method will override the default <a class="el" href="namespacepiranha_1_1math.html#afbe681443ac448d0eec22376992be475" title="Sine. ">math::sin()</a> implementation in case the coefficient type is an instance of <a class="el" href="classpiranha_1_1polynomial.html" title="Polynomial class. ">piranha::polynomial</a>. If the series is single-coefficient and not empty, and the coefficient represents a linear combination of variables with integral coefficients, then the return value will be a Poisson series consisting of a single term with coefficient constructed from "1" and trigonometric key containing the linear combination of variables.</p>
<p>In any other case, the default algorithm to calculate the sine of a series will take place.</p>
<dl class="section return"><dt>Returns</dt><dd>sine of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1series.html#a04adb9b939dda140547a027e461a4384" title="Test for single-coefficient series. ">piranha::series::is_single_coefficient()</a>, <a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>,</li>
<li><a class="el" href="classpiranha_1_1symbol__set.html#a13101abf79be11e045539f82be6f120f" title="Add symbol to the set. ">piranha::symbol_set::add()</a>,</li>
<li>memory allocation errors in standard containers,</li>
<li>the constructors of coefficient, key and term types,</li>
<li>the cast operator of <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b" title="Alias for piranha::mp_integer with default bit size. ">piranha::integer</a>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#a7ec2303772eab00a1ca75c11106c60b9" title="In-place negation. ">piranha::math::negate()</a>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#afbe681443ac448d0eec22376992be475" title="Sine. ">piranha::math::sin()</a>,</li>
<li>the extraction of a linear combination of integral arguments from the polynomial coefficient. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="poisson__series_8hpp_source.html#l00438">438</a> of file <a class="el" href="poisson__series_8hpp_source.html">poisson_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acae02a113d00a1cd291ac2d8052e1efd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html#a3bd2e6c7089dee8f3d370eda2260013a">size_type</a> <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Series size. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of terms in the series. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l01895">1895</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a16ec2b3885daaadf883e88322b4c3c46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subs_type&lt;T&gt; <a class="el" href="classpiranha_1_1substitutable__series.html">piranha::substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::subs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the coefficient and/or key types support substitution, and if the types involved in the substitution support the necessary arithmetic operations to compute the result.</dd></dl>
<p>This method will return an object resulting from the substitution of the symbol called <code>name</code> in <code>this</code> with the generic object <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of the symbol to be substituted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>object used for the substitution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the substitution.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from:<ul>
<li>the substitution routines for the coefficients and/or keys,</li>
<li>the computation of the return value,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="substitutable__series_8hpp_source.html#l00193">193</a> of file <a class="el" href="substitutable__series_8hpp_source.html">substitutable_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca20577870a846a98b720c97656dc592"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">t_degree_type&lt;T&gt; <a class="el" href="classpiranha_1_1trigonometric__series.html">piranha::trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;  &gt;::t_degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trigonometric degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the requirements outlined in <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a> are satisfied.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>total trigonometric degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from the computation and comparison of the degree of the individual terms. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="trigonometric__series_8hpp_source.html#l00178">178</a> of file <a class="el" href="trigonometric__series_8hpp_source.html">trigonometric_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aac2894c982307df448677b21ae86f4a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pt_degree_type&lt;T&gt; <a class="el" href="classpiranha_1_1trigonometric__series.html">piranha::trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;  &gt;::t_degree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial trigonometric degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the requirements outlined in <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a> are satisfied.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>names of the variables to be considered in the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial trigonometric degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from the computation and comparison of the degree of the individual terms. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="trigonometric__series_8hpp_source.html#l00198">198</a> of file <a class="el" href="trigonometric__series_8hpp_source.html">trigonometric_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1ac54ad7a9473b7c9820fb64a261a173"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf &gt; </div>
<div class="memtemplate">
template&lt;typename T  = poisson_series&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ti_type&lt;T&gt; <a class="el" href="classpiranha_1_1poisson__series.html">piranha::poisson_series</a>&lt; Cf &gt;::t_integrate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Time integration. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if:<ul>
<li>the calling series is not already an echeloned Poisson series,</li>
<li>the operations required by the computation of the time integration are supported by all the involved types.</li>
</ul>
</dd></dl>
<p>This is a special type of integration in which the trigonometric arguments are considered as linear functions of time, and in which the integration variable is time itself. The result of the operation is a so-called echeloned Poisson series, that it, a Poisson series in which the coefficient is a <a class="el" href="classpiranha_1_1divisor__series.html" title="Divisor series. ">piranha::divisor_series</a> whose coefficient type is the original coefficient type of the Poisson series.</p>
<p>For instance, if the original series is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{1}{5}z\cos\left( x - y \right), \]" src="form_14.png"/>
</p>
<p> the result of the time integration is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{1}{5}{z}\frac{1}{\left(\nu_{x}-\nu_{y}\right)}\sin{\left({x}-{y}\right)}, \]" src="form_15.png"/>
</p>
<p> where <img class="formulaInl" alt="$ \nu_{x} $" src="form_16.png"/> and <img class="formulaInl" alt="$ \nu_{y} $" src="form_17.png"/> are the frequencies associated to <img class="formulaInl" alt="$ x $" src="form_18.png"/> and <img class="formulaInl" alt="$ y $" src="form_19.png"/> (that is, <img class="formulaInl" alt="$ x = \nu_{x}t $" src="form_20.png"/> and <img class="formulaInl" alt="$ x = \nu_{y}t $" src="form_21.png"/>).</p>
<p>This method will throw an error if any term of the calling series has a unitary key (e.g., in the Poisson series <img class="formulaInl" alt="$ \frac{1}{5}z $" src="form_22.png"/> the only trigonometric key is <img class="formulaInl" alt="$ \cos\left( 0 \right) $" src="form_23.png"/> and would thus result in a division by zero during a time integration).</p>
<dl class="section return"><dt>Returns</dt><dd>the result of the time integration.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>memory errors in standard containers,</li>
<li>the public interfaces of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>, <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a> and <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#a00db2c62bd93a48258dd8545c6fb468c" title="Zero test. ">piranha::math::is_zero()</a>,</li>
<li>the mathematical operations needed to compute the result,</li>
<li><a class="el" href="classpiranha_1_1divisor.html#a47a871f636bf0838da1bcd7d8aa5dfac" title="Create and insert a term from range and exponent. ">piranha::divisor::insert()</a>,</li>
<li>construction of the involved types. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="poisson__series_8hpp_source.html#l00566">566</a> of file <a class="el" href="poisson__series_8hpp_source.html">poisson_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2773cd4458563ff78836ed7fa93679d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">t_ldegree_type&lt;T&gt; <a class="el" href="classpiranha_1_1trigonometric__series.html">piranha::trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;  &gt;::t_ldegree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trigonometric low degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the requirements outlined in <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a> are satisfied.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>total trigonometric low degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from the computation and comparison of the degree of the individual terms. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="trigonometric__series_8hpp_source.html#l00217">217</a> of file <a class="el" href="trigonometric__series_8hpp_source.html">trigonometric_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3ed013f36e3f618201159d40955cd019"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pt_ldegree_type&lt;T&gt; <a class="el" href="classpiranha_1_1trigonometric__series.html">piranha::trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;  &gt;::t_ldegree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial trigonometric low degree. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the requirements outlined in <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a> are satisfied.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>names of the variables to be considered in the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial trigonometric low degree of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from the computation and comparison of the degree of the individual terms. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="trigonometric__series_8hpp_source.html#l00237">237</a> of file <a class="el" href="trigonometric__series_8hpp_source.html">trigonometric_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab0708c4fa669662d35636e08d21c1de4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">t_lorder_type&lt;T&gt; <a class="el" href="classpiranha_1_1trigonometric__series.html">piranha::trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;  &gt;::t_lorder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trigonometric low order. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the requirements outlined in <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a> are satisfied.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>total trigonometric low order of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from the computation and comparison of the order of the individual terms. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="trigonometric__series_8hpp_source.html#l00295">295</a> of file <a class="el" href="trigonometric__series_8hpp_source.html">trigonometric_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca3c65cf42926a27bb47a449911ecc76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pt_lorder_type&lt;T&gt; <a class="el" href="classpiranha_1_1trigonometric__series.html">piranha::trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;  &gt;::t_lorder </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial trigonometric low order. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the requirements outlined in <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a> are satisfied.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>names of the variables to be considered in the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial trigonometric low order of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from the computation and comparison of the order of the individual terms. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="trigonometric__series_8hpp_source.html#l00315">315</a> of file <a class="el" href="trigonometric__series_8hpp_source.html">trigonometric_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab3cdb9b1100b27d76623eafbfb4e949a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">t_order_type&lt;T&gt; <a class="el" href="classpiranha_1_1trigonometric__series.html">piranha::trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;  &gt;::t_order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trigonometric order. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the requirements outlined in <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a> are satisfied.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>total trigonometric order of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from the computation and comparison of the order of the individual terms. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="trigonometric__series_8hpp_source.html#l00256">256</a> of file <a class="el" href="trigonometric__series_8hpp_source.html">trigonometric_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af84131d0a7471e675675f100a83cc353"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pt_order_type&lt;T&gt; <a class="el" href="classpiranha_1_1trigonometric__series.html">piranha::trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;  &gt;::t_order </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial trigonometric order. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the requirements outlined in <a class="el" href="classpiranha_1_1trigonometric__series.html" title="Trigonometric series toolbox. ">piranha::trigonometric_series</a> are satisfied.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>names of the variables to be considered in the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial trigonometric order of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from the computation and comparison of the order of the individual terms. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="trigonometric__series_8hpp_source.html#l00276">276</a> of file <a class="el" href="trigonometric__series_8hpp_source.html">trigonometric_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a041ef69409050af66478c0cc7c15419e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">t_subs_type&lt;T,U&gt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">piranha::t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::t_subs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trigonometric substitution. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requirements outlined in <a class="el" href="classpiranha_1_1t__substitutable__series.html" title="Toolbox for series that support trigonometric substitution. ">piranha::t_substitutable_series</a> are satisfied.</dd></dl>
<p>Trigonometric substitution is the substitution of the cosine and sine of <code>name</code> for <code>c</code> and <code>s</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of the symbol that will be subject to substitution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>cosine of <code>name</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>sine of <code>name</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the trigonometric substitution.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception resulting from:<ul>
<li>construction of the return type,</li>
<li>the assignment operator of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>term construction,</li>
<li>arithmetics on the intermediary values needed to compute the return value,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>,</li>
<li>the substitution methods of coefficient and key. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="t__substitutable__series_8hpp_source.html#l00195">195</a> of file <a class="el" href="t__substitutable__series_8hpp_source.html">t_substitutable_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a259a3dfca6849c5097246a4a0235cc61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html#a3bd2e6c7089dee8f3d370eda2260013a">size_type</a> <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::table_bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Table bucket count. </p>
<dl class="section return"><dt>Returns</dt><dd>the bucket count of the internal container. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02059">2059</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8cc5c9b27d9dbf3cdca9102eabb09003"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::table_load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Table load factor. </p>
<p>Will call <a class="el" href="classpiranha_1_1hash__set.html#a570ae119865b9bdcde64ff10459b3852" title="Load factor. ">piranha::hash_set::load_factor()</a> on the internal terms container and return the result.</p>
<dl class="section return"><dt>Returns</dt><dd>the load factor of the internal container. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02051">2051</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a57b8b94d7b67c5e91ec9bab039a37f73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sparsity_info_type <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::table_sparsity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Table sparsity. </p>
<p>Will call <a class="el" href="classpiranha_1_1hash__set.html#a947bcba0e0439d1abf15050567034978" title="Get information on the sparsity of the table. ">piranha::hash_set::evaluate_sparsity()</a> on the internal terms container and return the result.</p>
<dl class="section return"><dt>Returns</dt><dd>the output of <a class="el" href="classpiranha_1_1hash__set.html#a947bcba0e0439d1abf15050567034978" title="Get information on the sparsity of the table. ">piranha::hash_set::evaluate_sparsity()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classpiranha_1_1hash__set.html#a947bcba0e0439d1abf15050567034978" title="Get information on the sparsity of the table. ">piranha::hash_set::evaluate_sparsity()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02040">2040</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d2be8f9cd018cea990d8d33ff74b34e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;(const std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Term transformation. </p>
<p>This method will apply the functor <code>func</code> to each term in the series, and will use the return value of the functor to construct a new series. Terms are passed to <code>func</code> in the same format resulting from dereferencing the iterators obtained via <a class="el" href="classpiranha_1_1series.html#acfeae53f7a213c8aa8c29e9d3f65e4d0" title="Begin iterator. ">piranha::series::begin()</a>, and <code>func</code> is expected to produce a return value of the same type.</p>
<p>The return series is first initialised as an empty series. For each input term <code>t</code>, the return value of <code>func</code> is used to construct a new temporary series from the multiplication of <code>t.first</code> and <code>t.second</code>. Each temporary series is then added to the return value series.</p>
<p>This method requires the coefficient type to be multipliable by <code>Derived</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>transforming functor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformed series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the call operator of <code>func</code>,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>the assignment operator of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>term, coefficient, key construction,</li>
<li>series multiplication and addition.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>require multipliability of cf * Derived and addability of the result to Derived in place. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02372">2372</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad92d728b975d0dfda12ad7ddb168c984"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::trim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim. </p>
<p>This method will return a series mathematically equivalent to <code>this</code> in which discardable arguments have been removed from the internal set of symbols. Which symbols are removed depends on the trimming method <code>trim_identify()</code> of the key type (e.g., in a polynomial a symbol can be discarded if its exponent is zero in all monomials).</p>
<p>If the coefficient type is an instance of <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>, <a class="el" href="classpiranha_1_1series.html#ad92d728b975d0dfda12ad7ddb168c984" title="Trim. ">trim()</a> will be called recursively on the coefficients while building the return value.</p>
<dl class="section return"><dt>Returns</dt><dd>trimmed version of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>operations on <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>the trimming methods of coefficient and/or key,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>term, coefficient and key type construction. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02448">2448</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3c426d939bc75a2ba8365a6f82c91196"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::truncate_degree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>max_degree</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total degree truncation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>This method can be used to eliminate the parts of a series whose degree is greater than <code>max_degree</code>. This includes the elimination of whole terms, but also the recursive truncation of coefficients via the <a class="el" href="namespacepiranha_1_1math.html#ab529e82af5b6a2f2a87d7c4f2c4268a8" title="Truncation based on the total degree. ">piranha::math::truncate_degree()</a> function, if supported by the coefficient. It must be noted that, in general, this method is not guaranteed to eliminate all the parts whose degree is greater than <code>max_degree</code> (in particular, in the current implementation there is no truncation implemented for keys - a key is kept as-is or completely eliminated).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_degree</td><td>maximum allowed total degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the truncated counterpart of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="namespacepiranha_1_1math.html#ab529e82af5b6a2f2a87d7c4f2c4268a8" title="Truncation based on the total degree. ">piranha::math::truncate_degree()</a>, if used,</li>
<li>the constructor of the term type,</li>
<li>the computation and comparison of degree types,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="power__series_8hpp_source.html#l00419">419</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab6c335e9114a9be65cc447eed2605c43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::truncate_degree </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>max_degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial degree truncation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>This method is equivalent to the other overload, the only difference being that the partial degree is considered in the computation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_degree</td><td>maximum allowed partial degree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>names of the variables to be considered in the computation of the partial degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the truncated counterpart of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="namespacepiranha_1_1math.html#ab529e82af5b6a2f2a87d7c4f2c4268a8" title="Truncation based on the total degree. ">piranha::math::truncate_degree()</a>, if used,</li>
<li>the constructor of the term type,</li>
<li>the computation and comparison of degree types,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">piranha::series::insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="power__series_8hpp_source.html#l00452">452</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a40680bb3e8f2801b3754f0b03abb0633"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::unregister_all_custom_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregister all custom partial derivatives. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <a class="el" href="classpiranha_1_1series.html#a816a2a0ef41921df71a9c0f518ddd653" title="Partial derivative. ">piranha::series::partial()</a> is enabled for <code>Derived</code>.</dd></dl>
<p>Will unregister all custom derivatives currently registered via <a class="el" href="classpiranha_1_1series.html#a5ee2cef7972c1ed1a410351c9f3e175e" title="Register custom partial derivative. ">register_custom_derivative()</a>. It is safe to call this method from multiple threads.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by failure(s) in threading primitives. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02262">2262</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a041b2099313fa16a9b13d55ce7c0d930"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::unregister_custom_derivative </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregister custom partial derivative. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <a class="el" href="classpiranha_1_1series.html#a816a2a0ef41921df71a9c0f518ddd653" title="Partial derivative. ">piranha::series::partial()</a> is enabled for <code>Derived</code>.</dd></dl>
<p>Unregister the custom partial derivative function associated to the symbol called <code>name</code>. If no custom partial derivative was previously registered using <a class="el" href="classpiranha_1_1series.html#a5ee2cef7972c1ed1a410351c9f3e175e" title="Register custom partial derivative. ">register_custom_derivative()</a>, calling this function will be a no-op.</p>
<p>It is safe to call this method from multiple threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>symbol for which the custom partial derivative function will be unregistered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>failure(s) in threading primitives,</li>
<li>lookup and erase operations on <code>std::unordered_map</code>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02243">2243</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c74bd5642d0acd2cb40697f67502266"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1power__series.html">piranha::power_series</a>&lt; <a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a>&lt; <a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a>&lt; <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, <a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a>, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt;, <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt; &gt; , <a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a>&lt; Cf &gt;  &gt;::unset_auto_truncate_degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable degree-based auto-truncation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is available only if the requisites outlined in <a class="el" href="classpiranha_1_1power__series.html" title="Power series toolbox. ">piranha::power_series</a> are satisfied.</dd></dl>
<p>Disable the degree-based auto-truncation mechanism.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>threading primitives,</li>
<li>the constructor of the degree type,</li>
<li>memory allocation errors in standard containers. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="power__series_8hpp_source.html#l00539">539</a> of file <a class="el" href="power__series_8hpp_source.html">power_series.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="poisson__series__fwd_8hpp_source.html">poisson_series_fwd.hpp</a></li>
<li><a class="el" href="poisson__series_8hpp_source.html">poisson_series.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 18 2015 21:06:04 for piranha by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9
</small></address>
</body>
</html>

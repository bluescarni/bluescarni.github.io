<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>piranha: piranha Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">piranha
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">piranha Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Root piranha namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacepiranha_1_1literals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1literals.html">literals</a></td></tr>
<tr class="memdesc:namespacepiranha_1_1literals"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline namespace for the definition of user-defined literals. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepiranha_1_1math"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepiranha_1_1math.html">math</a></td></tr>
<tr class="memdesc:namespacepiranha_1_1math"><td class="mdescLeft">&#160;</td><td class="mdescRight">Math namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1array__key.html">array_key</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array key.  <a href="classpiranha_1_1array__key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1base__exception.html">base_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base exception class.  <a href="classpiranha_1_1base__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1cache__aligning__allocator.html">cache_aligning_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator that tries to align memory to the cache line size.  <a href="classpiranha_1_1cache__aligning__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1convert__to__impl.html">convert_to_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha.html#a8740bbc3e472de1f0acebc18c416c35d" title="Generic conversion function. ">piranha::convert_to()</a>.  <a href="structpiranha_1_1convert__to__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1debug__access.html">debug_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug class.  <a href="classpiranha_1_1debug__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1divisor.html">divisor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divisor class.  <a href="classpiranha_1_1divisor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1divisor__series.html">divisor_series</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divisor series.  <a href="classpiranha_1_1divisor__series.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1dynamic__aligning__allocator.html">dynamic_aligning_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory allocator with runtime alignment support.  <a href="classpiranha_1_1dynamic__aligning__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1enable__noexcept__checks.html">enable_noexcept_checks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable <code>noexcept</code> checks.  <a href="structpiranha_1_1enable__noexcept__checks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1environment.html">environment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Piranha environment.  <a href="classpiranha_1_1environment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1future__list.html">future_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to store a list of futures.  <a href="classpiranha_1_1future__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1has__binomial.html">has_binomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect the presence of the <a class="el" href="namespacepiranha_1_1math.html#a5a44533ef3963c6c96f4aca746c92d07" title="Generalised binomial coefficient. ">piranha::math::binomial</a> function.  <a href="classpiranha_1_1has__binomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1has__convert__to.html">has_convert_to</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect <a class="el" href="namespacepiranha.html#a8740bbc3e472de1f0acebc18c416c35d" title="Generic conversion function. ">piranha::convert_to()</a>.  <a href="classpiranha_1_1has__convert__to.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1has__cosine.html">has_cosine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect <a class="el" href="namespacepiranha_1_1math.html#a88eb0469177875f0133594816a8ba382" title="Cosine. ">piranha::math::cos()</a>.  <a href="classpiranha_1_1has__cosine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1has__degree.html">has_degree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect if type has a degree property.  <a href="classpiranha_1_1has__degree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1has__ipow__subs.html">has_ipow_subs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect the presence of the <a class="el" href="namespacepiranha_1_1math.html#acc11ac62c76344c10610b3b8e3326764" title="Substitution of integral power. ">piranha::math::ipow_subs</a> function.  <a href="classpiranha_1_1has__ipow__subs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1has__is__unitary.html">has_is_unitary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect the presence of the <a class="el" href="namespacepiranha_1_1math.html#ad23994843ee00b36960ab6b8a20962dd" title="Unitary test. ">piranha::math::is_unitary()</a> function.  <a href="classpiranha_1_1has__is__unitary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1has__is__zero.html">has_is_zero</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect the presence of the <a class="el" href="namespacepiranha_1_1math.html#a00db2c62bd93a48258dd8545c6fb468c" title="Zero test. ">piranha::math::is_zero()</a> function.  <a href="classpiranha_1_1has__is__zero.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1has__ldegree.html">has_ldegree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect if type has a low degree property.  <a href="classpiranha_1_1has__ldegree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1has__multiply__accumulate.html">has_multiply_accumulate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect the availability of <a class="el" href="namespacepiranha_1_1math.html#a904f85d9a1ef8c95384bcb89ff0795e7" title="Multiply-accumulate. ">piranha::math::multiply_accumulate</a>.  <a href="classpiranha_1_1has__multiply__accumulate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1has__negate.html">has_negate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect the presence of the <a class="el" href="namespacepiranha_1_1math.html#a7ec2303772eab00a1ca75c11106c60b9" title="In-place negation. ">piranha::math::negate</a> function.  <a href="classpiranha_1_1has__negate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1has__pbracket.html">has_pbracket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect <a class="el" href="namespacepiranha_1_1math.html#a7ac3a41bda6c458a8a4280badc7fcf17" title="Poisson bracket. ">piranha::math::pbracket()</a>.  <a href="classpiranha_1_1has__pbracket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1has__print__coefficient.html">has_print_coefficient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for classes implementing <a class="el" href="namespacepiranha.html#abbd5f3761e6b58233f94b615837ccb84" title="Print series coefficient. ">piranha::print_coefficient</a>.  <a href="classpiranha_1_1has__print__coefficient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1has__print__tex__coefficient.html">has_print_tex_coefficient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for classes implementing <a class="el" href="namespacepiranha.html#ac5f03dab82a8f92ec7c42ab6e8bbf735" title="Print series coefficient in TeX mode. ">piranha::print_tex_coefficient</a>.  <a href="classpiranha_1_1has__print__tex__coefficient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1has__safe__cast.html">has_safe_cast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect <a class="el" href="namespacepiranha.html#a712714b1e1348f73ec01687d5d5c9b2d" title="Safe cast. ">piranha::safe_cast()</a>.  <a href="classpiranha_1_1has__safe__cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1has__sine.html">has_sine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect <a class="el" href="namespacepiranha_1_1math.html#afbe681443ac448d0eec22376992be475" title="Sine. ">piranha::math::sin()</a>.  <a href="classpiranha_1_1has__sine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1has__subs.html">has_subs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect the presence of the <a class="el" href="namespacepiranha_1_1math.html#a5a6cafb8a41a9d777debf7213a7f6da4" title="Substitution. ">piranha::math::subs</a> function.  <a href="classpiranha_1_1has__subs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1has__t__degree.html">has_t_degree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect if type has a trigonometric degree property.  <a href="classpiranha_1_1has__t__degree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1has__t__ldegree.html">has_t_ldegree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect if type has a trigonometric low degree property.  <a href="classpiranha_1_1has__t__ldegree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1has__t__lorder.html">has_t_lorder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect if type has a trigonometric low order property.  <a href="classpiranha_1_1has__t__lorder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1has__t__order.html">has_t_order</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect if type has a trigonometric order property.  <a href="classpiranha_1_1has__t__order.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1has__t__subs.html">has_t_subs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect the presence of the <a class="el" href="namespacepiranha_1_1math.html#a8a1eb57d2b0e2adb24433e9fe86377f5" title="Trigonometric substitution. ">piranha::math::t_subs</a> function.  <a href="classpiranha_1_1has__t__subs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1has__transformation__is__canonical.html">has_transformation_is_canonical</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect <a class="el" href="namespacepiranha_1_1math.html#a652df25527486c9c55b365dd62e74e64" title="Check if a transformation is canonical. ">piranha::math::transformation_is_canonical()</a>.  <a href="classpiranha_1_1has__transformation__is__canonical.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1has__truncate__degree.html">has_truncate_degree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect if types can be used in <a class="el" href="namespacepiranha_1_1math.html#ab529e82af5b6a2f2a87d7c4f2c4268a8" title="Truncation based on the total degree. ">piranha::math::truncate_degree()</a>.  <a href="classpiranha_1_1has__truncate__degree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html">hash_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash set.  <a href="classpiranha_1_1hash__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1ipow__substitutable__series.html">ipow_substitutable_series</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toolbox for series suitable for integral power substitution.  <a href="classpiranha_1_1ipow__substitutable__series.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1is__addable.html">is_addable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addable type trait.  <a href="classpiranha_1_1is__addable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1is__addable__in__place.html">is_addable_in_place</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place addable type trait.  <a href="classpiranha_1_1is__addable__in__place.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1is__cf.html">is_cf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect coefficient types.  <a href="classpiranha_1_1is__cf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1is__container__element.html">is_container_element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for well-behaved container elements.  <a href="structpiranha_1_1is__container__element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1is__differentiable.html">is_differentiable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for differentiable types.  <a href="classpiranha_1_1is__differentiable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1is__divisible.html">is_divisible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divisible type trait.  <a href="classpiranha_1_1is__divisible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1is__divisible__in__place.html">is_divisible_in_place</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place divisible type trait.  <a href="classpiranha_1_1is__divisible__in__place.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1is__equality__comparable.html">is_equality_comparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality-comparable type trait.  <a href="classpiranha_1_1is__equality__comparable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1is__equality__function__object.html">is_equality_function_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect equality function objects.  <a href="classpiranha_1_1is__equality__function__object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1is__evaluable.html">is_evaluable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect the availability of <a class="el" href="namespacepiranha_1_1math.html#a4fd50fafb56550387b3b2dab67cdffcf" title="Evaluation. ">piranha::math::evaluate</a>.  <a href="classpiranha_1_1is__evaluable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1is__exponentiable.html">is_exponentiable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for exponentiable types.  <a href="classpiranha_1_1is__exponentiable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1is__forward__iterator.html">is_forward_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator type trait.  <a href="structpiranha_1_1is__forward__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1is__function__object.html">is_function_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object type trait.  <a href="classpiranha_1_1is__function__object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1is__greater__than__comparable.html">is_greater_than_comparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than-comparable type trait.  <a href="classpiranha_1_1is__greater__than__comparable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1is__hash__function__object.html">is_hash_function_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect hash function objects.  <a href="classpiranha_1_1is__hash__function__object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1is__hashable.html">is_hashable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashable type trait.  <a href="classpiranha_1_1is__hashable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1is__input__iterator.html">is_input_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input iterator type trait.  <a href="structpiranha_1_1is__input__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1is__instance__of.html">is_instance_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for detecting instances of class templates.  <a href="classpiranha_1_1is__instance__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1is__integrable.html">is_integrable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for integrable types.  <a href="classpiranha_1_1is__integrable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1is__iterator.html">is_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type trait.  <a href="structpiranha_1_1is__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1is__key.html">is_key</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect key types.  <a href="classpiranha_1_1is__key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1is__less__than__comparable.html">is_less_than_comparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than-comparable type trait.  <a href="classpiranha_1_1is__less__than__comparable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1is__multipliable.html">is_multipliable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multipliable type trait.  <a href="classpiranha_1_1is__multipliable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1is__multipliable__in__place.html">is_multipliable_in_place</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place multipliable type trait.  <a href="classpiranha_1_1is__multipliable__in__place.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1is__nonconst__rvalue__ref.html">is_nonconst_rvalue_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type is non-const rvalue reference.  <a href="structpiranha_1_1is__nonconst__rvalue__ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1is__nothrow__destructible.html">is_nothrow_destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type is nothrow-destructible.  <a href="structpiranha_1_1is__nothrow__destructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1is__ostreamable.html">is_ostreamable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for classes that can be output-streamed.  <a href="classpiranha_1_1is__ostreamable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1is__series.html">is_series</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect series types.  <a href="classpiranha_1_1is__series.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1is__subtractable.html">is_subtractable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtractable type trait.  <a href="classpiranha_1_1is__subtractable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1is__subtractable__in__place.html">is_subtractable_in_place</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place subtractable type trait.  <a href="classpiranha_1_1is__subtractable__in__place.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1key__has__degree.html">key_has_degree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect if a key type has a degree property.  <a href="classpiranha_1_1key__has__degree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1key__has__ipow__subs.html">key_has_ipow_subs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect the presence of the integral power substitution method in keys.  <a href="classpiranha_1_1key__has__ipow__subs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1key__has__ldegree.html">key_has_ldegree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect if a key type has a low degree property.  <a href="classpiranha_1_1key__has__ldegree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1key__has__subs.html">key_has_subs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect the presence of the substitution method in keys.  <a href="classpiranha_1_1key__has__subs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1key__has__t__degree.html">key_has_t_degree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect if a key type has a trigonometric degree property.  <a href="classpiranha_1_1key__has__t__degree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1key__has__t__ldegree.html">key_has_t_ldegree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect if a key type has a trigonometric low degree property.  <a href="classpiranha_1_1key__has__t__ldegree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1key__has__t__lorder.html">key_has_t_lorder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect if a key type has a trigonometric low order property.  <a href="classpiranha_1_1key__has__t__lorder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1key__has__t__order.html">key_has_t_order</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect if a key type has a trigonometric order property.  <a href="classpiranha_1_1key__has__t__order.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1key__has__t__subs.html">key_has_t_subs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect the presence of the trigonometric substitution method in keys.  <a href="classpiranha_1_1key__has__t__subs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1key__is__convertible.html">key_is_convertible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if a key type is convertible to another key type.  <a href="classpiranha_1_1key__is__convertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1key__is__differentiable.html">key_is_differentiable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect differentiable keys.  <a href="classpiranha_1_1key__is__differentiable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1key__is__evaluable.html">key_is_evaluable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect evaluable keys.  <a href="classpiranha_1_1key__is__evaluable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1key__is__multipliable.html">key_is_multipliable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for multipliable key.  <a href="classpiranha_1_1key__is__multipliable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1kronecker__array.html">kronecker_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker array.  <a href="classpiranha_1_1kronecker__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1kronecker__monomial.html">kronecker_monomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker monomial class.  <a href="classpiranha_1_1kronecker__monomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1monomial.html">monomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monomial class.  <a href="classpiranha_1_1monomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__integer.html">mp_integer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiple precision integer class.  <a href="classpiranha_1_1mp__integer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiple precision rational class.  <a href="classpiranha_1_1mp__rational.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1not__implemented__error.html">not_implemented_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for functionality not implemented or not available on the current platform.  <a href="structpiranha_1_1not__implemented__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1poisson__series.html">poisson_series</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poisson series class.  <a href="classpiranha_1_1poisson__series.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1polynomial.html">polynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polynomial class.  <a href="classpiranha_1_1polynomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1power__series.html">power_series</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power series toolbox.  <a href="classpiranha_1_1power__series.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1print__coefficient__impl.html">print_coefficient_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for <a class="el" href="namespacepiranha.html#abbd5f3761e6b58233f94b615837ccb84" title="Print series coefficient. ">piranha::print_coefficient()</a>.  <a href="structpiranha_1_1print__coefficient__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1print__coefficient__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__4f70554f1e13ddd06c988856639bfd73.html">print_coefficient_impl&lt; Series, typename std::enable_if&lt; is_series&lt; Series &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of <a class="el" href="structpiranha_1_1print__coefficient__impl.html" title="Default functor for piranha::print_coefficient(). ">piranha::print_coefficient_impl</a> for series.  <a href="structpiranha_1_1print__coefficient__impl_3_01_series_00_01typename_01std_1_1enable__if_3_01is__4f70554f1e13ddd06c988856639bfd73.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1print__tex__coefficient__impl.html">print_tex_coefficient_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for <a class="el" href="namespacepiranha.html#ac5f03dab82a8f92ec7c42ab6e8bbf735" title="Print series coefficient in TeX mode. ">piranha::print_tex_coefficient()</a>.  <a href="structpiranha_1_1print__tex__coefficient__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1print__tex__coefficient__impl_3_01_series_00_01typename_01std_1_1enable__if_3_0f1220a64cf7dff2558d14658421acb65.html">print_tex_coefficient_impl&lt; Series, typename std::enable_if&lt; is_series&lt; Series &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of <a class="el" href="structpiranha_1_1print__tex__coefficient__impl.html" title="Default functor for piranha::print_tex_coefficient(). ">piranha::print_tex_coefficient_impl</a> for series.  <a href="structpiranha_1_1print__tex__coefficient__impl_3_01_series_00_01typename_01std_1_1enable__if_3_0f1220a64cf7dff2558d14658421acb65.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1print__tex__coefficient__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01deta7b62f26a29f425de49707b424ec6dbe5.html">print_tex_coefficient_impl&lt; T, typename std::enable_if&lt; detail::is_mp_rational&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of the <a class="el" href="namespacepiranha.html#ac5f03dab82a8f92ec7c42ab6e8bbf735" title="Print series coefficient in TeX mode. ">piranha::print_tex_coefficient()</a> functor for <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="structpiranha_1_1print__tex__coefficient__impl_3_01_t_00_01typename_01std_1_1enable__if_3_01deta7b62f26a29f425de49707b424ec6dbe5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1real.html">real</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arbitrary precision floating-point class.  <a href="classpiranha_1_1real.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1real__trigonometric__kronecker__monomial.html">real_trigonometric_kronecker_monomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real trigonometric Kronecker monomial class.  <a href="classpiranha_1_1real__trigonometric__kronecker__monomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1runtime__info.html">runtime_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime information.  <a href="classpiranha_1_1runtime__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1safe__cast__impl.html">safe_cast_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default functor for the implementation of <a class="el" href="namespacepiranha.html#a712714b1e1348f73ec01687d5d5c9b2d" title="Safe cast. ">piranha::safe_cast()</a>.  <a href="structpiranha_1_1safe__cast__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1safe__cast__impl_3_01_to_00_01_from_00_01detail_1_1sc__int__float__enabler_3_01_to_00_01_from_01_4_01_4.html">safe_cast_impl&lt; To, From, detail::sc_int_float_enabler&lt; To, From &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of <a class="el" href="namespacepiranha.html#a712714b1e1348f73ec01687d5d5c9b2d" title="Safe cast. ">piranha::safe_cast()</a> for conversions involving integral and floating-point types.  <a href="structpiranha_1_1safe__cast__impl_3_01_to_00_01_from_00_01detail_1_1sc__int__float__enabler_3_01_to_00_01_from_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1safe__cast__impl_3_01_to_00_01_from_00_01detail_1_1sc__int__int__enabler_3_01_to_00_01_from_01_4_01_4.html">safe_cast_impl&lt; To, From, detail::sc_int_int_enabler&lt; To, From &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="namespacepiranha.html#a712714b1e1348f73ec01687d5d5c9b2d" title="Safe cast. ">piranha::safe_cast()</a> for integral types.  <a href="structpiranha_1_1safe__cast__impl_3_01_to_00_01_from_00_01detail_1_1sc__int__int__enabler_3_01_to_00_01_from_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1safe__cast__impl_3_01_to_00_01_from_00_01detail_1_1sc__rat__enabler_3_01_to_00_01_from_01_4_01_4.html">safe_cast_impl&lt; To, From, detail::sc_rat_enabler&lt; To, From &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of <a class="el" href="namespacepiranha.html#a712714b1e1348f73ec01687d5d5c9b2d" title="Safe cast. ">piranha::safe_cast()</a> for conversions involving <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="structpiranha_1_1safe__cast__impl_3_01_to_00_01_from_00_01detail_1_1sc__rat__enabler_3_01_to_00_01_from_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1safe__cast__impl_3_01_to_00_01_from_00_01detail_1_1sc__real__enabler_3_01_to_00_01_from_01_4_01_4.html">safe_cast_impl&lt; To, From, detail::sc_real_enabler&lt; To, From &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of <a class="el" href="namespacepiranha.html#a712714b1e1348f73ec01687d5d5c9b2d" title="Safe cast. ">piranha::safe_cast()</a> for conversions involving <a class="el" href="classpiranha_1_1real.html" title="Arbitrary precision floating-point class. ">piranha::real</a>.  <a href="structpiranha_1_1safe__cast__impl_3_01_to_00_01_from_00_01detail_1_1sc__real__enabler_3_01_to_00_01_from_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html">series</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Series class.  <a href="classpiranha_1_1series.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series__has__multiplier.html">series_has_multiplier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect the availability of a series multiplier.  <a href="classpiranha_1_1series__has__multiplier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series__is__rebindable.html">series_is_rebindable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a series can be rebound.  <a href="classpiranha_1_1series__is__rebindable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series__multiplier.html">series_multiplier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default series multiplier.  <a href="classpiranha_1_1series__multiplier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series__multiplier_3_01_series_00_01typename_01std_1_1enable__if_3_01detail_1_1kb459da37a0ddb37444991a23278e9f36.html">series_multiplier&lt; Series, typename std::enable_if&lt; detail::kronecker_enabler&lt; Series &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Series multiplier specialisation for polynomials with Kronecker monomials.  <a href="classpiranha_1_1series__multiplier_3_01_series_00_01typename_01std_1_1enable__if_3_01detail_1_1kb459da37a0ddb37444991a23278e9f36.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series__operators.html">series_operators</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Series operators.  <a href="classpiranha_1_1series__operators.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series__recursion__index.html">series_recursion_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Series recursion index.  <a href="classpiranha_1_1series__recursion__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1settings.html">settings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global settings.  <a href="classpiranha_1_1settings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1small__vector.html">small_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small vector class.  <a href="classpiranha_1_1small__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1static__vector.html">static_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static vector class.  <a href="classpiranha_1_1static__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1substitutable__series.html">substitutable_series</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toolbox for substitutable series.  <a href="classpiranha_1_1substitutable__series.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1symbol.html">symbol</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Literal symbol class.  <a href="classpiranha_1_1symbol.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol set.  <a href="classpiranha_1_1symbol__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1t__substitutable__series.html">t_substitutable_series</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toolbox for series that support trigonometric substitution.  <a href="classpiranha_1_1t__substitutable__series.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1term.html">term</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Term class.  <a href="classpiranha_1_1term.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1thread__barrier.html">thread_barrier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread barrier.  <a href="classpiranha_1_1thread__barrier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1thread__management.html">thread_management</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread management.  <a href="classpiranha_1_1thread__management.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1thread__pool.html">thread_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static thread pool.  <a href="classpiranha_1_1thread__pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1tracing.html">tracing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracing class.  <a href="classpiranha_1_1tracing.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1trigonometric__series.html">trigonometric_series</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigonometric series toolbox.  <a href="classpiranha_1_1trigonometric__series.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1tuning.html">tuning</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performance tuning.  <a href="classpiranha_1_1tuning.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpiranha_1_1zero__division__error.html">zero_division_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for signalling division by zero.  <a href="structpiranha_1_1zero__division__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8a41a40472e52a050f1c6a80ee9cf340"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a41a40472e52a050f1c6a80ee9cf340"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepiranha.html#a8a41a40472e52a050f1c6a80ee9cf340">k_monomial</a> = <a class="el" href="classpiranha_1_1kronecker__monomial.html">kronecker_monomial</a>&lt;&gt;</td></tr>
<tr class="memdesc:a8a41a40472e52a050f1c6a80ee9cf340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="classpiranha_1_1kronecker__monomial.html" title="Kronecker monomial class. ">piranha::kronecker_monomial</a> with default type. <br /></td></tr>
<tr class="separator:a8a41a40472e52a050f1c6a80ee9cf340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236e3b8e7d5b78d00fcdc5de941e9f4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a236e3b8e7d5b78d00fcdc5de941e9f4b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b">integer</a> = <a class="el" href="classpiranha_1_1mp__integer.html">mp_integer</a>&lt;&gt;</td></tr>
<tr class="memdesc:a236e3b8e7d5b78d00fcdc5de941e9f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a> with default bit size. <br /></td></tr>
<tr class="separator:a236e3b8e7d5b78d00fcdc5de941e9f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae329702ab296cd14e0e6d780ef09d5eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae329702ab296cd14e0e6d780ef09d5eb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepiranha.html#ae329702ab296cd14e0e6d780ef09d5eb">rational</a> = <a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a>&lt;&gt;</td></tr>
<tr class="memdesc:ae329702ab296cd14e0e6d780ef09d5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> with default bit size. <br /></td></tr>
<tr class="separator:ae329702ab296cd14e0e6d780ef09d5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8373ab492b3cd9e4ae7ba5f42e4805"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf8373ab492b3cd9e4ae7ba5f42e4805"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepiranha.html#acf8373ab492b3cd9e4ae7ba5f42e4805">rtk_monomial</a> = <a class="el" href="classpiranha_1_1real__trigonometric__kronecker__monomial.html">real_trigonometric_kronecker_monomial</a>&lt;&gt;</td></tr>
<tr class="memdesc:acf8373ab492b3cd9e4ae7ba5f42e4805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="classpiranha_1_1real__trigonometric__kronecker__monomial.html" title="Real trigonometric Kronecker monomial class. ">piranha::real_trigonometric_kronecker_monomial</a> with default type. <br /></td></tr>
<tr class="separator:acf8373ab492b3cd9e4ae7ba5f42e4805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b08e44f8cff8872d8708fa58e4efcd3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cf &gt; </td></tr>
<tr class="memitem:a3b08e44f8cff8872d8708fa58e4efcd3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha.html#a3b08e44f8cff8872d8708fa58e4efcd3">series_rebind</a> = detail::series_rebind_&lt; T, Cf &gt;</td></tr>
<tr class="memdesc:a3b08e44f8cff8872d8708fa58e4efcd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebind series.  <a href="#a3b08e44f8cff8872d8708fa58e4efcd3">More...</a><br /></td></tr>
<tr class="separator:a3b08e44f8cff8872d8708fa58e4efcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd41e4fdc9e391a963e34667f19e62ad"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:afd41e4fdc9e391a963e34667f19e62ad"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha.html#afd41e4fdc9e391a963e34667f19e62ad">min_int</a> = typename detail::min_int_impl&lt; T, Args...&gt;::type</td></tr>
<tr class="memdesc:afd41e4fdc9e391a963e34667f19e62ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect narrowest integer type.  <a href="#afd41e4fdc9e391a963e34667f19e62ad">More...</a><br /></td></tr>
<tr class="separator:afd41e4fdc9e391a963e34667f19e62ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ffc5baf86eac1627ad008e5608a9f7c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a8ffc5baf86eac1627ad008e5608a9f7c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha.html#a8ffc5baf86eac1627ad008e5608a9f7c">max_int</a> = typename detail::max_int_impl&lt; T, Args...&gt;::type</td></tr>
<tr class="memdesc:a8ffc5baf86eac1627ad008e5608a9f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect widest integer type.  <a href="#a8ffc5baf86eac1627ad008e5608a9f7c">More...</a><br /></td></tr>
<tr class="separator:a8ffc5baf86eac1627ad008e5608a9f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8740bbc3e472de1f0acebc18c416c35d"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From , detail::convert_enabler&lt; To, From &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8740bbc3e472de1f0acebc18c416c35d"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha.html#a8740bbc3e472de1f0acebc18c416c35d">convert_to</a> (const From &amp;x)</td></tr>
<tr class="memdesc:a8740bbc3e472de1f0acebc18c416c35d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic conversion function.  <a href="#a8740bbc3e472de1f0acebc18c416c35d">More...</a><br /></td></tr>
<tr class="separator:a8740bbc3e472de1f0acebc18c416c35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41914add70b267b6e4f3c686817c9d8a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepiranha.html#a41914add70b267b6e4f3c686817c9d8a">aligned_palloc</a> (const std::size_t &amp;alignment, const std::size_t &amp;size)</td></tr>
<tr class="memdesc:a41914add70b267b6e4f3c686817c9d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory aligned to a specific value.  <a href="#a41914add70b267b6e4f3c686817c9d8a">More...</a><br /></td></tr>
<tr class="separator:a41914add70b267b6e4f3c686817c9d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5626a367270e450d7d4563dfabe77035"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepiranha.html#a5626a367270e450d7d4563dfabe77035">aligned_pfree</a> (const std::size_t &amp;alignment, void *ptr)</td></tr>
<tr class="memdesc:a5626a367270e450d7d4563dfabe77035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated via piranha::aligned_alloc.  <a href="#a5626a367270e450d7d4563dfabe77035">More...</a><br /></td></tr>
<tr class="separator:a5626a367270e450d7d4563dfabe77035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0527373a9c22b44e00c1c7531b21b65"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa0527373a9c22b44e00c1c7531b21b65"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha.html#aa0527373a9c22b44e00c1c7531b21b65">alignment_check</a> (const std::size_t &amp;alignment)</td></tr>
<tr class="memdesc:aa0527373a9c22b44e00c1c7531b21b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alignment checks.  <a href="#aa0527373a9c22b44e00c1c7531b21b65">More...</a><br /></td></tr>
<tr class="separator:aa0527373a9c22b44e00c1c7531b21b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d47fce414c16ff8cbabd0c65ddfd9f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;is_container_element&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a11d47fce414c16ff8cbabd0c65ddfd9f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha.html#a11d47fce414c16ff8cbabd0c65ddfd9f">parallel_value_init</a> (T *ptr, const std::size_t &amp;size, const unsigned &amp;n_threads)</td></tr>
<tr class="memdesc:a11d47fce414c16ff8cbabd0c65ddfd9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel value initialisation.  <a href="#a11d47fce414c16ff8cbabd0c65ddfd9f">More...</a><br /></td></tr>
<tr class="separator:a11d47fce414c16ff8cbabd0c65ddfd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a7db62803c0cb08bb5abe242c60ddb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;is_container_element&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aa5a7db62803c0cb08bb5abe242c60ddb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha.html#aa5a7db62803c0cb08bb5abe242c60ddb">parallel_destroy</a> (T *ptr, const std::size_t &amp;size, const unsigned &amp;n_threads)</td></tr>
<tr class="memdesc:aa5a7db62803c0cb08bb5abe242c60ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel destruction.  <a href="#aa5a7db62803c0cb08bb5abe242c60ddb">More...</a><br /></td></tr>
<tr class="separator:aa5a7db62803c0cb08bb5abe242c60ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ebf21b831683c972e187866f8fac34"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;is_container_element&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a74ebf21b831683c972e187866f8fac34"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T[], detail::parallel_deleter&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha.html#a74ebf21b831683c972e187866f8fac34">make_parallel_array</a> (const std::size_t &amp;size, const unsigned &amp;n_threads)</td></tr>
<tr class="memdesc:a74ebf21b831683c972e187866f8fac34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an array in parallel.  <a href="#a74ebf21b831683c972e187866f8fac34">More...</a><br /></td></tr>
<tr class="separator:a74ebf21b831683c972e187866f8fac34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd5f3761e6b58233f94b615837ccb84"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abbd5f3761e6b58233f94b615837ccb84"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha.html#abbd5f3761e6b58233f94b615837ccb84">print_coefficient</a> (std::ostream &amp;os, const T &amp;cf) -&gt; decltype(<a class="el" href="structpiranha_1_1print__coefficient__impl.html">print_coefficient_impl</a>&lt; T &gt;()(os, cf))</td></tr>
<tr class="memdesc:abbd5f3761e6b58233f94b615837ccb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print series coefficient.  <a href="#abbd5f3761e6b58233f94b615837ccb84">More...</a><br /></td></tr>
<tr class="separator:abbd5f3761e6b58233f94b615837ccb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f03dab82a8f92ec7c42ab6e8bbf735"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac5f03dab82a8f92ec7c42ab6e8bbf735"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha.html#ac5f03dab82a8f92ec7c42ab6e8bbf735">print_tex_coefficient</a> (std::ostream &amp;os, const T &amp;cf) -&gt; decltype(<a class="el" href="structpiranha_1_1print__tex__coefficient__impl.html">print_tex_coefficient_impl</a>&lt; T &gt;()(os, cf))</td></tr>
<tr class="memdesc:ac5f03dab82a8f92ec7c42ab6e8bbf735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print series coefficient in TeX mode.  <a href="#ac5f03dab82a8f92ec7c42ab6e8bbf735">More...</a><br /></td></tr>
<tr class="separator:ac5f03dab82a8f92ec7c42ab6e8bbf735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712714b1e1348f73ec01687d5d5c9b2d"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From , detail::safe_cast_enabler&lt; To, From &gt;  = 0&gt; </td></tr>
<tr class="memitem:a712714b1e1348f73ec01687d5d5c9b2d"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepiranha.html#a712714b1e1348f73ec01687d5d5c9b2d">safe_cast</a> (const From &amp;x)</td></tr>
<tr class="memdesc:a712714b1e1348f73ec01687d5d5c9b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe cast.  <a href="#a712714b1e1348f73ec01687d5d5c9b2d">More...</a><br /></td></tr>
<tr class="separator:a712714b1e1348f73ec01687d5d5c9b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Root piranha namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a8ffc5baf86eac1627ad008e5608a9f7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepiranha.html#a8ffc5baf86eac1627ad008e5608a9f7c">piranha::max_int</a> = typedef typename detail::max_int_impl&lt;T,Args...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect widest integer type. </p>
<p>This type alias requires <code>T</code> and <code>Args</code> (if any) to be all signed or unsigned integer types. It will be defined as the input type with the widest numerical range. </p>

<p>Definition at line <a class="el" href="type__traits_8hpp_source.html#l00787">787</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afd41e4fdc9e391a963e34667f19e62ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepiranha.html#afd41e4fdc9e391a963e34667f19e62ad">piranha::min_int</a> = typedef typename detail::min_int_impl&lt;T,Args...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect narrowest integer type. </p>
<p>This type alias requires <code>T</code> and <code>Args</code> (if any) to be all signed or unsigned integer types. It will be defined as the input type with the narrowest numerical range. </p>

<p>Definition at line <a class="el" href="type__traits_8hpp_source.html#l00779">779</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3b08e44f8cff8872d8708fa58e4efcd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Cf &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepiranha.html#a3b08e44f8cff8872d8708fa58e4efcd3">piranha::series_rebind</a> = typedef detail::series_rebind_&lt;T,Cf&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rebind series. </p>
<p>Utility alias to rebind series <code>T</code> to coefficient <code>Cf</code>. See <a class="el" href="classpiranha_1_1series__is__rebindable.html" title="Check if a series can be rebound. ">piranha::series_is_rebindable</a> for an explanation. In addition to being a shortcut to the <code>rebind</code> alias in <code>T</code> (if present), the implementation will also check that <code>T</code> and <code>Cf</code> satisfy the <a class="el" href="classpiranha_1_1series__is__rebindable.html" title="Check if a series can be rebound. ">piranha::series_is_rebindable</a> type traits. </p>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l00189">189</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a41914add70b267b6e4f3c686817c9d8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* piranha::aligned_palloc </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory aligned to a specific value. </p>
<p>This function will allocate a block of memory of <code>size</code> bytes aligned to <code>alignment</code>. If <code>size</code> is zero, <code>nullptr</code> will be returned. If <code>alignment</code> is zero, <code>std::malloc()</code> will be used for the allocation. Otherwise, the allocation will be deferred to an implementation-defined and platform-dependent low-level routine (e.g., <code>posix_memalign()</code>). If such a low level routine is not available, an exception will be raised.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>desired alignment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of bytes to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory block, or <code>nullptr</code> if <code>size</code> is zero.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if the allocation fails for any reason (e.g., bad alignment value, failure in the low-level allocation routine, etc.). </td></tr>
    <tr><td class="paramname"><a class="el" href="structpiranha_1_1not__implemented__error.html" title="Exception for functionality not implemented or not available on the current platform. ">piranha::not_implemented_error</a></td><td>if <code>alignment</code> and <code>size</code> are both nonzero and the low-level allocation function is not available on the platform. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="memory_8hpp_source.html#l00127">127</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5626a367270e450d7d4563dfabe77035"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void piranha::aligned_pfree </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free memory allocated via piranha::aligned_alloc. </p>
<p>This function must be used to deallocate memory obtained via piranha::aligned_alloc(). If <code>ptr</code> is <code>nullptr</code>, this function will be a no-op. If <code>alignment</code> is zero, <code>std::free()</code> will be used. Otherwise, the deallocation will be deferred to an implementation-defined and platform-dependent low-level routine (e.g., <code>_aligned_free()</code>). If such a low level routine is not available, an exception will be raised.</p>
<p>The value of <code>alignment</code> must be the same used for the allocation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>alignment value used during allocation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to the memory to be freed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structpiranha_1_1not__implemented__error.html" title="Exception for functionality not implemented or not available on the current platform. ">piranha::not_implemented_error</a></td><td>if <code>ptr</code> is not <code>nullptr</code>, <code>alignment</code> is not zero and the low-level deallocation routine is not available on the platform. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="memory_8hpp_source.html#l00175">175</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa0527373a9c22b44e00c1c7531b21b65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool piranha::alignment_check </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alignment checks. </p>
<p>This function will run a series of checks on an alignment value to be used to allocate storage for objects of the decay type of <code>T</code> using <a class="el" href="namespacepiranha.html#a41914add70b267b6e4f3c686817c9d8a" title="Allocate memory aligned to a specific value. ">piranha::aligned_palloc()</a>, and it will retun <code>true</code> if the alignment value passes these checks, <code>false</code> otherwise. An alignment of zero will always return <code>true</code>.</p>
<p>The checks performed are the following:</p><ul>
<li>the alignment must be a power of 2 (3.11/4),</li>
<li>the alignment must not be smaller than the default alignment of <code>T</code>, as reported by <code>alignas()</code>,</li>
<li>the alignment must satisfy additional platform-dependent checks (e.g., <code>posix_memalign()</code> requires the alignment to be a multiple of <code>sizeof(void *)</code>).</li>
</ul>
<p>Note that <a class="el" href="namespacepiranha.html#a41914add70b267b6e4f3c686817c9d8a" title="Allocate memory aligned to a specific value. ">piranha::aligned_palloc()</a> will not check the alignment via this function, and that even if this function returns <code>true</code> on an alignment value, this will not guarantee that the allocation via <a class="el" href="namespacepiranha.html#a41914add70b267b6e4f3c686817c9d8a" title="Allocate memory aligned to a specific value. ">piranha::aligned_palloc()</a> will succeed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>alignment value to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the input value is zero or if it passes the alignment checks, <code>false</code> otherwise. </dd></dl>

<p>Definition at line <a class="el" href="memory_8hpp_source.html#l00215">215</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8740bbc3e472de1f0acebc18c416c35d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From , detail::convert_enabler&lt; To, From &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To piranha::convert_to </td>
          <td>(</td>
          <td class="paramtype">const From &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic conversion function. </p>
<p>This function is meant to convert an instance of type <code>From</code> to an instance of the decay type of <code>To</code>. It is intended to be a user-extensible replacement for <code>static_cast</code>.</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1convert__to__impl.html" title="Default functor for the implementation of piranha::convert_to(). ">piranha::convert_to_impl</a> functor's call operator. The decay type of <code>To</code> is passed as first template parameter of <a class="el" href="structpiranha_1_1convert__to__impl.html" title="Default functor for the implementation of piranha::convert_to(). ">piranha::convert_to_impl</a>, whereas <code>From</code> is passed as-is.</p>
<p>Any specialisation of <a class="el" href="structpiranha_1_1convert__to__impl.html" title="Default functor for the implementation of piranha::convert_to(). ">piranha::convert_to_impl</a> must have a call operator returning an instance of the decay type of <code>To</code>, otherwise this function will be disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>conversion argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of the decay type of <code>To</code> converted from <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of the <a class="el" href="structpiranha_1_1convert__to__impl.html" title="Default functor for the implementation of piranha::convert_to(). ">piranha::convert_to_impl</a> functor. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="convert__to_8hpp_source.html#l00086">86</a> of file <a class="el" href="convert__to_8hpp_source.html">convert_to.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a74ebf21b831683c972e187866f8fac34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;is_container_element&lt;T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;T[],detail::parallel_deleter&lt;T&gt; &gt; piranha::make_parallel_array </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>n_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an array in parallel. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if <code>T</code> satisfies the <a class="el" href="structpiranha_1_1is__container__element.html" title="Type trait for well-behaved container elements. ">piranha::is_container_element</a> type trait.</dd></dl>
<p>This function will create an array whose values will be initialised in parallel using <a class="el" href="namespacepiranha.html#a11d47fce414c16ff8cbabd0c65ddfd9f" title="Parallel value initialisation. ">piranha::parallel_value_init()</a>. The pointer to the array is returned wrapped inside an <code>std::unique_ptr</code> that will take care of destroying the array elements (also in parallel using <a class="el" href="namespacepiranha.html#aa5a7db62803c0cb08bb5abe242c60ddb" title="Parallel destruction. ">piranha::parallel_destroy()</a>) and deallocating the memory when the destructor is called.</p>
<dl class="section note"><dt>Note</dt><dd>Due to the special semantics of the parallel deleter, the returned smart pointer cannot be reset with another arbitrary pointer without supplying a new deleter. To replace the managed object while supplying a new deleter as well, move semantics may be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of the array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_threads</td><td>number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <code>std::unique_ptr</code> wrapping the array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if <code>size</code> is greater than an implementation-defined value. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="namespacepiranha.html#a41914add70b267b6e4f3c686817c9d8a" title="Allocate memory aligned to a specific value. ">piranha::aligned_palloc()</a> (called with an alignment value of 0),</li>
<li><a class="el" href="namespacepiranha.html#a11d47fce414c16ff8cbabd0c65ddfd9f" title="Parallel value initialisation. ">piranha::parallel_value_init()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="memory_8hpp_source.html#l00456">456</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa5a7db62803c0cb08bb5abe242c60ddb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;is_container_element&lt;T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void piranha::parallel_destroy </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>n_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel destruction. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if <code>T</code> satisfies the <a class="el" href="structpiranha_1_1is__container__element.html" title="Type trait for well-behaved container elements. ">piranha::is_container_element</a> type trait.</dd></dl>
<p>This function will destroy in parallel the element of an array <code>ptr</code> of size <code>size</code>. If <code>n_threads</code> is 0 or 1, the operation will be performed in the calling thread, otherwise the first <code>n_threads</code> in <a class="el" href="classpiranha_1_1thread__pool.html" title="Static thread pool. ">piranha::thread_pool</a> will be used to perform the operation concurrently.</p>
<p>The function is a no-op if <code>ptr</code> is null or if <code>T</code> has a trivial destructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to the array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of the array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_threads</td><td>number of threads to use. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="memory_8hpp_source.html#l00339">339</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a11d47fce414c16ff8cbabd0c65ddfd9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;is_container_element&lt;T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void piranha::parallel_value_init </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>n_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel value initialisation. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled only if <code>T</code> satisfies the <a class="el" href="structpiranha_1_1is__container__element.html" title="Type trait for well-behaved container elements. ">piranha::is_container_element</a> type trait.</dd></dl>
<p>This function will value-initialise in parallel the array <code>ptr</code> of size <code>size</code>. The routine will use the first <code>n_threads</code> from <a class="el" href="classpiranha_1_1thread__pool.html" title="Static thread pool. ">piranha::thread_pool</a> to perform the operation concurrently. If <code>n_threads</code> is 1 or 0, the operation will be performed in the calling thread. If <code>ptr</code> is null, this function will be a no-op.</p>
<p>This function provides the strong exception safety guarantee: in case of errors, any constructed instance of <code>T</code> will be destroyed before the error is re-thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to the array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of the array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_threads</td><td>number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>in case of memory allocation errors in multithreaded mode. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the value initialisation of instances of type <code>T</code>,</li>
<li><a class="el" href="classpiranha_1_1thread__pool.html#a3478c7cb97f5030d943d5d99e50717a3" title="Append task. ">piranha::thread_pool::enqueue()</a> and <a class="el" href="classpiranha_1_1future__list.html#a2e80f33417eef5cb4ac2ecf6d7c5c942" title="Move-insert a future. ">piranha::future_list::push_back()</a>, only in multithreaded mode. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="memory_8hpp_source.html#l00262">262</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abbd5f3761e6b58233f94b615837ccb84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::print_coefficient </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>cf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1print__coefficient__impl.html">print_coefficient_impl</a>&lt;T&gt;()(os,cf))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print series coefficient. </p>
<p>This function is used in the stream operator overload for <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a> when printing coefficients.</p>
<p>The implementation uses the call operator of the <a class="el" href="structpiranha_1_1print__coefficient__impl.html" title="Default functor for piranha::print_coefficient(). ">piranha::print_coefficient_impl</a> functor. Specialisations of <a class="el" href="structpiranha_1_1print__coefficient__impl.html" title="Default functor for piranha::print_coefficient(). ">piranha::print_coefficient_impl</a> can be defined to customize the behaviour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>target stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cf</td><td>coefficient object to be printed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value returned by the call operator of <a class="el" href="structpiranha_1_1print__coefficient__impl.html" title="Default functor for piranha::print_coefficient(). ">piranha::print_coefficient_impl</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1print__coefficient__impl.html" title="Default functor for piranha::print_coefficient(). ">piranha::print_coefficient_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="print__coefficient_8hpp_source.html#l00077">77</a> of file <a class="el" href="print__coefficient_8hpp_source.html">print_coefficient.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac5f03dab82a8f92ec7c42ab6e8bbf735"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto piranha::print_tex_coefficient </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>cf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structpiranha_1_1print__tex__coefficient__impl.html">print_tex_coefficient_impl</a>&lt;T&gt;()(os,cf))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print series coefficient in TeX mode. </p>
<p>This function is used in to print coefficients in TeX mode.</p>
<p>The implementation uses the call operator of the <a class="el" href="structpiranha_1_1print__tex__coefficient__impl.html" title="Default functor for piranha::print_tex_coefficient(). ">piranha::print_tex_coefficient_impl</a> functor. Specialisations of <a class="el" href="structpiranha_1_1print__tex__coefficient__impl.html" title="Default functor for piranha::print_tex_coefficient(). ">piranha::print_tex_coefficient_impl</a> can be defined to customize the behaviour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>target stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cf</td><td>coefficient object to be printed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value returned by the call operator of <a class="el" href="structpiranha_1_1print__tex__coefficient__impl.html" title="Default functor for piranha::print_tex_coefficient(). ">piranha::print_tex_coefficient_impl</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of <a class="el" href="structpiranha_1_1print__tex__coefficient__impl.html" title="Default functor for piranha::print_tex_coefficient(). ">piranha::print_tex_coefficient_impl</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="print__tex__coefficient_8hpp_source.html#l00074">74</a> of file <a class="el" href="print__tex__coefficient_8hpp_source.html">print_tex_coefficient.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a712714b1e1348f73ec01687d5d5c9b2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From , detail::safe_cast_enabler&lt; To, From &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To piranha::safe_cast </td>
          <td>(</td>
          <td class="paramtype">const From &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safe cast. </p>
<p>This function is meant to be used when it is necessary to convert between two types while making sure that the value is preserved after the conversion. For instance, a safe cast between integral types will check that the input value is representable by the return type, otherwise an error will be raised.</p>
<p>The actual implementation of this function is in the <a class="el" href="structpiranha_1_1safe__cast__impl.html" title="Default functor for the implementation of piranha::safe_cast(). ">piranha::safe_cast_impl</a> functor's call operator. The decay type of <code>To</code> is passed as first template parameter of <a class="el" href="structpiranha_1_1safe__cast__impl.html" title="Default functor for the implementation of piranha::safe_cast(). ">piranha::safe_cast_impl</a>, whereas <code>From</code> is passed as-is.</p>
<p>Any specialisation of <a class="el" href="structpiranha_1_1safe__cast__impl.html" title="Default functor for the implementation of piranha::safe_cast(). ">piranha::safe_cast_impl</a> must have a call operator returning an instance of the decay type of <code>To</code>, otherwise this function will be disabled.</p>
<p>Any exception thrown by the implementation will be caught and an <code>std::invalid_argument</code> exception will be raised instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>argument for the conversion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> converted to the decay type of <code>To</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the conversion fails. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="safe__cast_8hpp_source.html#l00225">225</a> of file <a class="el" href="safe__cast_8hpp_source.html">safe_cast.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 18 2015 21:06:04 for piranha by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9
</small></address>
</body>
</html>

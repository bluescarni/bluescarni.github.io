<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>piranha: piranha::mp_rational&lt; NBits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">piranha
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepiranha.html">piranha</a></li><li class="navelem"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classpiranha_1_1mp__rational-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">piranha::mp_rational&lt; NBits &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Multiple precision rational class.  
 <a href="classpiranha_1_1mp__rational.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac966f004ceb41b9e076abfd1ce286f4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac966f004ceb41b9e076abfd1ce286f4f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#ac966f004ceb41b9e076abfd1ce286f4f">int_type</a> = <a class="el" href="classpiranha_1_1mp__integer.html">mp_integer</a>&lt; NBits &gt;</td></tr>
<tr class="memdesc:ac966f004ceb41b9e076abfd1ce286f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a> type used to represent numerator and denominator. <br /></td></tr>
<tr class="separator:ac966f004ceb41b9e076abfd1ce286f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab6e9a682b16c0f1e7150f31d8ec87c8c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#ab6e9a682b16c0f1e7150f31d8ec87c8c">mp_rational</a> ()</td></tr>
<tr class="memdesc:ab6e9a682b16c0f1e7150f31d8ec87c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#ab6e9a682b16c0f1e7150f31d8ec87c8c">More...</a><br /></td></tr>
<tr class="separator:ab6e9a682b16c0f1e7150f31d8ec87c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4453562c98cc60a9b0d5c57de0521f4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4453562c98cc60a9b0d5c57de0521f4b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a4453562c98cc60a9b0d5c57de0521f4b">mp_rational</a> (const <a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> &amp;)=default</td></tr>
<tr class="memdesc:a4453562c98cc60a9b0d5c57de0521f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted copy constructor. <br /></td></tr>
<tr class="separator:a4453562c98cc60a9b0d5c57de0521f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b07d4cc47b72bdbe459b8ad6dd50aa0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b07d4cc47b72bdbe459b8ad6dd50aa0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a0b07d4cc47b72bdbe459b8ad6dd50aa0">mp_rational</a> (<a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a0b07d4cc47b72bdbe459b8ad6dd50aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a0b07d4cc47b72bdbe459b8ad6dd50aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f248dee9ef50aa22ec830315addea6a"><td class="memTemplParams" colspan="2">template&lt;typename I0 , typename I1 , nd_ctor_enabler&lt; I0, I1 &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6f248dee9ef50aa22ec830315addea6a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a6f248dee9ef50aa22ec830315addea6a">mp_rational</a> (const I0 &amp;n, const I1 &amp;d)</td></tr>
<tr class="memdesc:a6f248dee9ef50aa22ec830315addea6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from numerator/denominator pair.  <a href="#a6f248dee9ef50aa22ec830315addea6a">More...</a><br /></td></tr>
<tr class="separator:a6f248dee9ef50aa22ec830315addea6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e34b5bb5edcc34a545a7bb2b9e5e71"><td class="memTemplParams" colspan="2">template&lt;typename T , generic_ctor_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad0e34b5bb5edcc34a545a7bb2b9e5e71"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#ad0e34b5bb5edcc34a545a7bb2b9e5e71">mp_rational</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ad0e34b5bb5edcc34a545a7bb2b9e5e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic constructor.  <a href="#ad0e34b5bb5edcc34a545a7bb2b9e5e71">More...</a><br /></td></tr>
<tr class="separator:ad0e34b5bb5edcc34a545a7bb2b9e5e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3ff6d094cc7ab86184529ee7cd9a15"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a9f3ff6d094cc7ab86184529ee7cd9a15">mp_rational</a> (const char *str)</td></tr>
<tr class="memdesc:a9f3ff6d094cc7ab86184529ee7cd9a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from C string.  <a href="#a9f3ff6d094cc7ab86184529ee7cd9a15">More...</a><br /></td></tr>
<tr class="separator:a9f3ff6d094cc7ab86184529ee7cd9a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524940ea89563f0d41c999d3bdfcf68f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a524940ea89563f0d41c999d3bdfcf68f">mp_rational</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a524940ea89563f0d41c999d3bdfcf68f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from C++ string.  <a href="#a524940ea89563f0d41c999d3bdfcf68f">More...</a><br /></td></tr>
<tr class="separator:a524940ea89563f0d41c999d3bdfcf68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f34ad416fda0c0136a9ebccb49ed00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75f34ad416fda0c0136a9ebccb49ed00"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a75f34ad416fda0c0136a9ebccb49ed00">~mp_rational</a> ()</td></tr>
<tr class="memdesc:a75f34ad416fda0c0136a9ebccb49ed00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a75f34ad416fda0c0136a9ebccb49ed00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a54d160600597967e8cf34bf2f02146"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a54d160600597967e8cf34bf2f02146"></a>
<a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a6a54d160600597967e8cf34bf2f02146">operator=</a> (const <a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> &amp;)=default</td></tr>
<tr class="memdesc:a6a54d160600597967e8cf34bf2f02146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted copy assignment operator. <br /></td></tr>
<tr class="separator:a6a54d160600597967e8cf34bf2f02146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e617743a1cfd3581342ab4f756d286"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3e617743a1cfd3581342ab4f756d286"></a>
<a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#aa3e617743a1cfd3581342ab4f756d286">operator=</a> (<a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:aa3e617743a1cfd3581342ab4f756d286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. <br /></td></tr>
<tr class="separator:aa3e617743a1cfd3581342ab4f756d286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90da88a721caa2353f32ae0cc4cb3ea"><td class="memTemplParams" colspan="2">template&lt;typename T , generic_ctor_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:aa90da88a721caa2353f32ae0cc4cb3ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#aa90da88a721caa2353f32ae0cc4cb3ea">operator=</a> (const T &amp;x)</td></tr>
<tr class="memdesc:aa90da88a721caa2353f32ae0cc4cb3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic assignment operator.  <a href="#aa90da88a721caa2353f32ae0cc4cb3ea">More...</a><br /></td></tr>
<tr class="separator:aa90da88a721caa2353f32ae0cc4cb3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a820356e529595baba2e6702e9173ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a7a820356e529595baba2e6702e9173ec">operator=</a> (const char *str)</td></tr>
<tr class="memdesc:a7a820356e529595baba2e6702e9173ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator from C string.  <a href="#a7a820356e529595baba2e6702e9173ec">More...</a><br /></td></tr>
<tr class="separator:a7a820356e529595baba2e6702e9173ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11008ec6dde47b911d5fed1ed1f47217"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a11008ec6dde47b911d5fed1ed1f47217">operator=</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a11008ec6dde47b911d5fed1ed1f47217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator from C++ string.  <a href="#a11008ec6dde47b911d5fed1ed1f47217">More...</a><br /></td></tr>
<tr class="separator:a11008ec6dde47b911d5fed1ed1f47217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c9fb13d0f92611b07c2750be655035"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7c9fb13d0f92611b07c2750be655035"></a>
const <a class="el" href="classpiranha_1_1mp__rational.html#ac966f004ceb41b9e076abfd1ce286f4f">int_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#ad7c9fb13d0f92611b07c2750be655035">num</a> () const </td></tr>
<tr class="memdesc:ad7c9fb13d0f92611b07c2750be655035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get const reference to the numerator. <br /></td></tr>
<tr class="separator:ad7c9fb13d0f92611b07c2750be655035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a38b21139ca71447d36315a499d40a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13a38b21139ca71447d36315a499d40a"></a>
const <a class="el" href="classpiranha_1_1mp__rational.html#ac966f004ceb41b9e076abfd1ce286f4f">int_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a13a38b21139ca71447d36315a499d40a">den</a> () const </td></tr>
<tr class="memdesc:a13a38b21139ca71447d36315a499d40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get const reference to the denominator. <br /></td></tr>
<tr class="separator:a13a38b21139ca71447d36315a499d40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb9b398c705c8e14d6d169d6b85dcc7"><td class="memItemLeft" align="right" valign="top">mpq_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#adeb9b398c705c8e14d6d169d6b85dcc7">get_mpq_view</a> () const </td></tr>
<tr class="memdesc:adeb9b398c705c8e14d6d169d6b85dcc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an <code>mpq</code> view of <code>this</code>.  <a href="#adeb9b398c705c8e14d6d169d6b85dcc7">More...</a><br /></td></tr>
<tr class="separator:adeb9b398c705c8e14d6d169d6b85dcc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d27aae6bd4a658675d2d1844c4216bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a3d27aae6bd4a658675d2d1844c4216bf">is_canonical</a> () const </td></tr>
<tr class="memdesc:a3d27aae6bd4a658675d2d1844c4216bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicality check.  <a href="#a3d27aae6bd4a658675d2d1844c4216bf">More...</a><br /></td></tr>
<tr class="separator:a3d27aae6bd4a658675d2d1844c4216bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a136cc869baeb52229bbdfb570b127"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#ae5a136cc869baeb52229bbdfb570b127">canonicalise</a> ()</td></tr>
<tr class="memdesc:ae5a136cc869baeb52229bbdfb570b127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalise.  <a href="#ae5a136cc869baeb52229bbdfb570b127">More...</a><br /></td></tr>
<tr class="separator:ae5a136cc869baeb52229bbdfb570b127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6e0c14b12e358819c5400bb765c0a1"><td class="memTemplParams" colspan="2">template&lt;typename T , cast_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:acf6e0c14b12e358819c5400bb765c0a1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#acf6e0c14b12e358819c5400bb765c0a1">operator T</a> () const </td></tr>
<tr class="memdesc:acf6e0c14b12e358819c5400bb765c0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator.  <a href="#acf6e0c14b12e358819c5400bb765c0a1">More...</a><br /></td></tr>
<tr class="separator:acf6e0c14b12e358819c5400bb765c0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e3f7fe0d4e73a7b974d3e9c131f8d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a33e3f7fe0d4e73a7b974d3e9c131f8d6">operator+</a> () const </td></tr>
<tr class="memdesc:a33e3f7fe0d4e73a7b974d3e9c131f8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity operator.  <a href="#a33e3f7fe0d4e73a7b974d3e9c131f8d6">More...</a><br /></td></tr>
<tr class="separator:a33e3f7fe0d4e73a7b974d3e9c131f8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b35f153f54dbc2140e5ed37e0f4db4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#ae1b35f153f54dbc2140e5ed37e0f4db4">operator++</a> ()</td></tr>
<tr class="memdesc:ae1b35f153f54dbc2140e5ed37e0f4db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-increment operator.  <a href="#ae1b35f153f54dbc2140e5ed37e0f4db4">More...</a><br /></td></tr>
<tr class="separator:ae1b35f153f54dbc2140e5ed37e0f4db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9d6e66796154ef63bffa09a17a51e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a1f9d6e66796154ef63bffa09a17a51e1">operator++</a> (int)</td></tr>
<tr class="memdesc:a1f9d6e66796154ef63bffa09a17a51e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post-increment operator.  <a href="#a1f9d6e66796154ef63bffa09a17a51e1">More...</a><br /></td></tr>
<tr class="separator:a1f9d6e66796154ef63bffa09a17a51e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10ec4143cde5610ca14c43f81f6dbc9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae10ec4143cde5610ca14c43f81f6dbc9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#ae10ec4143cde5610ca14c43f81f6dbc9">operator+=</a> (const T &amp;x) -&gt; decltype(this-&gt;in_place_add(x))</td></tr>
<tr class="memdesc:ae10ec4143cde5610ca14c43f81f6dbc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place addition.  <a href="#ae10ec4143cde5610ca14c43f81f6dbc9">More...</a><br /></td></tr>
<tr class="separator:ae10ec4143cde5610ca14c43f81f6dbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0709f086e43595407b1e72889138a05d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0709f086e43595407b1e72889138a05d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a0709f086e43595407b1e72889138a05d">negate</a> ()</td></tr>
<tr class="memdesc:a0709f086e43595407b1e72889138a05d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate in-place. <br /></td></tr>
<tr class="separator:a0709f086e43595407b1e72889138a05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af843cbdbaa0bfcd026dadfd9d1d2b875"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#af843cbdbaa0bfcd026dadfd9d1d2b875">operator-</a> () const </td></tr>
<tr class="memdesc:af843cbdbaa0bfcd026dadfd9d1d2b875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negated copy.  <a href="#af843cbdbaa0bfcd026dadfd9d1d2b875">More...</a><br /></td></tr>
<tr class="separator:af843cbdbaa0bfcd026dadfd9d1d2b875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887ade6275e0493485c0534f9054d016"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a887ade6275e0493485c0534f9054d016">operator--</a> ()</td></tr>
<tr class="memdesc:a887ade6275e0493485c0534f9054d016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-decrement operator.  <a href="#a887ade6275e0493485c0534f9054d016">More...</a><br /></td></tr>
<tr class="separator:a887ade6275e0493485c0534f9054d016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1b249f67603748963807dfcfdf3386"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a1f1b249f67603748963807dfcfdf3386">operator--</a> (int)</td></tr>
<tr class="memdesc:a1f1b249f67603748963807dfcfdf3386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post-decrement operator.  <a href="#a1f1b249f67603748963807dfcfdf3386">More...</a><br /></td></tr>
<tr class="separator:a1f1b249f67603748963807dfcfdf3386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cf3bdd28b204226061e9cade27e8b1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a70cf3bdd28b204226061e9cade27e8b1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a70cf3bdd28b204226061e9cade27e8b1">operator-=</a> (const T &amp;x) -&gt; decltype(this-&gt;in_place_sub(x))</td></tr>
<tr class="memdesc:a70cf3bdd28b204226061e9cade27e8b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place subtraction.  <a href="#a70cf3bdd28b204226061e9cade27e8b1">More...</a><br /></td></tr>
<tr class="separator:a70cf3bdd28b204226061e9cade27e8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbff0ab2df7988e2f6e6af1f2e4fad73"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acbff0ab2df7988e2f6e6af1f2e4fad73"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#acbff0ab2df7988e2f6e6af1f2e4fad73">operator*=</a> (const T &amp;x) -&gt; decltype(this-&gt;in_place_mult(x))</td></tr>
<tr class="memdesc:acbff0ab2df7988e2f6e6af1f2e4fad73"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place multiplication.  <a href="#acbff0ab2df7988e2f6e6af1f2e4fad73">More...</a><br /></td></tr>
<tr class="separator:acbff0ab2df7988e2f6e6af1f2e4fad73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0fc3d89749b700dd4cf2e3669fd5bf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:add0fc3d89749b700dd4cf2e3669fd5bf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#add0fc3d89749b700dd4cf2e3669fd5bf">operator/=</a> (const T &amp;x) -&gt; decltype(this-&gt;in_place_div(x))</td></tr>
<tr class="memdesc:add0fc3d89749b700dd4cf2e3669fd5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place division.  <a href="#add0fc3d89749b700dd4cf2e3669fd5bf">More...</a><br /></td></tr>
<tr class="separator:add0fc3d89749b700dd4cf2e3669fd5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75718089777ed438e52ab6bd295191c"><td class="memTemplParams" colspan="2">template&lt;typename T , pow_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:aa75718089777ed438e52ab6bd295191c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#aa75718089777ed438e52ab6bd295191c">pow</a> (const T &amp;exp) const </td></tr>
<tr class="memdesc:aa75718089777ed438e52ab6bd295191c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponentiation.  <a href="#aa75718089777ed438e52ab6bd295191c">More...</a><br /></td></tr>
<tr class="separator:aa75718089777ed438e52ab6bd295191c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdc43620594df3d255a5730267bb391"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a6fdc43620594df3d255a5730267bb391">abs</a> () const </td></tr>
<tr class="memdesc:a6fdc43620594df3d255a5730267bb391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute value.  <a href="#a6fdc43620594df3d255a5730267bb391">More...</a><br /></td></tr>
<tr class="separator:a6fdc43620594df3d255a5730267bb391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e388aee0040a9874c95e2992dd00d3"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a68e388aee0040a9874c95e2992dd00d3">hash</a> () const </td></tr>
<tr class="memdesc:a68e388aee0040a9874c95e2992dd00d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash value.  <a href="#a68e388aee0040a9874c95e2992dd00d3">More...</a><br /></td></tr>
<tr class="separator:a68e388aee0040a9874c95e2992dd00d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5281e8bddf5e1fcf501b09d8f717df3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; std::is_integral&lt; T &gt;::value||std::is_same&lt; T, int_type &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ae5281e8bddf5e1fcf501b09d8f717df3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#ae5281e8bddf5e1fcf501b09d8f717df3">binomial</a> (const T &amp;n) const </td></tr>
<tr class="memdesc:ae5281e8bddf5e1fcf501b09d8f717df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binomial coefficient.  <a href="#ae5281e8bddf5e1fcf501b09d8f717df3">More...</a><br /></td></tr>
<tr class="separator:ae5281e8bddf5e1fcf501b09d8f717df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Low-level interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Low-level methods. These methods allow direct mutable access to numerator and denominator, and they will not keep the rational in canonical form. </p>
</div></td></tr>
<tr class="memitem:a617ce9d7aa7fcec2b365f7ec32c964e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1mp__rational.html#ac966f004ceb41b9e076abfd1ce286f4f">int_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a617ce9d7aa7fcec2b365f7ec32c964e5">_num</a> ()</td></tr>
<tr class="memdesc:a617ce9d7aa7fcec2b365f7ec32c964e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable reference to the numerator.  <a href="#a617ce9d7aa7fcec2b365f7ec32c964e5">More...</a><br /></td></tr>
<tr class="separator:a617ce9d7aa7fcec2b365f7ec32c964e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf79eaf4d77d5efb15d49e321225a93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a1cf79eaf4d77d5efb15d49e321225a93">_set_den</a> (const <a class="el" href="classpiranha_1_1mp__rational.html#ac966f004ceb41b9e076abfd1ce286f4f">int_type</a> &amp;<a class="el" href="classpiranha_1_1mp__rational.html#a13a38b21139ca71447d36315a499d40a">den</a>)</td></tr>
<tr class="memdesc:a1cf79eaf4d77d5efb15d49e321225a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set denominator.  <a href="#a1cf79eaf4d77d5efb15d49e321225a93">More...</a><br /></td></tr>
<tr class="separator:a1cf79eaf4d77d5efb15d49e321225a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af2f1514ddde92c6f882970d538eb3332"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#af2f1514ddde92c6f882970d538eb3332">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> &amp;q)</td></tr>
<tr class="memdesc:af2f1514ddde92c6f882970d538eb3332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator.  <a href="#af2f1514ddde92c6f882970d538eb3332">More...</a><br /></td></tr>
<tr class="separator:af2f1514ddde92c6f882970d538eb3332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c1e907d2dc15363d50a0397da04cf2"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#ab8c1e907d2dc15363d50a0397da04cf2">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> &amp;q)</td></tr>
<tr class="memdesc:ab8c1e907d2dc15363d50a0397da04cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload input stream operator for <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="#ab8c1e907d2dc15363d50a0397da04cf2">More...</a><br /></td></tr>
<tr class="separator:ab8c1e907d2dc15363d50a0397da04cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c078993d5d707e76222eb392f34354c"><td class="memTemplParams" colspan="2">template&lt;typename T , generic_in_place_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9c078993d5d707e76222eb392f34354c"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a9c078993d5d707e76222eb392f34354c">operator+=</a> (T &amp;x, const <a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> &amp;q)</td></tr>
<tr class="memdesc:a9c078993d5d707e76222eb392f34354c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic in-place addition with <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="#a9c078993d5d707e76222eb392f34354c">More...</a><br /></td></tr>
<tr class="separator:a9c078993d5d707e76222eb392f34354c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add54a859d046d99ef445553ef5cb6d41"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:add54a859d046d99ef445553ef5cb6d41"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#add54a859d046d99ef445553ef5cb6d41">operator+</a> (const T &amp;x, const U &amp;y) -&gt; decltype(mp_rational::binary_plus(x, y))</td></tr>
<tr class="memdesc:add54a859d046d99ef445553ef5cb6d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic binary addition involving <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="#add54a859d046d99ef445553ef5cb6d41">More...</a><br /></td></tr>
<tr class="separator:add54a859d046d99ef445553ef5cb6d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abccc0123fbaf054b9927192f7963c233"><td class="memTemplParams" colspan="2">template&lt;typename T , generic_in_place_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:abccc0123fbaf054b9927192f7963c233"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#abccc0123fbaf054b9927192f7963c233">operator-=</a> (T &amp;x, const <a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> &amp;q)</td></tr>
<tr class="memdesc:abccc0123fbaf054b9927192f7963c233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic in-place subtraction with <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="#abccc0123fbaf054b9927192f7963c233">More...</a><br /></td></tr>
<tr class="separator:abccc0123fbaf054b9927192f7963c233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0ca12ffd41f310703e00cf70ed71d9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ade0ca12ffd41f310703e00cf70ed71d9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#ade0ca12ffd41f310703e00cf70ed71d9">operator-</a> (const T &amp;x, const U &amp;y) -&gt; decltype(mp_rational::binary_minus(x, y))</td></tr>
<tr class="memdesc:ade0ca12ffd41f310703e00cf70ed71d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic binary subtraction involving <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="#ade0ca12ffd41f310703e00cf70ed71d9">More...</a><br /></td></tr>
<tr class="separator:ade0ca12ffd41f310703e00cf70ed71d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424a26d3b00a19ead2a5c6a6ac5c962e"><td class="memTemplParams" colspan="2">template&lt;typename T , generic_in_place_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a424a26d3b00a19ead2a5c6a6ac5c962e"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a424a26d3b00a19ead2a5c6a6ac5c962e">operator*=</a> (T &amp;x, const <a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> &amp;q)</td></tr>
<tr class="memdesc:a424a26d3b00a19ead2a5c6a6ac5c962e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic in-place multiplication with <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="#a424a26d3b00a19ead2a5c6a6ac5c962e">More...</a><br /></td></tr>
<tr class="separator:a424a26d3b00a19ead2a5c6a6ac5c962e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34f705c9c209e4051f2ca3b007a1f26"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aa34f705c9c209e4051f2ca3b007a1f26"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#aa34f705c9c209e4051f2ca3b007a1f26">operator*</a> (const T &amp;x, const U &amp;y) -&gt; decltype(mp_rational::binary_mult(x, y))</td></tr>
<tr class="memdesc:aa34f705c9c209e4051f2ca3b007a1f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic binary multiplication involving <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="#aa34f705c9c209e4051f2ca3b007a1f26">More...</a><br /></td></tr>
<tr class="separator:aa34f705c9c209e4051f2ca3b007a1f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b73e8b6d4869af8331c00bc34a7aaae"><td class="memTemplParams" colspan="2">template&lt;typename T , generic_in_place_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a4b73e8b6d4869af8331c00bc34a7aaae"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a4b73e8b6d4869af8331c00bc34a7aaae">operator/=</a> (T &amp;x, const <a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> &amp;q)</td></tr>
<tr class="memdesc:a4b73e8b6d4869af8331c00bc34a7aaae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic in-place division with <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="#a4b73e8b6d4869af8331c00bc34a7aaae">More...</a><br /></td></tr>
<tr class="separator:a4b73e8b6d4869af8331c00bc34a7aaae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b5c6a9bea2a29a12d4b6bff0b87f6b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a03b5c6a9bea2a29a12d4b6bff0b87f6b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a03b5c6a9bea2a29a12d4b6bff0b87f6b">operator/</a> (const T &amp;x, const U &amp;y) -&gt; decltype(mp_rational::binary_div(x, y))</td></tr>
<tr class="memdesc:a03b5c6a9bea2a29a12d4b6bff0b87f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic binary division involving <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="#a03b5c6a9bea2a29a12d4b6bff0b87f6b">More...</a><br /></td></tr>
<tr class="separator:a03b5c6a9bea2a29a12d4b6bff0b87f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aafbb7f567424b66e2e6914d190f6d0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a5aafbb7f567424b66e2e6914d190f6d0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a5aafbb7f567424b66e2e6914d190f6d0">operator==</a> (const T &amp;x, const U &amp;y) -&gt; decltype(mp_rational::binary_eq(x, y))</td></tr>
<tr class="memdesc:a5aafbb7f567424b66e2e6914d190f6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic equality operator involving <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="#a5aafbb7f567424b66e2e6914d190f6d0">More...</a><br /></td></tr>
<tr class="separator:a5aafbb7f567424b66e2e6914d190f6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab93a2c81b3e993664bd22e768699544"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aab93a2c81b3e993664bd22e768699544"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#aab93a2c81b3e993664bd22e768699544">operator!=</a> (const T &amp;x, const U &amp;y) -&gt; decltype(!mp_rational::binary_eq(x, y))</td></tr>
<tr class="memdesc:aab93a2c81b3e993664bd22e768699544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic inequality operator involving <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="#aab93a2c81b3e993664bd22e768699544">More...</a><br /></td></tr>
<tr class="separator:aab93a2c81b3e993664bd22e768699544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add81562f70f84f0dcd4718ad546b3665"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:add81562f70f84f0dcd4718ad546b3665"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#add81562f70f84f0dcd4718ad546b3665">operator&lt;</a> (const T &amp;x, const U &amp;y) -&gt; decltype(mp_rational::binary_less_than(x, y))</td></tr>
<tr class="memdesc:add81562f70f84f0dcd4718ad546b3665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic less-than operator involving <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="#add81562f70f84f0dcd4718ad546b3665">More...</a><br /></td></tr>
<tr class="separator:add81562f70f84f0dcd4718ad546b3665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc0474b463771aa1a3b5bd87b85bbbc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a0fc0474b463771aa1a3b5bd87b85bbbc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a0fc0474b463771aa1a3b5bd87b85bbbc">operator&gt;=</a> (const T &amp;x, const U &amp;y) -&gt; decltype(!mp_rational::binary_less_than(x, y))</td></tr>
<tr class="memdesc:a0fc0474b463771aa1a3b5bd87b85bbbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic greater-than or equal operator involving <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="#a0fc0474b463771aa1a3b5bd87b85bbbc">More...</a><br /></td></tr>
<tr class="separator:a0fc0474b463771aa1a3b5bd87b85bbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a47f6274ccede33de7f36be275b02f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ae4a47f6274ccede33de7f36be275b02f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#ae4a47f6274ccede33de7f36be275b02f">operator&gt;</a> (const T &amp;x, const U &amp;y) -&gt; decltype(mp_rational::binary_greater_than(x, y))</td></tr>
<tr class="memdesc:ae4a47f6274ccede33de7f36be275b02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic greater-than operator involving <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="#ae4a47f6274ccede33de7f36be275b02f">More...</a><br /></td></tr>
<tr class="separator:ae4a47f6274ccede33de7f36be275b02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2a2f751640a8b70f1e9e52453c6482"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a9e2a2f751640a8b70f1e9e52453c6482"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1mp__rational.html#a9e2a2f751640a8b70f1e9e52453c6482">operator&lt;=</a> (const T &amp;x, const U &amp;y) -&gt; decltype(!mp_rational::binary_greater_than(x, y))</td></tr>
<tr class="memdesc:a9e2a2f751640a8b70f1e9e52453c6482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic less-than or equal operator involving <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.  <a href="#a9e2a2f751640a8b70f1e9e52453c6482">More...</a><br /></td></tr>
<tr class="separator:a9e2a2f751640a8b70f1e9e52453c6482"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int NBits = 0&gt;<br />
class piranha::mp_rational&lt; NBits &gt;</h3>

<p>Multiple precision rational class. </p>
<p>This class encapsulates two instances of <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a> to represent an arbitrary-precision rational number in terms of a numerator and a denominator. The meaning of the <code>NBits</code> template parameter is the same as in <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>, that is, it represents the bit width of the two limbs stored statically in the numerator and in the denominator.</p>
<p>Unless otherwise specified, rational numbers are always kept in the usual canonical form in which numerator and denominator are coprime, and the denominator is always positive. Zero is uniquely represented by 0/1.</p>
<h2>Interoperability with other types</h2>
<p>This class interoperates with the same types as <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>, plus <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a> itself. The same caveats with respect to interoperability with floating-point types mentioned in the documentation of <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a> apply.</p>
<h2>Exception safety guarantee</h2>
<p>This class provides the strong exception safety guarantee for all operations. In case of memory allocation errors by GMP routines, the program will terminate.</p>
<h2>Move semantics</h2>
<p>Move construction and move assignment will leave the moved-from object in an unspecified but valid state.</p>
<h2>Serialization</h2>
<p>This class supports serialization.</p>
<dl class="section author"><dt>Author</dt><dd>Francesco Biscani (<a href="#" onclick="location.href='mai'+'lto:'+'blu'+'es'+'car'+'ni'+'@gm'+'ai'+'l.c'+'om'; return false;">blues<span style="display: none;">.nosp@m.</span>carn<span style="display: none;">.nosp@m.</span>i@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a>) </dd></dl>

<p>Definition at line <a class="el" href="mp__rational__fwd_8hpp_source.html#l00029">29</a> of file <a class="el" href="mp__rational__fwd_8hpp_source.html">mp_rational_fwd.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab6e9a682b16c0f1e7150f31d8ec87c8c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::<a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>This constructor will initialise the rational to zero (that is, the numerator is set to zero, the denominator to 1). </p>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l00667">667</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f248dee9ef50aa22ec830315addea6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<div class="memtemplate">
template&lt;typename I0 , typename I1 , nd_ctor_enabler&lt; I0, I1 &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::<a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> </td>
          <td>(</td>
          <td class="paramtype">const I0 &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const I1 &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from numerator/denominator pair. </p>
<dl class="section note"><dt>Note</dt><dd>This constructor is enabled only if <code>I0</code> and <code>I1</code> are either integral types or <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b" title="Alias for piranha::mp_integer with default bit size. ">piranha::integer</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>numerator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>denominator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structpiranha_1_1zero__division__error.html" title="Exception for signalling division by zero. ">piranha::zero_division_error</a></td><td>if the denominator is zero. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the invoked constructor of <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l00690">690</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad0e34b5bb5edcc34a545a7bb2b9e5e71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<div class="memtemplate">
template&lt;typename T , generic_ctor_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::<a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic constructor. </p>
<dl class="section note"><dt>Note</dt><dd>This constructor is enabled only if <code>T</code> is an interoperable type.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>object used to construct <code>this</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the construction fails (e.g., construction from a non-finite floating-point value). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l00708">708</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9f3ff6d094cc7ab86184529ee7cd9a15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::<a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from C string. </p>
<p>The string must represent either a valid single <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>, or two valid <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a> separated by "/". The rational will be put in canonical form by this constructor.</p>
<p>Note that if the string is not null-terminated, undefined behaviour will occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>C string used for construction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the string is not formatted correctly. </td></tr>
    <tr><td class="paramname"><a class="el" href="structpiranha_1_1zero__division__error.html" title="Exception for signalling division by zero. ">piranha::zero_division_error</a></td><td>if the denominator, if present, is zero. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the constructor from string of <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a> or by memory errors in <code>std::string</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l00726">726</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a524940ea89563f0d41c999d3bdfcf68f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::<a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from C++ string. </p>
<p>Equivalent to the constructor from C string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>C string used for construction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the constructor from C string. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l00761">761</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a617ce9d7aa7fcec2b365f7ec32c964e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1mp__rational.html#ac966f004ceb41b9e076abfd1ce286f4f">int_type</a>&amp; <a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::_num </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutable reference to the numerator. </p>
<dl class="section return"><dt>Returns</dt><dd>mutable reference to the numerator. </dd></dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l00975">975</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1cf79eaf4d77d5efb15d49e321225a93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::_set_den </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1mp__rational.html#ac966f004ceb41b9e076abfd1ce286f4f">int_type</a> &amp;&#160;</td>
          <td class="paramname"><em>den</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set denominator. </p>
<p>This method will set the denominator to <code>den</code> without canonicalising the rational.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">den</td><td>desired value for the denominator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>den</code> is not positive. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l00987">987</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6fdc43620594df3d255a5730267bb391"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> <a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::abs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Absolute value. </p>
<dl class="section return"><dt>Returns</dt><dd>absolute value of <code>this</code>. </dd></dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01550">1550</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae5281e8bddf5e1fcf501b09d8f717df3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; std::is_integral&lt; T &gt;::value||std::is_same&lt; T, int_type &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> <a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::binomial </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binomial coefficient. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <code>T</code> is an integral type or <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>.</dd></dl>
<p>Will return <code>this</code> choose <code>n</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>bottom argument for the binomial coefficient.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>this</code> choose <code>n</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classpiranha_1_1mp__integer.html#aaf4cdd3d27c1fc2231d603481ed1353b" title="Binomial coefficient. ">piranha::mp_integer::binomial()</a> or by arithmetic operations on <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01586">1586</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae5a136cc869baeb52229bbdfb570b127"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::canonicalise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Canonicalise. </p>
<p>This method will convert <code>this</code> to the canonical form, if needed.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpiranha_1_1mp__rational.html#a3d27aae6bd4a658675d2d1844c4216bf" title="Canonicality check. ">piranha::mp_rational::is_canonical()</a>. </dd></dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l00927">927</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adeb9b398c705c8e14d6d169d6b85dcc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpq_view <a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::get_mpq_view </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an <code>mpq</code> view of <code>this</code>. </p>
<p>This method will return an object of an unspecified type <code>mpq_view</code> which is implicitly convertible to a const pointer to an <code>mpq</code> struct (and which can thus be used as a <code>const mpq_t</code> parameter in GMP functions). In addition to the implicit conversion operator, the <code>mpq</code> struct pointer can also be retrieved via the <code>get()</code> method of the <code>mpq_view</code> class. The pointee will represent a GMP rational whose value is equal to <code>this</code>.</p>
<p>Note that the returned <code>mpq_view</code> instance can only be move-constructed (the other constructors and the assignment operators are disabled). Additionally, the returned object and the pointer might reference internal data belonging to <code>this</code>, and they can thus be used safely only during the lifetime of <code>this</code>. Any modification to <code>this</code> will also invalidate the view and the pointer.</p>
<dl class="section return"><dt>Returns</dt><dd>an <code>mpq</code> view of <code>this</code>. </dd></dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l00897">897</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a68e388aee0040a9874c95e2992dd00d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::hash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hash value. </p>
<p>The hash value is calculated by combining the hash values of numerator and denominator.</p>
<dl class="section return"><dt>Returns</dt><dd>a hash value for this. </dd></dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01564">1564</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d27aae6bd4a658675d2d1844c4216bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::is_canonical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Canonicality check. </p>
<p>A rational number is in canonical form when numerator and denominator are coprime. A zero numerator must be paired to a 1 denominator.</p>
<p>If low-level methods are not used, this function will always return <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>this</code> is in canonical form, <code>false</code> otherwise. </dd></dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l00910">910</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf6e0c14b12e358819c5400bb765c0a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<div class="memtemplate">
template&lt;typename T , cast_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::operator T </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator. </p>
<dl class="section note"><dt>Note</dt><dd>This operator is enabled only if <code>T</code> is an interoperable type.</dd></dl>
<p>The conversion to <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a> is computed by dividing the numerator by the denominator. The conversion to integral types is computed by casting first to <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>, then to the target integral type. The conversion to floating-point types might generate non-finite values.</p>
<dl class="section return"><dt>Returns</dt><dd>the value of <code>this</code> converted to type <code>T</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>if the conversion fails (e.g., the range of the target integral type is insufficient to represent the value of <code>this</code>). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l00962">962</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acbff0ab2df7988e2f6e6af1f2e4fad73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(this-&gt;in_place_mult(x))
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place multiplication. </p>
<dl class="section note"><dt>Note</dt><dd>This operator is enabled only if <code>T</code> is an interoperable type or <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.</dd></dl>
<p>If <code>T</code> is not a float, the exact result will be computed. If <code>T</code> is a floating-point type, the following sequence of operations takes place:</p>
<ul>
<li><code>this</code> is converted to an instance <code>f</code> of type <code>T</code> via the conversion operator,</li>
<li><code>f</code> is multiplied by <code>x</code>,</li>
<li>the result is assigned back to <code>this</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>argument for the multiplication.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the conversion operator, the generic constructor of <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>, or the generic assignment operator, if used. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01222">1222</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a33e3f7fe0d4e73a7b974d3e9c131f8d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> <a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::operator+ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identity operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a copy of <code>this</code>. </dd></dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l00999">999</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae1b35f153f54dbc2140e5ed37e0f4db4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a>&amp; <a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pre-increment operator. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>this</code> after the increment.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by in-place addition. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01009">1009</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f9d6e66796154ef63bffa09a17a51e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> <a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Post-increment operator. </p>
<dl class="section return"><dt>Returns</dt><dd>copy of <code>this</code> before the increment.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the pre-increment operator. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01019">1019</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae10ec4143cde5610ca14c43f81f6dbc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(this-&gt;in_place_add(x))
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place addition. </p>
<dl class="section note"><dt>Note</dt><dd>This operator is enabled only if <code>T</code> is an interoperable type or <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.</dd></dl>
<p>If <code>T</code> is not a float, the exact result will be computed. If <code>T</code> is a floating-point type, the following sequence of operations takes place:</p>
<ul>
<li><code>this</code> is converted to an instance <code>f</code> of type <code>T</code> via the conversion operator,</li>
<li><code>f</code> is added to <code>x</code>,</li>
<li>the result is assigned back to <code>this</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>argument for the addition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the conversion operator, the generic constructor of <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>, or the generic assignment operator, if used. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01045">1045</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af843cbdbaa0bfcd026dadfd9d1d2b875"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> <a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negated copy. </p>
<dl class="section return"><dt>Returns</dt><dd>a negated copy of <code>this</code>. </dd></dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01104">1104</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a887ade6275e0493485c0534f9054d016"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a>&amp; <a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pre-decrement operator. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>this</code> after the decrement.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by in-place subtraction. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01116">1116</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f1b249f67603748963807dfcfdf3386"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> <a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Post-decrement operator. </p>
<dl class="section return"><dt>Returns</dt><dd>copy of <code>this</code> before the decrement.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the pre-decrement operator. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01126">1126</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a70cf3bdd28b204226061e9cade27e8b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(this-&gt;in_place_sub(x))
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place subtraction. </p>
<dl class="section note"><dt>Note</dt><dd>This operator is enabled only if <code>T</code> is an interoperable type or <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.</dd></dl>
<p>If <code>T</code> is not a float, the exact result will be computed. If <code>T</code> is a floating-point type, the following sequence of operations takes place:</p>
<ul>
<li><code>this</code> is converted to an instance <code>f</code> of type <code>T</code> via the conversion operator,</li>
<li><code>x</code> is subtracted from <code>f</code>,</li>
<li>the result is assigned back to <code>this</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>argument for the subtraction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the conversion operator, the generic constructor of <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>, or the generic assignment operator, if used. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01152">1152</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="add0fc3d89749b700dd4cf2e3669fd5bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(this-&gt;in_place_div(x))
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place division. </p>
<dl class="section note"><dt>Note</dt><dd>This operator is enabled only if <code>T</code> is an interoperable type or <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.</dd></dl>
<p>If <code>T</code> is not a float, the exact result will be computed. If <code>T</code> is a floating-point type, the following sequence of operations takes place:</p>
<ul>
<li><code>this</code> is converted to an instance <code>f</code> of type <code>T</code> via the conversion operator,</li>
<li><code>f</code> is divided by <code>x</code>,</li>
<li>the result is assigned back to <code>this</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>argument for the division.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structpiranha_1_1zero__division__error.html" title="Exception for signalling division by zero. ">piranha::zero_division_error</a></td><td>if <code>x</code> is zero. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the conversion operator, the generic constructor of <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>, or the generic assignment operator, if used. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01293">1293</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa90da88a721caa2353f32ae0cc4cb3ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<div class="memtemplate">
template&lt;typename T , generic_ctor_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a>&amp; <a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic assignment operator. </p>
<dl class="section note"><dt>Note</dt><dd>This assignment operator is enabled only if <code>T</code> is an interoperable type.</dd></dl>
<p>This operator will construct a temporary <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> from <code>x</code> and will then move-assign it to <code>this</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>assignment target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the generic constructor from interoperable type. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l00798">798</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7a820356e529595baba2e6702e9173ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a>&amp; <a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator from C string. </p>
<p>This assignment operator will construct a <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> from the string <code>str</code> and will then move-assign the result to <code>this</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>C string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the constructor from string. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l00813">813</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a11008ec6dde47b911d5fed1ed1f47217"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a>&amp; <a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator from C++ string. </p>
<p>This assignment operator will construct a <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> from the string <code>str</code> and will then move-assign the result to <code>this</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>C++ string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the constructor from string. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l00828">828</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa75718089777ed438e52ab6bd295191c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<div class="memtemplate">
template&lt;typename T , pow_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a> <a class="el" href="classpiranha_1_1mp__rational.html">piranha::mp_rational</a>&lt; NBits &gt;::pow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>exp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exponentiation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <a class="el" href="classpiranha_1_1mp__integer.html#ae22512fea24b12635223983cf0e21ca3" title="Exponentiation. ">piranha::mp_integer::pow()</a> can be called with an argument of type <code>T</code>.</dd></dl>
<p>This method computes <code>this</code> raised to the integral power <code>exp</code>. Internally, the <a class="el" href="classpiranha_1_1mp__integer.html#ae22512fea24b12635223983cf0e21ca3" title="Exponentiation. ">piranha::mp_integer::pow()</a> method of numerator and denominator is used. Negative powers will raise an error if the numerator of <code>this</code> is zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">exp</td><td>exponent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>this ** exp</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structpiranha_1_1zero__division__error.html" title="Exception for signalling division by zero. ">piranha::zero_division_error</a></td><td>if <code>exp</code> is negative and the numerator of <code>this</code> is zero. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classpiranha_1_1mp__integer.html#ae22512fea24b12635223983cf0e21ca3" title="Exponentiation. ">piranha::mp_integer::pow()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01520">1520</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="aab93a2c81b3e993664bd22e768699544"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(!mp_rational::binary_eq(x,y))
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic inequality operator involving <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This template operator is enabled only if either:<ul>
<li><code>T</code> is <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> and <code>U</code> is an interoperable type,</li>
<li><code>U</code> is <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> and <code>T</code> is an interoperable type,</li>
<li>both <code>T</code> and <code>U</code> are <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.</li>
</ul>
</dd></dl>
<p>If no floating-point types are involved, the exact result of the comparison will be returned.</p>
<p>If one of the arguments is a floating-point value <code>f</code> of type <code>F</code>, the other argument will be converted to an instance of type <code>F</code> and compared to <code>f</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>x != y</code>, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the equality operator. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01395">1395</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa34f705c9c209e4051f2ca3b007a1f26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(mp_rational::binary_mult(x,y))
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic binary multiplication involving <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This template operator is enabled only if either:<ul>
<li><code>T</code> is <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> and <code>U</code> is an interoperable type,</li>
<li><code>U</code> is <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> and <code>T</code> is an interoperable type,</li>
<li>both <code>T</code> and <code>U</code> are <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.</li>
</ul>
</dd></dl>
<p>If no floating-point types are involved, the exact result of the operation will be returned as a <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.</p>
<p>If one of the arguments is a floating-point value <code>f</code> of type <code>F</code>, the other argument will be converted to an instance of type <code>F</code> and multiplied by <code>f</code> to generate the return value, which will then be of type <code>F</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x * y</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the corresponding in-place operator,</li>
<li>the invoked constructor or the conversion operator, if used. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01268">1268</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a424a26d3b00a19ead2a5c6a6ac5c962e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<div class="memtemplate">
template&lt;typename T , generic_in_place_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a>&lt; NBits &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic in-place multiplication with <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This operator is enabled only if <code>T</code> is a non-const interoperable type.</dd></dl>
<p>Multiply by a <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> in-place. This method will first compute <code>x * q</code>, cast it back to <code>T</code> via <code>static_cast</code> and finally assign the result to <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>first argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the binary operator or by casting <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> to <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01241">1241</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="add54a859d046d99ef445553ef5cb6d41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(mp_rational::binary_plus(x,y))
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic binary addition involving <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This template operator is enabled only if either:<ul>
<li><code>T</code> is <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> and <code>U</code> is an interoperable type,</li>
<li><code>U</code> is <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> and <code>T</code> is an interoperable type,</li>
<li>both <code>T</code> and <code>U</code> are <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.</li>
</ul>
</dd></dl>
<p>If no floating-point types are involved, the exact result of the operation will be returned as a <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.</p>
<p>If one of the arguments is a floating-point value <code>f</code> of type <code>F</code>, the other argument will be converted to an instance of type <code>F</code> and added to <code>f</code> to generate the return value, which will then be of type <code>F</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x + y</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the corresponding in-place operator,</li>
<li>the invoked constructor or the conversion operator, if used. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01091">1091</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c078993d5d707e76222eb392f34354c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<div class="memtemplate">
template&lt;typename T , generic_in_place_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a>&lt; NBits &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic in-place addition with <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This operator is enabled only if <code>T</code> is a non-const interoperable type.</dd></dl>
<p>Add a <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> in-place. This method will first compute <code>q + x</code>, cast it back to <code>T</code> via <code>static_cast</code> and finally assign the result to <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>first argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the binary operator or by casting <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> to <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01064">1064</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ade0ca12ffd41f310703e00cf70ed71d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(mp_rational::binary_minus(x,y))
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic binary subtraction involving <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This template operator is enabled only if either:<ul>
<li><code>T</code> is <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> and <code>U</code> is an interoperable type,</li>
<li><code>U</code> is <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> and <code>T</code> is an interoperable type,</li>
<li>both <code>T</code> and <code>U</code> are <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.</li>
</ul>
</dd></dl>
<p>If no floating-point types are involved, the exact result of the operation will be returned as a <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.</p>
<p>If one of the arguments is a floating-point value <code>f</code> of type <code>F</code>, the other argument will be converted to an instance of type <code>F</code> and subtracted from (or to) <code>f</code> to generate the return value, which will then be of type <code>F</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x - y</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the corresponding in-place operator,</li>
<li>the invoked constructor or the conversion operator, if used. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01198">1198</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abccc0123fbaf054b9927192f7963c233"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<div class="memtemplate">
template&lt;typename T , generic_in_place_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a>&lt; NBits &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic in-place subtraction with <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This operator is enabled only if <code>T</code> is a non-const interoperable type.</dd></dl>
<p>Subtract a <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> in-place. This method will first compute <code>x - q</code>, cast it back to <code>T</code> via <code>static_cast</code> and finally assign the result to <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>first argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the binary operator or by casting <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> to <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01171">1171</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a03b5c6a9bea2a29a12d4b6bff0b87f6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(mp_rational::binary_div(x,y))
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic binary division involving <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This template operator is enabled only if either:<ul>
<li><code>T</code> is <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> and <code>U</code> is an interoperable type,</li>
<li><code>U</code> is <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> and <code>T</code> is an interoperable type,</li>
<li>both <code>T</code> and <code>U</code> are <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.</li>
</ul>
</dd></dl>
<p>If no floating-point types are involved, the exact result of the operation will be returned as a <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.</p>
<p>If one of the arguments is a floating-point value <code>f</code> of type <code>F</code>, the other argument will be converted to an instance of type <code>F</code> and divided by <code>f</code> (or viceversa) to generate the return value, which will then be of type <code>F</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x / y</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structpiranha_1_1zero__division__error.html" title="Exception for signalling division by zero. ">piranha::zero_division_error</a></td><td>in case of division by zero. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the corresponding in-place operator,</li>
<li>the invoked constructor or the conversion operator, if used. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01343">1343</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4b73e8b6d4869af8331c00bc34a7aaae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<div class="memtemplate">
template&lt;typename T , generic_in_place_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a>&lt; NBits &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic in-place division with <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This operator is enabled only if <code>T</code> is a non-const interoperable type.</dd></dl>
<p>Divide by a <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> in-place. This method will first compute <code>x / q</code>, cast it back to <code>T</code> via <code>static_cast</code> and finally assign the result to <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>first argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the binary operator or by casting <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> to <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01315">1315</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="add81562f70f84f0dcd4718ad546b3665"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(mp_rational::binary_less_than(x,y))
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic less-than operator involving <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This template operator is enabled only if either:<ul>
<li><code>T</code> is <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> and <code>U</code> is an interoperable type,</li>
<li><code>U</code> is <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> and <code>T</code> is an interoperable type,</li>
<li>both <code>T</code> and <code>U</code> are <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.</li>
</ul>
</dd></dl>
<p>If no floating-point types are involved, the exact result of the comparison will be returned.</p>
<p>If one of the arguments is a floating-point value <code>f</code> of type <code>F</code>, the other argument will be converted to an instance of type <code>F</code> and compared to <code>f</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>x &lt; y</code>, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the less-than operator of <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>,</li>
<li>the invoked conversion operator, if used. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01422">1422</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af2f1514ddde92c6f882970d538eb3332"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a>&lt; NBits &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stream operator. </p>
<p>The printing format is as follows:</p><ul>
<li>only the numerator is printed if the denominator is 1,</li>
<li>otherwise, numerator and denominator are printed separated by a '/' sign.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">os</td><td>target stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>rational to be printed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>os</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the streaming operator of <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l00845">845</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9e2a2f751640a8b70f1e9e52453c6482"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(!mp_rational::binary_greater_than(x,y))
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic less-than or equal operator involving <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This template operator is enabled only if either:<ul>
<li><code>T</code> is <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> and <code>U</code> is an interoperable type,</li>
<li><code>U</code> is <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> and <code>T</code> is an interoperable type,</li>
<li>both <code>T</code> and <code>U</code> are <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.</li>
</ul>
</dd></dl>
<p>If no floating-point types are involved, the exact result of the comparison will be returned.</p>
<p>If one of the arguments is a floating-point value <code>f</code> of type <code>F</code>, the other argument will be converted to an instance of type <code>F</code> and compared to <code>f</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>x &lt;= y</code>, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the greater-than operator. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01499">1499</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5aafbb7f567424b66e2e6914d190f6d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(mp_rational::binary_eq(x,y))
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic equality operator involving <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This template operator is enabled only if either:<ul>
<li><code>T</code> is <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> and <code>U</code> is an interoperable type,</li>
<li><code>U</code> is <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> and <code>T</code> is an interoperable type,</li>
<li>both <code>T</code> and <code>U</code> are <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.</li>
</ul>
</dd></dl>
<p>If no floating-point types are involved, the exact result of the comparison will be returned.</p>
<p>If one of the arguments is a floating-point value <code>f</code> of type <code>F</code>, the other argument will be converted to an instance of type <code>F</code> and compared to <code>f</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>x == y</code>, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the comparison operator of <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>,</li>
<li>the invoked conversion operator, if used. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01370">1370</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae4a47f6274ccede33de7f36be275b02f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(mp_rational::binary_greater_than(x,y))
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic greater-than operator involving <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This template operator is enabled only if either:<ul>
<li><code>T</code> is <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> and <code>U</code> is an interoperable type,</li>
<li><code>U</code> is <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> and <code>T</code> is an interoperable type,</li>
<li>both <code>T</code> and <code>U</code> are <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.</li>
</ul>
</dd></dl>
<p>If no floating-point types are involved, the exact result of the comparison will be returned.</p>
<p>If one of the arguments is a floating-point value <code>f</code> of type <code>F</code>, the other argument will be converted to an instance of type <code>F</code> and compared to <code>f</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>x &gt; y</code>, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the greater-than operator of <a class="el" href="classpiranha_1_1mp__integer.html" title="Multiple precision integer class. ">piranha::mp_integer</a>,</li>
<li>the invoked conversion operator, if used. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01474">1474</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0fc0474b463771aa1a3b5bd87b85bbbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(!mp_rational::binary_less_than(x,y))
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic greater-than or equal operator involving <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This template operator is enabled only if either:<ul>
<li><code>T</code> is <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> and <code>U</code> is an interoperable type,</li>
<li><code>U</code> is <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a> and <code>T</code> is an interoperable type,</li>
<li>both <code>T</code> and <code>U</code> are <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>.</li>
</ul>
</dd></dl>
<p>If no floating-point types are involved, the exact result of the comparison will be returned.</p>
<p>If one of the arguments is a floating-point value <code>f</code> of type <code>F</code>, the other argument will be converted to an instance of type <code>F</code> and compared to <code>f</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>x &gt;= y</code>, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the less-than operator. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l01447">1447</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab8c1e907d2dc15363d50a0397da04cf2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int NBits = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpiranha_1_1mp__rational.html">mp_rational</a>&lt; NBits &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload input stream operator for <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>. </p>
<p>Equivalent to extracting a line from the stream and then assigning it to <code>q</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is</td><td>input stream. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">q</td><td>rational to which the contents of the stream will be assigned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>is</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the constructor from string of <a class="el" href="classpiranha_1_1mp__rational.html" title="Multiple precision rational class. ">piranha::mp_rational</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mp__rational_8hpp_source.html#l00865">865</a> of file <a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="mp__rational__fwd_8hpp_source.html">mp_rational_fwd.hpp</a></li>
<li><a class="el" href="mp__rational_8hpp_source.html">mp_rational.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 18 2015 21:06:04 for piranha by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9
</small></address>
</body>
</html>

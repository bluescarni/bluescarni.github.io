<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>piranha: piranha::hash_set&lt; T, Hash, Pred &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">piranha
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepiranha.html">piranha</a></li><li class="navelem"><a class="el" href="classpiranha_1_1hash__set.html">hash_set</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpiranha_1_1hash__set-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">piranha::hash_set&lt; T, Hash, Pred &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Hash set.  
 <a href="classpiranha_1_1hash__set.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3358548958f187113c4109c71d3e4b90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3358548958f187113c4109c71d3e4b90"></a>
typedef Hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a3358548958f187113c4109c71d3e4b90">hasher</a></td></tr>
<tr class="memdesc:a3358548958f187113c4109c71d3e4b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor type for the calculation of hash values. <br /></td></tr>
<tr class="separator:a3358548958f187113c4109c71d3e4b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ddef44083f51adc44cbcb28f1f6deb0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ddef44083f51adc44cbcb28f1f6deb0"></a>
typedef Pred&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a1ddef44083f51adc44cbcb28f1f6deb0">key_equal</a></td></tr>
<tr class="memdesc:a1ddef44083f51adc44cbcb28f1f6deb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor type for comparing the items in the set. <br /></td></tr>
<tr class="separator:a1ddef44083f51adc44cbcb28f1f6deb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac653c242d62d734ee3c4a9eebbea2bf7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac653c242d62d734ee3c4a9eebbea2bf7"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#ac653c242d62d734ee3c4a9eebbea2bf7">key_type</a></td></tr>
<tr class="memdesc:ac653c242d62d734ee3c4a9eebbea2bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key type. <br /></td></tr>
<tr class="separator:ac653c242d62d734ee3c4a9eebbea2bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35554d84e1181e8f6dff01fe3500e591"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a></td></tr>
<tr class="memdesc:a35554d84e1181e8f6dff01fe3500e591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type.  <a href="#a35554d84e1181e8f6dff01fe3500e591">More...</a><br /></td></tr>
<tr class="separator:a35554d84e1181e8f6dff01fe3500e591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9aa3a38e4d18f1b1793689b0fc64ff0"><td class="memItemLeft" align="right" valign="top">typedef iterator_impl&lt; <a class="el" href="classpiranha_1_1hash__set.html#ac653c242d62d734ee3c4a9eebbea2bf7">key_type</a> const  &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0">iterator</a></td></tr>
<tr class="memdesc:aa9aa3a38e4d18f1b1793689b0fc64ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type.  <a href="#aa9aa3a38e4d18f1b1793689b0fc64ff0">More...</a><br /></td></tr>
<tr class="separator:aa9aa3a38e4d18f1b1793689b0fc64ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3360e044316f471c5c9fa013afa4acae"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a3360e044316f471c5c9fa013afa4acae">const_iterator</a></td></tr>
<tr class="memdesc:a3360e044316f471c5c9fa013afa4acae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator type.  <a href="#a3360e044316f471c5c9fa013afa4acae">More...</a><br /></td></tr>
<tr class="separator:a3360e044316f471c5c9fa013afa4acae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67f930abbfc820886722ac03b57cfb3"><td class="memItemLeft" align="right" valign="top">typedef list::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#ae67f930abbfc820886722ac03b57cfb3">local_iterator</a></td></tr>
<tr class="memdesc:ae67f930abbfc820886722ac03b57cfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local iterator.  <a href="#ae67f930abbfc820886722ac03b57cfb3">More...</a><br /></td></tr>
<tr class="separator:ae67f930abbfc820886722ac03b57cfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4692ca4e714e42890b9e1df60f790a1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a4692ca4e714e42890b9e1df60f790a1e">hash_set</a> (const <a class="el" href="classpiranha_1_1hash__set.html#a3358548958f187113c4109c71d3e4b90">hasher</a> &amp;h=<a class="el" href="classpiranha_1_1hash__set.html#a3358548958f187113c4109c71d3e4b90">hasher</a>(), const <a class="el" href="classpiranha_1_1hash__set.html#a1ddef44083f51adc44cbcb28f1f6deb0">key_equal</a> &amp;k=<a class="el" href="classpiranha_1_1hash__set.html#a1ddef44083f51adc44cbcb28f1f6deb0">key_equal</a>())</td></tr>
<tr class="memdesc:a4692ca4e714e42890b9e1df60f790a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a4692ca4e714e42890b9e1df60f790a1e">More...</a><br /></td></tr>
<tr class="separator:a4692ca4e714e42890b9e1df60f790a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775be370fd244dcb9fe7d69833009c73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a775be370fd244dcb9fe7d69833009c73">hash_set</a> (const <a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a> &amp;n_buckets, const <a class="el" href="classpiranha_1_1hash__set.html#a3358548958f187113c4109c71d3e4b90">hasher</a> &amp;h=<a class="el" href="classpiranha_1_1hash__set.html#a3358548958f187113c4109c71d3e4b90">hasher</a>(), const <a class="el" href="classpiranha_1_1hash__set.html#a1ddef44083f51adc44cbcb28f1f6deb0">key_equal</a> &amp;k=<a class="el" href="classpiranha_1_1hash__set.html#a1ddef44083f51adc44cbcb28f1f6deb0">key_equal</a>(), unsigned n_threads=1u)</td></tr>
<tr class="memdesc:a775be370fd244dcb9fe7d69833009c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from number of buckets.  <a href="#a775be370fd244dcb9fe7d69833009c73">More...</a><br /></td></tr>
<tr class="separator:a775be370fd244dcb9fe7d69833009c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb332b27894abd27db2f96a37fb65424"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#afb332b27894abd27db2f96a37fb65424">hash_set</a> (const <a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> &amp;other)</td></tr>
<tr class="memdesc:afb332b27894abd27db2f96a37fb65424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#afb332b27894abd27db2f96a37fb65424">More...</a><br /></td></tr>
<tr class="separator:afb332b27894abd27db2f96a37fb65424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ef017f6b6d2e063440dbe46df7e51a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a23ef017f6b6d2e063440dbe46df7e51a">hash_set</a> (<a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a23ef017f6b6d2e063440dbe46df7e51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#a23ef017f6b6d2e063440dbe46df7e51a">More...</a><br /></td></tr>
<tr class="separator:a23ef017f6b6d2e063440dbe46df7e51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e98db5d79f1da36900c7369934efea"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a42e98db5d79f1da36900c7369934efea"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a42e98db5d79f1da36900c7369934efea">hash_set</a> (const InputIterator &amp;<a class="el" href="classpiranha_1_1hash__set.html#a93b2da097fdfd65b08ee15446419d05b">begin</a>, const InputIterator &amp;<a class="el" href="classpiranha_1_1hash__set.html#a74fb4d3e9dba445eeae7dfe6d6993932">end</a>, const <a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a> &amp;n_buckets=0u, const hasher &amp;h=hasher(), const key_equal &amp;k=key_equal())</td></tr>
<tr class="memdesc:a42e98db5d79f1da36900c7369934efea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from range.  <a href="#a42e98db5d79f1da36900c7369934efea">More...</a><br /></td></tr>
<tr class="separator:a42e98db5d79f1da36900c7369934efea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e70936b664aa2f5211cadd7b5c29397"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a6e70936b664aa2f5211cadd7b5c29397"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a6e70936b664aa2f5211cadd7b5c29397">hash_set</a> (std::initializer_list&lt; U &gt; list)</td></tr>
<tr class="memdesc:a6e70936b664aa2f5211cadd7b5c29397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from initializer list.  <a href="#a6e70936b664aa2f5211cadd7b5c29397">More...</a><br /></td></tr>
<tr class="separator:a6e70936b664aa2f5211cadd7b5c29397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cccdf7ed4e6a69a2bdd32641b362d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#ac0cccdf7ed4e6a69a2bdd32641b362d1">~hash_set</a> ()</td></tr>
<tr class="memdesc:ac0cccdf7ed4e6a69a2bdd32641b362d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ac0cccdf7ed4e6a69a2bdd32641b362d1">More...</a><br /></td></tr>
<tr class="separator:ac0cccdf7ed4e6a69a2bdd32641b362d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3dd442b2ca21a11390d3d4812c0156"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#afe3dd442b2ca21a11390d3d4812c0156">operator=</a> (const <a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> &amp;other)</td></tr>
<tr class="memdesc:afe3dd442b2ca21a11390d3d4812c0156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#afe3dd442b2ca21a11390d3d4812c0156">More...</a><br /></td></tr>
<tr class="separator:afe3dd442b2ca21a11390d3d4812c0156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfdf3a3c36d7bd5556a6ecbe4a015a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#addfdf3a3c36d7bd5556a6ecbe4a015a0">operator=</a> (<a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:addfdf3a3c36d7bd5556a6ecbe4a015a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#addfdf3a3c36d7bd5556a6ecbe4a015a0">More...</a><br /></td></tr>
<tr class="separator:addfdf3a3c36d7bd5556a6ecbe4a015a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b2da097fdfd65b08ee15446419d05b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#a3360e044316f471c5c9fa013afa4acae">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a93b2da097fdfd65b08ee15446419d05b">begin</a> () const </td></tr>
<tr class="memdesc:a93b2da097fdfd65b08ee15446419d05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const begin iterator.  <a href="#a93b2da097fdfd65b08ee15446419d05b">More...</a><br /></td></tr>
<tr class="separator:a93b2da097fdfd65b08ee15446419d05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fb4d3e9dba445eeae7dfe6d6993932"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#a3360e044316f471c5c9fa013afa4acae">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a74fb4d3e9dba445eeae7dfe6d6993932">end</a> () const </td></tr>
<tr class="memdesc:a74fb4d3e9dba445eeae7dfe6d6993932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const end iterator.  <a href="#a74fb4d3e9dba445eeae7dfe6d6993932">More...</a><br /></td></tr>
<tr class="separator:a74fb4d3e9dba445eeae7dfe6d6993932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d843fddaf9f43e904210a4be10ce2f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a2d843fddaf9f43e904210a4be10ce2f4">begin</a> ()</td></tr>
<tr class="memdesc:a2d843fddaf9f43e904210a4be10ce2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin iterator.  <a href="#a2d843fddaf9f43e904210a4be10ce2f4">More...</a><br /></td></tr>
<tr class="separator:a2d843fddaf9f43e904210a4be10ce2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f53ebc55378c1af9f13d45c55757ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#ae9f53ebc55378c1af9f13d45c55757ad">end</a> ()</td></tr>
<tr class="memdesc:ae9f53ebc55378c1af9f13d45c55757ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">End iterator.  <a href="#ae9f53ebc55378c1af9f13d45c55757ad">More...</a><br /></td></tr>
<tr class="separator:ae9f53ebc55378c1af9f13d45c55757ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58a1db344a23f3260fa1b1327ce15f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#aa58a1db344a23f3260fa1b1327ce15f3">size</a> () const </td></tr>
<tr class="memdesc:aa58a1db344a23f3260fa1b1327ce15f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements contained in the table.  <a href="#aa58a1db344a23f3260fa1b1327ce15f3">More...</a><br /></td></tr>
<tr class="separator:aa58a1db344a23f3260fa1b1327ce15f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04b17946b243676075974f312a733ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#ad04b17946b243676075974f312a733ec">empty</a> () const </td></tr>
<tr class="memdesc:ad04b17946b243676075974f312a733ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for empty table.  <a href="#ad04b17946b243676075974f312a733ec">More...</a><br /></td></tr>
<tr class="separator:ad04b17946b243676075974f312a733ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30c6af8e1b498c7ac15c204899e0ae9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#ae30c6af8e1b498c7ac15c204899e0ae9">bucket_count</a> () const </td></tr>
<tr class="memdesc:ae30c6af8e1b498c7ac15c204899e0ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of buckets.  <a href="#ae30c6af8e1b498c7ac15c204899e0ae9">More...</a><br /></td></tr>
<tr class="separator:ae30c6af8e1b498c7ac15c204899e0ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570ae119865b9bdcde64ff10459b3852"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a570ae119865b9bdcde64ff10459b3852">load_factor</a> () const </td></tr>
<tr class="memdesc:a570ae119865b9bdcde64ff10459b3852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load factor.  <a href="#a570ae119865b9bdcde64ff10459b3852">More...</a><br /></td></tr>
<tr class="separator:a570ae119865b9bdcde64ff10459b3852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fc5f5a8ba36f4c50bdd577d0fabe42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a13fc5f5a8ba36f4c50bdd577d0fabe42">bucket</a> (const <a class="el" href="classpiranha_1_1hash__set.html#ac653c242d62d734ee3c4a9eebbea2bf7">key_type</a> &amp;k) const </td></tr>
<tr class="memdesc:a13fc5f5a8ba36f4c50bdd577d0fabe42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of destination bucket.  <a href="#a13fc5f5a8ba36f4c50bdd577d0fabe42">More...</a><br /></td></tr>
<tr class="separator:a13fc5f5a8ba36f4c50bdd577d0fabe42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455c154b0614dc4d86112550ed3e4346"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#a3360e044316f471c5c9fa013afa4acae">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a455c154b0614dc4d86112550ed3e4346">find</a> (const <a class="el" href="classpiranha_1_1hash__set.html#ac653c242d62d734ee3c4a9eebbea2bf7">key_type</a> &amp;k) const </td></tr>
<tr class="memdesc:a455c154b0614dc4d86112550ed3e4346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find element.  <a href="#a455c154b0614dc4d86112550ed3e4346">More...</a><br /></td></tr>
<tr class="separator:a455c154b0614dc4d86112550ed3e4346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb23bf3f6828e339e413a33ad9a3083"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a0eb23bf3f6828e339e413a33ad9a3083">find</a> (const <a class="el" href="classpiranha_1_1hash__set.html#ac653c242d62d734ee3c4a9eebbea2bf7">key_type</a> &amp;k)</td></tr>
<tr class="memdesc:a0eb23bf3f6828e339e413a33ad9a3083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find element.  <a href="#a0eb23bf3f6828e339e413a33ad9a3083">More...</a><br /></td></tr>
<tr class="separator:a0eb23bf3f6828e339e413a33ad9a3083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e4e3bff0636960db4be7a2493ed8f7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#ab6e4e3bff0636960db4be7a2493ed8f7">max_load_factor</a> () const </td></tr>
<tr class="memdesc:ab6e4e3bff0636960db4be7a2493ed8f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum load factor.  <a href="#ab6e4e3bff0636960db4be7a2493ed8f7">More...</a><br /></td></tr>
<tr class="separator:ab6e4e3bff0636960db4be7a2493ed8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1932a69f1c81715ad76a182f7eca9d9f"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a1932a69f1c81715ad76a182f7eca9d9f"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a1932a69f1c81715ad76a182f7eca9d9f">insert</a> (U &amp;&amp;k, typename std::enable_if&lt; std::is_same&lt; T, typename std::decay&lt; U &gt;::type &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:a1932a69f1c81715ad76a182f7eca9d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert element.  <a href="#a1932a69f1c81715ad76a182f7eca9d9f">More...</a><br /></td></tr>
<tr class="separator:a1932a69f1c81715ad76a182f7eca9d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e4d798ba7678f8874e5ca09696feed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a02e4d798ba7678f8874e5ca09696feed">erase</a> (const <a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0">iterator</a> &amp;it)</td></tr>
<tr class="memdesc:a02e4d798ba7678f8874e5ca09696feed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element.  <a href="#a02e4d798ba7678f8874e5ca09696feed">More...</a><br /></td></tr>
<tr class="separator:a02e4d798ba7678f8874e5ca09696feed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c574ee8280352852816be2127e3e072"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a6c574ee8280352852816be2127e3e072">clear</a> ()</td></tr>
<tr class="memdesc:a6c574ee8280352852816be2127e3e072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements.  <a href="#a6c574ee8280352852816be2127e3e072">More...</a><br /></td></tr>
<tr class="separator:a6c574ee8280352852816be2127e3e072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf673b10b69a549482652f34834bc80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a4bf673b10b69a549482652f34834bc80">swap</a> (<a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> &amp;other)</td></tr>
<tr class="memdesc:a4bf673b10b69a549482652f34834bc80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap content.  <a href="#a4bf673b10b69a549482652f34834bc80">More...</a><br /></td></tr>
<tr class="separator:a4bf673b10b69a549482652f34834bc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19de666eb17d34c1a97725c04b6238fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a19de666eb17d34c1a97725c04b6238fd">rehash</a> (const <a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a> &amp;new_size, unsigned n_threads=1u)</td></tr>
<tr class="memdesc:a19de666eb17d34c1a97725c04b6238fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rehash table.  <a href="#a19de666eb17d34c1a97725c04b6238fd">More...</a><br /></td></tr>
<tr class="separator:a19de666eb17d34c1a97725c04b6238fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947bcba0e0439d1abf15050567034978"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a>, <a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a947bcba0e0439d1abf15050567034978">evaluate_sparsity</a> () const </td></tr>
<tr class="memdesc:a947bcba0e0439d1abf15050567034978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information on the sparsity of the table.  <a href="#a947bcba0e0439d1abf15050567034978">More...</a><br /></td></tr>
<tr class="separator:a947bcba0e0439d1abf15050567034978"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Low-level interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp7488076a19cba8b11ea501b8ea5632f5"></a>Low-level methods and types. </p>
</td></tr>
<tr class="memitem:a92ddcd8b23f86838146d494a5f9efed3"><td class="memItemLeft" align="right" valign="top">typedef iterator_impl&lt; <a class="el" href="classpiranha_1_1hash__set.html#ac653c242d62d734ee3c4a9eebbea2bf7">key_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a92ddcd8b23f86838146d494a5f9efed3">_m_iterator</a></td></tr>
<tr class="memdesc:a92ddcd8b23f86838146d494a5f9efed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable iterator.  <a href="#a92ddcd8b23f86838146d494a5f9efed3">More...</a><br /></td></tr>
<tr class="separator:a92ddcd8b23f86838146d494a5f9efed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb51f373c6a699f629cea1a895ec17cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#a92ddcd8b23f86838146d494a5f9efed3">_m_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#abb51f373c6a699f629cea1a895ec17cd">_m_begin</a> ()</td></tr>
<tr class="memdesc:abb51f373c6a699f629cea1a895ec17cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable begin iterator.  <a href="#abb51f373c6a699f629cea1a895ec17cd">More...</a><br /></td></tr>
<tr class="separator:abb51f373c6a699f629cea1a895ec17cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47fe9d9b519f2cfd56549479b1d000c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#a92ddcd8b23f86838146d494a5f9efed3">_m_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#ae47fe9d9b519f2cfd56549479b1d000c">_m_end</a> ()</td></tr>
<tr class="memdesc:ae47fe9d9b519f2cfd56549479b1d000c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable end iterator.  <a href="#ae47fe9d9b519f2cfd56549479b1d000c">More...</a><br /></td></tr>
<tr class="separator:ae47fe9d9b519f2cfd56549479b1d000c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2d00d6af10f99df81b512b04aace48"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a4b2d00d6af10f99df81b512b04aace48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a4b2d00d6af10f99df81b512b04aace48">_unique_insert</a> (U &amp;&amp;k, const <a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a> &amp;bucket_idx, typename std::enable_if&lt; std::is_same&lt; T, typename std::decay&lt; U &gt;::type &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:a4b2d00d6af10f99df81b512b04aace48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert unique element (low-level).  <a href="#a4b2d00d6af10f99df81b512b04aace48">More...</a><br /></td></tr>
<tr class="separator:a4b2d00d6af10f99df81b512b04aace48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa747b430fe16e4cf93455d89eb715eb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#a3360e044316f471c5c9fa013afa4acae">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#aa747b430fe16e4cf93455d89eb715eb1">_find</a> (const <a class="el" href="classpiranha_1_1hash__set.html#ac653c242d62d734ee3c4a9eebbea2bf7">key_type</a> &amp;k, const <a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a> &amp;bucket_idx) const </td></tr>
<tr class="memdesc:aa747b430fe16e4cf93455d89eb715eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find element (low-level).  <a href="#aa747b430fe16e4cf93455d89eb715eb1">More...</a><br /></td></tr>
<tr class="separator:aa747b430fe16e4cf93455d89eb715eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3fb5556ef2c91a3d69bb90956b0bd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a6c3fb5556ef2c91a3d69bb90956b0bd2">_bucket_from_hash</a> (const std::size_t &amp;hash) const </td></tr>
<tr class="memdesc:a6c3fb5556ef2c91a3d69bb90956b0bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of destination bucket from hash value.  <a href="#a6c3fb5556ef2c91a3d69bb90956b0bd2">More...</a><br /></td></tr>
<tr class="separator:a6c3fb5556ef2c91a3d69bb90956b0bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8274117bcb42b293702fbe4e2406df09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a8274117bcb42b293702fbe4e2406df09">_bucket</a> (const <a class="el" href="classpiranha_1_1hash__set.html#ac653c242d62d734ee3c4a9eebbea2bf7">key_type</a> &amp;k) const </td></tr>
<tr class="memdesc:a8274117bcb42b293702fbe4e2406df09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of destination bucket (low-level).  <a href="#a8274117bcb42b293702fbe4e2406df09">More...</a><br /></td></tr>
<tr class="separator:a8274117bcb42b293702fbe4e2406df09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435316baaf709ace4479a6e5f2db2227"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a435316baaf709ace4479a6e5f2db2227">_update_size</a> (const <a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a> &amp;new_size)</td></tr>
<tr class="memdesc:a435316baaf709ace4479a6e5f2db2227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force update of the number of elements.  <a href="#a435316baaf709ace4479a6e5f2db2227">More...</a><br /></td></tr>
<tr class="separator:a435316baaf709ace4479a6e5f2db2227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cae073bdb82fa916c9a1e55590cd927"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#a8cae073bdb82fa916c9a1e55590cd927">_increase_size</a> ()</td></tr>
<tr class="memdesc:a8cae073bdb82fa916c9a1e55590cd927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase bucket count.  <a href="#a8cae073bdb82fa916c9a1e55590cd927">More...</a><br /></td></tr>
<tr class="separator:a8cae073bdb82fa916c9a1e55590cd927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f8ebcae6d7453d73599fe92c37f43b"><td class="memItemLeft" align="right" valign="top">const list &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#af6f8ebcae6d7453d73599fe92c37f43b">_get_bucket_list</a> (const <a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a> &amp;idx) const </td></tr>
<tr class="memdesc:af6f8ebcae6d7453d73599fe92c37f43b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const reference to list in bucket.  <a href="#af6f8ebcae6d7453d73599fe92c37f43b">More...</a><br /></td></tr>
<tr class="separator:af6f8ebcae6d7453d73599fe92c37f43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1cfcbf1ed8a13577255785d1f4258c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1hash__set.html#ae67f930abbfc820886722ac03b57cfb3">local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1hash__set.html#aa1cfcbf1ed8a13577255785d1f4258c2">_erase</a> (const <a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0">iterator</a> &amp;it)</td></tr>
<tr class="memdesc:aa1cfcbf1ed8a13577255785d1f4258c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element.  <a href="#aa1cfcbf1ed8a13577255785d1f4258c2">More...</a><br /></td></tr>
<tr class="separator:aa1cfcbf1ed8a13577255785d1f4258c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt;<br />
class piranha::hash_set&lt; T, Hash, Pred &gt;</h3>

<p>Hash set. </p>
<p>Hash set class with interface similar to <code>std::unordered_set</code>. The main points of difference with respect to <code>std::unordered_set</code> are the following:</p>
<ul>
<li>the exception safety guarantee is weaker (see below),</li>
<li>iterators and iterator invalidation: after a rehash operation, all iterators will be invalidated and existing references/pointers to the elements will also be invalid; after an insertion/erase operation, all existing iterators, pointers and references to the elements in the destination bucket will be invalid.</li>
</ul>
<p>The implementation employs a separate chaining strategy consisting of an array of buckets, each one a singly linked list with the first node stored directly within the array (so that the first insertion in a bucket does not require any heap allocation).</p>
<p>An additional set of low-level methods is provided: such methods are suitable for use in high-performance and multi-threaded contexts, and, if misused, could lead to data corruption and other unpredictable errors.</p>
<p>Note that for performance reasons the implementation employs table sizes that are powers of two. Hence, particular care should be taken that the hash function does not exhibit commensurabilities with powers of 2.</p>
<h2>Type requirements</h2>
<ul>
<li><code>T</code> must satisfy <a class="el" href="structpiranha_1_1is__container__element.html" title="Type trait for well-behaved container elements. ">piranha::is_container_element</a>,</li>
<li><code>Hash</code> must satisfy <a class="el" href="classpiranha_1_1is__hash__function__object.html" title="Type trait to detect hash function objects. ">piranha::is_hash_function_object</a>,</li>
<li><code>Pred</code> must satisfy <a class="el" href="classpiranha_1_1is__equality__function__object.html" title="Type trait to detect equality function objects. ">piranha::is_equality_function_object</a>.</li>
</ul>
<h2>Exception safety guarantee</h2>
<p>This class provides the strong exception safety guarantee for all operations apart from methods involving insertion, which provide the basic guarantee (after a failed insertion, the table will be left in an unspecified but valid state).</p>
<h2>Move semantics</h2>
<p>Move construction and move assignment will leave the moved-from object equivalent to an empty set whose hasher and equality predicate have been moved-from.</p>
<h2>Serialization</h2>
<p>This class supports serialization if the contained type supports it. Note that the hasher and the comparator are not serialised and they are recreated from scratch upon deserialization.</p>
<dl class="section author"><dt>Author</dt><dd>Francesco Biscani (<a href="#" onclick="location.href='mai'+'lto:'+'blu'+'es'+'car'+'ni'+'@gm'+'ai'+'l.c'+'om'; return false;">blues<span style="display: none;">.nosp@m.</span>carn<span style="display: none;">.nosp@m.</span>i@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a>) </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00109">109</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a92ddcd8b23f86838146d494a5f9efed3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef iterator_impl&lt;<a class="el" href="classpiranha_1_1hash__set.html#ac653c242d62d734ee3c4a9eebbea2bf7">key_type</a>&gt; <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::<a class="el" href="classpiranha_1_1hash__set.html#a92ddcd8b23f86838146d494a5f9efed3">_m_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutable iterator. </p>
<p>This iterator type provides non-const access to the elements of the table. Please note that modifications to an existing element of the table might invalidate the relation between the element and its position in the table. After such modifications of one or more elements, the only valid operation is <a class="el" href="classpiranha_1_1hash__set.html#a6c574ee8280352852816be2127e3e072" title="Remove all elements. ">hash_set::clear()</a> (destruction of the table before calling <a class="el" href="classpiranha_1_1hash__set.html#a6c574ee8280352852816be2127e3e072" title="Remove all elements. ">hash_set::clear()</a> will lead to assertion failures in debug mode). </p>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01071">1071</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3360e044316f471c5c9fa013afa4acae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0">iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::<a class="el" href="classpiranha_1_1hash__set.html#a3360e044316f471c5c9fa013afa4acae">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const iterator type. </p>
<p>Equivalent to the iterator type. </p>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00537">537</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa9aa3a38e4d18f1b1793689b0fc64ff0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef iterator_impl&lt;<a class="el" href="classpiranha_1_1hash__set.html#ac653c242d62d734ee3c4a9eebbea2bf7">key_type</a> const&gt; <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::<a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator type. </p>
<p>A read-only forward iterator. </p>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00528">528</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae67f930abbfc820886722ac03b57cfb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef list::const_iterator <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::<a class="el" href="classpiranha_1_1hash__set.html#ae67f930abbfc820886722ac03b57cfb3">local_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Local iterator. </p>
<p>Const iterator that can be used to iterate through a single bucket. </p>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00542">542</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a35554d84e1181e8f6dff01fe3500e591"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::<a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size type. </p>
<p>Alias for <code>std::size_t</code>. </p>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00354">354</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4692ca4e714e42890b9e1df60f790a1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::<a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#a3358548958f187113c4109c71d3e4b90">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classpiranha_1_1hash__set.html#a3358548958f187113c4109c71d3e4b90">hasher</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#a1ddef44083f51adc44cbcb28f1f6deb0">key_equal</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em> = <code><a class="el" href="classpiranha_1_1hash__set.html#a1ddef44083f51adc44cbcb28f1f6deb0">key_equal</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>If not specified, it will default-initialise the hasher and the equality predicate. The resulting hash set will be empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>hasher functor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>equality predicate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the copy constructors of <code>Hash</code> or <code>Pred</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00553">553</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a775be370fd244dcb9fe7d69833009c73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::<a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>n_buckets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#a3358548958f187113c4109c71d3e4b90">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classpiranha_1_1hash__set.html#a3358548958f187113c4109c71d3e4b90">hasher</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#a1ddef44083f51adc44cbcb28f1f6deb0">key_equal</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em> = <code><a class="el" href="classpiranha_1_1hash__set.html#a1ddef44083f51adc44cbcb28f1f6deb0">key_equal</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code>1u</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from number of buckets. </p>
<p>Will construct a table whose number of buckets is at least equal to <code>n_buckets</code>. If <code>n_threads</code> is not 1, then the first <code>n_threads</code> threads from <a class="el" href="classpiranha_1_1thread__pool.html" title="Static thread pool. ">piranha::thread_pool</a> will be used concurrently for the initialisation of the table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n_buckets</td><td>desired number of buckets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>hasher functor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>equality predicate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_threads</td><td>number of threads to use during initialisation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if the desired number of buckets is greater than an implementation-defined maximum, or in case of memory errors. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>n_threads</code> is zero. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the copy constructors of <code>Hash</code> or <code>Pred</code>,</li>
<li><a class="el" href="classpiranha_1_1thread__pool.html#a3478c7cb97f5030d943d5d99e50717a3" title="Append task. ">piranha::thread_pool::enqueue()</a> or <a class="el" href="classpiranha_1_1future__list.html#a2e80f33417eef5cb4ac2ecf6d7c5c942" title="Move-insert a future. ">piranha::future_list::push_back()</a>, if <code>n_threads</code> is not 1. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00573">573</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afb332b27894abd27db2f96a37fb65424"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::<a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html">hash_set</a>&lt; T, Hash, Pred &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td><a class="el" href="classpiranha_1_1hash__set.html" title="Hash set. ">piranha::hash_set</a> that will be copied into <code>this</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by memory allocation errors, the copy constructor of the stored type, <code>Hash</code> or <code>Pred</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00585">585</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a23ef017f6b6d2e063440dbe46df7e51a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::<a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpiranha_1_1hash__set.html">hash_set</a>&lt; T, Hash, Pred &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>After the move, <code>other</code> will have zero buckets and zero elements, and its hasher and equality predicate will have been used to move-construct their counterparts in <code>this</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>table to be moved. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00625">625</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a42e98db5d79f1da36900c7369934efea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::<a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> </td>
          <td>(</td>
          <td class="paramtype">const InputIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>n_buckets</em> = <code>0u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#a3358548958f187113c4109c71d3e4b90">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classpiranha_1_1hash__set.html#a3358548958f187113c4109c71d3e4b90">hasher</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#a1ddef44083f51adc44cbcb28f1f6deb0">key_equal</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em> = <code><a class="el" href="classpiranha_1_1hash__set.html#a1ddef44083f51adc44cbcb28f1f6deb0">key_equal</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from range. </p>
<p>Create a table with a copy of a range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>begin of range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>end of range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_buckets</td><td>number of initial buckets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>hash functor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key equality predicate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if the desired number of buckets is greater than an implementation-defined maximum. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the copy constructors of <code>Hash</code> or <code>Pred</code>, or arising from calling <a class="el" href="classpiranha_1_1hash__set.html#a1932a69f1c81715ad76a182f7eca9d9f" title="Insert element. ">insert()</a> on the elements of the range. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00649">649</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6e70936b664aa2f5211cadd7b5c29397"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::<a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; U &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from initializer list. </p>
<p>Will <a class="el" href="classpiranha_1_1hash__set.html#a1932a69f1c81715ad76a182f7eca9d9f" title="Insert element. ">insert()</a> all the elements of the initializer list, ignoring the return value of the operation. Hash functor and equality predicate will be default-constructed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>initializer list of elements to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if the desired number of buckets is greater than an implementation-defined maximum. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by either <a class="el" href="classpiranha_1_1hash__set.html#a1932a69f1c81715ad76a182f7eca9d9f" title="Insert element. ">insert()</a> or of the default constructor of <code>Hash</code> or <code>Pred</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00669">669</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac0cccdf7ed4e6a69a2bdd32641b362d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::~<a class="el" href="classpiranha_1_1hash__set.html">hash_set</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>No side effects. </p>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00682">682</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8274117bcb42b293702fbe4e2406df09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::_bucket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#ac653c242d62d734ee3c4a9eebbea2bf7">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of destination bucket (low-level). </p>
<p>Equivalent to <a class="el" href="classpiranha_1_1hash__set.html#a13fc5f5a8ba36f4c50bdd577d0fabe42" title="Index of destination bucket. ">bucket()</a>, with the exception that this method will not check if the number of buckets is zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>input argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the destination bucket for <code>k</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the call operator of the hasher. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01188">1188</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6c3fb5556ef2c91a3d69bb90956b0bd2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::_bucket_from_hash </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of destination bucket from hash value. </p>
<p>Note that this method will not check if the number of buckets is zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hash</td><td>input hash value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the destination bucket for an object with hash value <code>hash</code>. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01172">1172</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa1cfcbf1ed8a13577255785d1f4258c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#ae67f930abbfc820886722ac03b57cfb3">local_iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::_erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase element. </p>
<p>Erase the element to which <code>it</code> points. <code>it</code> must be a valid iterator pointing to an element of the table.</p>
<p>Erasing an element invalidates all iterators pointing to elements in the same bucket as the erased element.</p>
<p>This method will not update the number of elements in the table, nor it will try to access elements outside the bucket to which <code>it</code> refers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">it</td><td>iterator to the element of the table to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>local iterator pointing to the element following <code>it</code> pior to the element being erased, or local <a class="el" href="classpiranha_1_1hash__set.html#ae9f53ebc55378c1af9f13d45c55757ad" title="End iterator. ">end()</a> if no such element exists. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01250">1250</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa747b430fe16e4cf93455d89eb715eb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#a3360e044316f471c5c9fa013afa4acae">const_iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::_find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#ac653c242d62d734ee3c4a9eebbea2bf7">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bucket_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find element (low-level). </p>
<p>Locate element in the table. The parameter <code>bucket_idx</code> is the index of the destination bucket for <code>k</code> and, for a table with a nonzero number of buckets, must be equal to the output of <a class="el" href="classpiranha_1_1hash__set.html#a13fc5f5a8ba36f4c50bdd577d0fabe42" title="Index of destination bucket. ">bucket()</a> before the insertion. This method will not check if the value of <code>bucket_idx</code> is correct.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>element to be located. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bucket_idx</td><td>index of the destination bucket for <code>k</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0" title="Iterator type. ">hash_set::iterator</a> to <code>k</code>'s position in the table, or <a class="el" href="classpiranha_1_1hash__set.html#ae9f53ebc55378c1af9f13d45c55757ad" title="End iterator. ">end()</a> if <code>k</code> is not in the table.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by calling the equality predicate. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01148">1148</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6f8ebcae6d7453d73599fe92c37f43b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const list&amp; <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::_get_bucket_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const reference to list in bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>index of the bucket whose list will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the list of items contained in the bucket positioned at index <code>idx</code>. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01229">1229</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8cae073bdb82fa916c9a1e55590cd927"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::_increase_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase bucket count. </p>
<p>Increase the number of buckets to the next implementation-defined value.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if the operation results in a resize of the table past an implementation-defined maximum number of buckets. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classpiranha_1_1hash__set.html#a19de666eb17d34c1a97725c04b6238fd" title="Rehash table. ">rehash()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01210">1210</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abb51f373c6a699f629cea1a895ec17cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#a92ddcd8b23f86838146d494a5f9efed3">_m_iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::_m_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutable begin iterator. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classpiranha_1_1hash__set.html#a92ddcd8b23f86838146d494a5f9efed3" title="Mutable iterator. ">hash_set::_m_iterator</a> to the beginning of the table. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01076">1076</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae47fe9d9b519f2cfd56549479b1d000c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#a92ddcd8b23f86838146d494a5f9efed3">_m_iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::_m_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutable end iterator. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classpiranha_1_1hash__set.html#a92ddcd8b23f86838146d494a5f9efed3" title="Mutable iterator. ">hash_set::_m_iterator</a> to the end of the table. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01100">1100</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4b2d00d6af10f99df81b512b04aace48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0">iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::_unique_insert </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>bucket_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; std::is_same&lt; T, typename std::decay&lt; U &gt;::type &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert unique element (low-level). </p>
<p>This template is activated only if <code>T</code> and <code>U</code> are the same type, aside from cv qualifications and references. The parameter <code>bucket_idx</code> is the index of the destination bucket for <code>k</code> and, for a table with a nonzero number of buckets, must be equal to the output of <a class="el" href="classpiranha_1_1hash__set.html#a13fc5f5a8ba36f4c50bdd577d0fabe42" title="Index of destination bucket. ">bucket()</a> before the insertion.</p>
<p>This method will not check if a key equivalent to <code>k</code> already exists in the table, it will not update the number of elements present in the table after the insertion, it will not resize the table in case the maximum load factor is exceeded, nor it will check if the value of <code>bucket_idx</code> is correct.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>object that will be inserted into the table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bucket_idx</td><td>destination bucket for <code>k</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the newly-inserted element.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the copy constructor of <a class="el" href="classpiranha_1_1hash__set.html#ac653c242d62d734ee3c4a9eebbea2bf7" title="Key type. ">hash_set::key_type</a> or by memory allocation errors. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01125">1125</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a435316baaf709ace4479a6e5f2db2227"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::_update_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force update of the number of elements. </p>
<p>After this call, <a class="el" href="classpiranha_1_1hash__set.html#aa58a1db344a23f3260fa1b1327ce15f3" title="Number of elements contained in the table. ">size()</a> will return <code>new_size</code> regardless of the true number of elements in the table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_size</td><td>new table size. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01198">1198</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a93b2da097fdfd65b08ee15446419d05b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#a3360e044316f471c5c9fa013afa4acae">const_iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const begin iterator. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classpiranha_1_1hash__set.html#a3360e044316f471c5c9fa013afa4acae" title="Const iterator type. ">hash_set::const_iterator</a> to the first element of the table, or <a class="el" href="classpiranha_1_1hash__set.html#ae9f53ebc55378c1af9f13d45c55757ad" title="End iterator. ">end()</a> if the table is empty. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00730">730</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d843fddaf9f43e904210a4be10ce2f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0">iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin iterator. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0" title="Iterator type. ">hash_set::iterator</a> to the first element of the table, or <a class="el" href="classpiranha_1_1hash__set.html#ae9f53ebc55378c1af9f13d45c55757ad" title="End iterator. ">end()</a> if the table is empty. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00762">762</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a13fc5f5a8ba36f4c50bdd577d0fabe42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::bucket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#ac653c242d62d734ee3c4a9eebbea2bf7">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of destination bucket. </p>
<p>Index to which <code>k</code> would belong, were it to be inserted into the table. The index of the destination bucket is the hash value reduced modulo the bucket count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>input argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the destination bucket for <code>k</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structpiranha_1_1zero__division__error.html" title="Exception for signalling division by zero. ">piranha::zero_division_error</a></td><td>if <a class="el" href="classpiranha_1_1hash__set.html#ae30c6af8e1b498c7ac15c204899e0ae9" title="Number of buckets. ">bucket_count()</a> returns zero. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classpiranha_1_1hash__set.html#a8274117bcb42b293702fbe4e2406df09" title="Index of destination bucket (low-level). ">_bucket()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00819">819</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae30c6af8e1b498c7ac15c204899e0ae9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of buckets. </p>
<dl class="section return"><dt>Returns</dt><dd>number of buckets in the table. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00794">794</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6c574ee8280352852816be2127e3e072"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all elements. </p>
<p>After this call, <a class="el" href="classpiranha_1_1hash__set.html#aa58a1db344a23f3260fa1b1327ce15f3" title="Number of elements contained in the table. ">size()</a> and <a class="el" href="classpiranha_1_1hash__set.html#ae30c6af8e1b498c7ac15c204899e0ae9" title="Number of buckets. ">bucket_count()</a> will both return zero. </p>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00963">963</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad04b17946b243676075974f312a733ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for empty table. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <a class="el" href="classpiranha_1_1hash__set.html#aa58a1db344a23f3260fa1b1327ce15f3" title="Number of elements contained in the table. ">size()</a> returns 0, <code>false</code> otherwise. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00786">786</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a74fb4d3e9dba445eeae7dfe6d6993932"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#a3360e044316f471c5c9fa013afa4acae">const_iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const end iterator. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classpiranha_1_1hash__set.html#a3360e044316f471c5c9fa013afa4acae" title="Const iterator type. ">hash_set::const_iterator</a> to the position past the last element of the table. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00754">754</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae9f53ebc55378c1af9f13d45c55757ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0">iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End iterator. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0" title="Iterator type. ">hash_set::iterator</a> to the position past the last element of the table. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00770">770</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a02e4d798ba7678f8874e5ca09696feed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0">iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase element. </p>
<p>Erase the element to which <code>it</code> points. <code>it</code> must be a valid iterator pointing to an element of the table.</p>
<p>Erasing an element invalidates all iterators pointing to elements in the same bucket as the erased element.</p>
<p>After the operation has taken place, the <a class="el" href="classpiranha_1_1hash__set.html#aa58a1db344a23f3260fa1b1327ce15f3" title="Number of elements contained in the table. ">size()</a> of the table will be decreased by one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">it</td><td>iterator to the element of the table to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the element following <code>it</code> pior to the element being erased, or <a class="el" href="classpiranha_1_1hash__set.html#ae9f53ebc55378c1af9f13d45c55757ad" title="End iterator. ">end()</a> if no such element exists. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00929">929</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a947bcba0e0439d1abf15050567034978"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a>,<a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a>&gt; <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::evaluate_sparsity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get information on the sparsity of the table. </p>
<dl class="section return"><dt>Returns</dt><dd>an <code>std::map&lt;size_type,size_type&gt;</code> in which the key is the number of elements stored in a bucket and the mapped type the number of buckets containing those many elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by memory errors in standard containers. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01046">1046</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a455c154b0614dc4d86112550ed3e4346"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#a3360e044316f471c5c9fa013afa4acae">const_iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#ac653c242d62d734ee3c4a9eebbea2bf7">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>element to be located.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classpiranha_1_1hash__set.html#a3360e044316f471c5c9fa013afa4acae" title="Const iterator type. ">hash_set::const_iterator</a> to <code>k</code>'s position in the table, or <a class="el" href="classpiranha_1_1hash__set.html#ae9f53ebc55378c1af9f13d45c55757ad" title="End iterator. ">end()</a> if <code>k</code> is not in the table.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classpiranha_1_1hash__set.html#aa747b430fe16e4cf93455d89eb715eb1" title="Find element (low-level). ">_find()</a> or by <a class="el" href="classpiranha_1_1hash__set.html#a8274117bcb42b293702fbe4e2406df09" title="Index of destination bucket (low-level). ">_bucket()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00834">834</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0eb23bf3f6828e339e413a33ad9a3083"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0">iterator</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#ac653c242d62d734ee3c4a9eebbea2bf7">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>element to be located.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0" title="Iterator type. ">hash_set::iterator</a> to <code>k</code>'s position in the table, or <a class="el" href="classpiranha_1_1hash__set.html#ae9f53ebc55378c1af9f13d45c55757ad" title="End iterator. ">end()</a> if <code>k</code> is not in the table.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classpiranha_1_1hash__set.html#aa747b430fe16e4cf93455d89eb715eb1" title="Find element (low-level). ">_find()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00849">849</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1932a69f1c81715ad76a182f7eca9d9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0">iterator</a>,bool&gt; <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; std::is_same&lt; T, typename std::decay&lt; U &gt;::type &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert element. </p>
<p>This template is activated only if <code>T</code> and <code>U</code> are the same type, aside from cv qualifications and references. If no other key equivalent to <code>k</code> exists in the table, the insertion is successful and returns the <code>(it,true)</code> pair - where <code>it</code> is the position in the table into which the object has been inserted. Otherwise, the return value will be <code>(it,false)</code> - where <code>it</code> is the position of the existing equivalent object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>object that will be inserted into the table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(<a class="el" href="classpiranha_1_1hash__set.html#aa9aa3a38e4d18f1b1793689b0fc64ff0" title="Iterator type. ">hash_set::iterator</a>,bool)</code> pair containing an iterator to the newly-inserted object (or its existing equivalent) and the result of the operation.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1hash__set.html#ac653c242d62d734ee3c4a9eebbea2bf7" title="Key type. ">hash_set::key_type</a>'s copy constructor,</li>
<li><a class="el" href="classpiranha_1_1hash__set.html#aa747b430fe16e4cf93455d89eb715eb1" title="Find element (low-level). ">_find()</a>,</li>
<li><a class="el" href="classpiranha_1_1hash__set.html#a8274117bcb42b293702fbe4e2406df09" title="Index of destination bucket (low-level). ">_bucket()</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">std::overflow_error</td><td>if a successful insertion would result in <a class="el" href="classpiranha_1_1hash__set.html#aa58a1db344a23f3260fa1b1327ce15f3" title="Number of elements contained in the table. ">size()</a> exceeding the maximum value representable by type <a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591" title="Size type. ">piranha::hash_set::size_type</a>. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if the operation results in a resize of the table past an implementation-defined maximum number of buckets. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00885">885</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a570ae119865b9bdcde64ff10459b3852"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load factor. </p>
<dl class="section return"><dt>Returns</dt><dd><code>(double)<a class="el" href="classpiranha_1_1hash__set.html#aa58a1db344a23f3260fa1b1327ce15f3" title="Number of elements contained in the table. ">size()</a> / <a class="el" href="classpiranha_1_1hash__set.html#ae30c6af8e1b498c7ac15c204899e0ae9" title="Number of buckets. ">bucket_count()</a></code>, or 0 if the table is empty. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00802">802</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab6e4e3bff0636960db4be7a2493ed8f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum load factor. </p>
<dl class="section return"><dt>Returns</dt><dd>the maximum load factor allowed before a resize. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00857">857</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afe3dd442b2ca21a11390d3d4812c0156"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html">hash_set</a>&amp; <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html">hash_set</a>&lt; T, Hash, Pred &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>assignment argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the copy constructor. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00695">695</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="addfdf3a3c36d7bd5556a6ecbe4a015a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html">hash_set</a>&amp; <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpiranha_1_1hash__set.html">hash_set</a>&lt; T, Hash, Pred &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>table to be moved into <code>this</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>this</code>. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00709">709</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a19de666eb17d34c1a97725c04b6238fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code>1u</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rehash table. </p>
<p>Change the number of buckets in the table to at least <code>new_size</code>. No rehash is performed if rehashing would lead to exceeding the maximum load factor. If <code>n_threads</code> is not 1, then the first <code>n_threads</code> threads from <a class="el" href="classpiranha_1_1thread__pool.html" title="Static thread pool. ">piranha::thread_pool</a> will be used concurrently during the rehash operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_size</td><td>new desired number of buckets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_threads</td><td>number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>n_threads</code> is zero. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the constructor from number of buckets, <a class="el" href="classpiranha_1_1hash__set.html#a4b2d00d6af10f99df81b512b04aace48" title="Insert unique element (low-level). ">_unique_insert()</a> or <a class="el" href="classpiranha_1_1hash__set.html#a8274117bcb42b293702fbe4e2406df09" title="Index of destination bucket (low-level). ">_bucket()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l01002">1002</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa58a1db344a23f3260fa1b1327ce15f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">size_type</a> <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of elements contained in the table. </p>
<dl class="section return"><dt>Returns</dt><dd>number of elements in the table. </dd></dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00778">778</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4bf673b10b69a549482652f34834bc80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Pred = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1hash__set.html">piranha::hash_set</a>&lt; T, Hash, Pred &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpiranha_1_1hash__set.html">hash_set</a>&lt; T, Hash, Pred &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap content. </p>
<p>Will use <code>std::swap</code> to swap hasher and equality predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>swap argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by swapping hasher or equality predicate via <code>std::swap</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__set_8hpp_source.html#l00979">979</a> of file <a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="hash__set_8hpp_source.html">hash_set.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 18 2015 21:06:04 for piranha by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9
</small></address>
</body>
</html>

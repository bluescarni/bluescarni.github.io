<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>piranha: piranha::series&lt; Cf, Key, Derived &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">piranha
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepiranha.html">piranha</a></li><li class="navelem"><a class="el" href="classpiranha_1_1series.html">series</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classpiranha_1_1series-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">piranha::series&lt; Cf, Key, Derived &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Series class.  
 <a href="classpiranha_1_1series.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="series_8hpp_source.html">series.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for piranha::series&lt; Cf, Key, Derived &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classpiranha_1_1series__inherit__graph.png" border="0" usemap="#piranha_1_1series_3_01_cf_00_01_key_00_01_derived_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="piranha_1_1series_3_01_cf_00_01_key_00_01_derived_01_4_inherit__map" id="piranha_1_1series_3_01_cf_00_01_key_00_01_derived_01_4_inherit__map">
<area shape="rect" id="node2" href="classpiranha_1_1series__operators.html" title="Series operators. " alt="" coords="5,5,173,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for piranha::series&lt; Cf, Key, Derived &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classpiranha_1_1series__coll__graph.png" border="0" usemap="#piranha_1_1series_3_01_cf_00_01_key_00_01_derived_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="piranha_1_1series_3_01_cf_00_01_key_00_01_derived_01_4_coll__map" id="piranha_1_1series_3_01_cf_00_01_key_00_01_derived_01_4_coll__map">
<area shape="rect" id="node2" href="classpiranha_1_1series__operators.html" title="Series operators. " alt="" coords="5,5,173,32"/><area shape="rect" id="node3" href="classpiranha_1_1symbol__set.html" title="Symbol set. " alt="" coords="197,5,336,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1af0f49cc902d64a77cbaea64f0a2d24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1af0f49cc902d64a77cbaea64f0a2d24"></a>
typedef <a class="el" href="classpiranha_1_1term.html">term</a>&lt; Cf, Key &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a1af0f49cc902d64a77cbaea64f0a2d24">term_type</a></td></tr>
<tr class="memdesc:a1af0f49cc902d64a77cbaea64f0a2d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for term type. <br /></td></tr>
<tr class="separator:a1af0f49cc902d64a77cbaea64f0a2d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd2e6c7089dee8f3d370eda2260013a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">container_type::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a3bd2e6c7089dee8f3d370eda2260013a">size_type</a></td></tr>
<tr class="memdesc:a3bd2e6c7089dee8f3d370eda2260013a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type.  <a href="#a3bd2e6c7089dee8f3d370eda2260013a">More...</a><br /></td></tr>
<tr class="separator:a3bd2e6c7089dee8f3d370eda2260013a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e56e9552fe250c2032580e2b7b9b722"><td class="memItemLeft" align="right" valign="top">typedef const_iterator_impl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a9e56e9552fe250c2032580e2b7b9b722">const_iterator</a></td></tr>
<tr class="memdesc:a9e56e9552fe250c2032580e2b7b9b722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator.  <a href="#a9e56e9552fe250c2032580e2b7b9b722">More...</a><br /></td></tr>
<tr class="separator:a9e56e9552fe250c2032580e2b7b9b722"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a17222371bab8534b2047c8c02ca8601d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17222371bab8534b2047c8c02ca8601d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a17222371bab8534b2047c8c02ca8601d">series</a> ()=default</td></tr>
<tr class="memdesc:a17222371bab8534b2047c8c02ca8601d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted default constructor. <br /></td></tr>
<tr class="separator:a17222371bab8534b2047c8c02ca8601d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052750279ee9bcabd6f700f1233af862"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a052750279ee9bcabd6f700f1233af862">series</a> (const <a class="el" href="classpiranha_1_1series.html">series</a> &amp;)=default</td></tr>
<tr class="memdesc:a052750279ee9bcabd6f700f1233af862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted copy constructor.  <a href="#a052750279ee9bcabd6f700f1233af862">More...</a><br /></td></tr>
<tr class="separator:a052750279ee9bcabd6f700f1233af862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f144843ddbe1f9b49ae6542496e83c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f144843ddbe1f9b49ae6542496e83c4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a3f144843ddbe1f9b49ae6542496e83c4">series</a> (<a class="el" href="classpiranha_1_1series.html">series</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a3f144843ddbe1f9b49ae6542496e83c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted move constructor. <br /></td></tr>
<tr class="separator:a3f144843ddbe1f9b49ae6542496e83c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c893768f55bb988d5cf85d172f0c196"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U  = series, generic_ctor_enabler&lt; T, U &gt;  = 0&gt; </td></tr>
<tr class="memitem:a4c893768f55bb988d5cf85d172f0c196"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a4c893768f55bb988d5cf85d172f0c196">series</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a4c893768f55bb988d5cf85d172f0c196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic constructor.  <a href="#a4c893768f55bb988d5cf85d172f0c196">More...</a><br /></td></tr>
<tr class="separator:a4c893768f55bb988d5cf85d172f0c196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb05a89eb377e24251cfd1ea355ccf9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcb05a89eb377e24251cfd1ea355ccf9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#afcb05a89eb377e24251cfd1ea355ccf9">~series</a> ()</td></tr>
<tr class="memdesc:afcb05a89eb377e24251cfd1ea355ccf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trivial destructor. <br /></td></tr>
<tr class="separator:afcb05a89eb377e24251cfd1ea355ccf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c380a3c64bcb9dbe6b850b41d005e06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html">series</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a3c380a3c64bcb9dbe6b850b41d005e06">operator=</a> (const <a class="el" href="classpiranha_1_1series.html">series</a> &amp;other)</td></tr>
<tr class="memdesc:a3c380a3c64bcb9dbe6b850b41d005e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-assignment operator.  <a href="#a3c380a3c64bcb9dbe6b850b41d005e06">More...</a><br /></td></tr>
<tr class="separator:a3c380a3c64bcb9dbe6b850b41d005e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1c7d1e03e7e06d130b2c34def58b40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb1c7d1e03e7e06d130b2c34def58b40"></a>
<a class="el" href="classpiranha_1_1series.html">series</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#adb1c7d1e03e7e06d130b2c34def58b40">operator=</a> (<a class="el" href="classpiranha_1_1series.html">series</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:adb1c7d1e03e7e06d130b2c34def58b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted move assignment operator. <br /></td></tr>
<tr class="separator:adb1c7d1e03e7e06d130b2c34def58b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899ea9bebd2f80f4378af24ea68e6102"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U  = series, generic_ctor_enabler&lt; T, U &gt;  = 0&gt; </td></tr>
<tr class="memitem:a899ea9bebd2f80f4378af24ea68e6102"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html">series</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a899ea9bebd2f80f4378af24ea68e6102">operator=</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a899ea9bebd2f80f4378af24ea68e6102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic assignment operator.  <a href="#a899ea9bebd2f80f4378af24ea68e6102">More...</a><br /></td></tr>
<tr class="separator:a899ea9bebd2f80f4378af24ea68e6102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae02a113d00a1cd291ac2d8052e1efd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html#a3bd2e6c7089dee8f3d370eda2260013a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#acae02a113d00a1cd291ac2d8052e1efd">size</a> () const </td></tr>
<tr class="memdesc:acae02a113d00a1cd291ac2d8052e1efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Series size.  <a href="#acae02a113d00a1cd291ac2d8052e1efd">More...</a><br /></td></tr>
<tr class="separator:acae02a113d00a1cd291ac2d8052e1efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d693909213b238270bd4687a196bbb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a6d693909213b238270bd4687a196bbb5">empty</a> () const </td></tr>
<tr class="memdesc:a6d693909213b238270bd4687a196bbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty test.  <a href="#a6d693909213b238270bd4687a196bbb5">More...</a><br /></td></tr>
<tr class="separator:a6d693909213b238270bd4687a196bbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04adb9b939dda140547a027e461a4384"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a04adb9b939dda140547a027e461a4384">is_single_coefficient</a> () const </td></tr>
<tr class="memdesc:a04adb9b939dda140547a027e461a4384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for single-coefficient series.  <a href="#a04adb9b939dda140547a027e461a4384">More...</a><br /></td></tr>
<tr class="separator:a04adb9b939dda140547a027e461a4384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac049565106ddee1881fedf6481de9458"><td class="memTemplParams" colspan="2">template&lt;bool Sign, typename T , insert_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac049565106ddee1881fedf6481de9458"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458">insert</a> (T &amp;&amp;<a class="el" href="classpiranha_1_1term.html">term</a>)</td></tr>
<tr class="memdesc:ac049565106ddee1881fedf6481de9458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert term.  <a href="#ac049565106ddee1881fedf6481de9458">More...</a><br /></td></tr>
<tr class="separator:ac049565106ddee1881fedf6481de9458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1924707f1dbc3c82284e48bdaf87f1"><td class="memTemplParams" colspan="2">template&lt;typename T , insert_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2d1924707f1dbc3c82284e48bdaf87f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a2d1924707f1dbc3c82284e48bdaf87f1">insert</a> (T &amp;&amp;<a class="el" href="classpiranha_1_1term.html">term</a>)</td></tr>
<tr class="memdesc:a2d1924707f1dbc3c82284e48bdaf87f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert generic term with <code>Sign = true</code>.  <a href="#a2d1924707f1dbc3c82284e48bdaf87f1">More...</a><br /></td></tr>
<tr class="separator:a2d1924707f1dbc3c82284e48bdaf87f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7999e7a1d36a9519ca4b373f8886ed40"><td class="memItemLeft" align="right" valign="top">Derived&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a7999e7a1d36a9519ca4b373f8886ed40">operator+</a> () const </td></tr>
<tr class="memdesc:a7999e7a1d36a9519ca4b373f8886ed40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity operator.  <a href="#a7999e7a1d36a9519ca4b373f8886ed40">More...</a><br /></td></tr>
<tr class="separator:a7999e7a1d36a9519ca4b373f8886ed40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6835fa85739cf3f53bea993964b3b80"><td class="memItemLeft" align="right" valign="top">Derived&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#af6835fa85739cf3f53bea993964b3b80">operator-</a> () const </td></tr>
<tr class="memdesc:af6835fa85739cf3f53bea993964b3b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negation operator.  <a href="#af6835fa85739cf3f53bea993964b3b80">More...</a><br /></td></tr>
<tr class="separator:af6835fa85739cf3f53bea993964b3b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dce8005ee4919ce2f68b508e6292118"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a3dce8005ee4919ce2f68b508e6292118">negate</a> ()</td></tr>
<tr class="memdesc:a3dce8005ee4919ce2f68b508e6292118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate series in-place.  <a href="#a3dce8005ee4919ce2f68b508e6292118">More...</a><br /></td></tr>
<tr class="separator:a3dce8005ee4919ce2f68b508e6292118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ddd34099884d45825b72155d1d6e48"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U  = Derived&gt; </td></tr>
<tr class="memitem:a76ddd34099884d45825b72155d1d6e48"><td class="memTemplItemLeft" align="right" valign="top">pow_ret_type&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a76ddd34099884d45825b72155d1d6e48">pow</a> (const T &amp;x) const </td></tr>
<tr class="memdesc:a76ddd34099884d45825b72155d1d6e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponentiation.  <a href="#a76ddd34099884d45825b72155d1d6e48">More...</a><br /></td></tr>
<tr class="separator:a76ddd34099884d45825b72155d1d6e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97624cbcc7139b6f70682d908f759656"><td class="memItemLeft" align="right" valign="top">Derived&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a97624cbcc7139b6f70682d908f759656">apply_cf_functor</a> (std::function&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>(const typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a> &amp;)&gt; f) const </td></tr>
<tr class="memdesc:a97624cbcc7139b6f70682d908f759656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply functor to single-coefficient series.  <a href="#a97624cbcc7139b6f70682d908f759656">More...</a><br /></td></tr>
<tr class="separator:a97624cbcc7139b6f70682d908f759656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816a2a0ef41921df71a9c0f518ddd653"><td class="memTemplParams" colspan="2">template&lt;typename Series  = Derived&gt; </td></tr>
<tr class="memitem:a816a2a0ef41921df71a9c0f518ddd653"><td class="memTemplItemLeft" align="right" valign="top">partial_type&lt; Series &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a816a2a0ef41921df71a9c0f518ddd653">partial</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a816a2a0ef41921df71a9c0f518ddd653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial derivative.  <a href="#a816a2a0ef41921df71a9c0f518ddd653">More...</a><br /></td></tr>
<tr class="separator:a816a2a0ef41921df71a9c0f518ddd653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfeae53f7a213c8aa8c29e9d3f65e4d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html#a9e56e9552fe250c2032580e2b7b9b722">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#acfeae53f7a213c8aa8c29e9d3f65e4d0">begin</a> () const </td></tr>
<tr class="memdesc:acfeae53f7a213c8aa8c29e9d3f65e4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin iterator.  <a href="#acfeae53f7a213c8aa8c29e9d3f65e4d0">More...</a><br /></td></tr>
<tr class="separator:acfeae53f7a213c8aa8c29e9d3f65e4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08dd51abc504168912f97e7569d7fb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html#a9e56e9552fe250c2032580e2b7b9b722">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#af08dd51abc504168912f97e7569d7fb0">end</a> () const </td></tr>
<tr class="memdesc:af08dd51abc504168912f97e7569d7fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">End iterator.  <a href="#af08dd51abc504168912f97e7569d7fb0">More...</a><br /></td></tr>
<tr class="separator:af08dd51abc504168912f97e7569d7fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2bc7a506a97ab87d1013abafec409c"><td class="memItemLeft" align="right" valign="top">Derived&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a4c2bc7a506a97ab87d1013abafec409c">filter</a> (std::function&lt; bool(const std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, Derived &gt; &amp;)&gt; func) const </td></tr>
<tr class="memdesc:a4c2bc7a506a97ab87d1013abafec409c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Term filtering.  <a href="#a4c2bc7a506a97ab87d1013abafec409c">More...</a><br /></td></tr>
<tr class="separator:a4c2bc7a506a97ab87d1013abafec409c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2be8f9cd018cea990d8d33ff74b34e"><td class="memItemLeft" align="right" valign="top">Derived&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a4d2be8f9cd018cea990d8d33ff74b34e">transform</a> (std::function&lt; std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, Derived &gt;(const std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, Derived &gt; &amp;)&gt; func) const </td></tr>
<tr class="memdesc:a4d2be8f9cd018cea990d8d33ff74b34e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Term transformation.  <a href="#a4d2be8f9cd018cea990d8d33ff74b34e">More...</a><br /></td></tr>
<tr class="separator:a4d2be8f9cd018cea990d8d33ff74b34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa040344d49db37a9a4bf9d2c32c7221b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Series  = series&gt; </td></tr>
<tr class="memitem:aa040344d49db37a9a4bf9d2c32c7221b"><td class="memTemplItemLeft" align="right" valign="top">eval_type&lt; Series, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#aa040344d49db37a9a4bf9d2c32c7221b">evaluate</a> (const std::unordered_map&lt; std::string, T &gt; &amp;dict) const </td></tr>
<tr class="memdesc:aa040344d49db37a9a4bf9d2c32c7221b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation.  <a href="#aa040344d49db37a9a4bf9d2c32c7221b">More...</a><br /></td></tr>
<tr class="separator:aa040344d49db37a9a4bf9d2c32c7221b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92d728b975d0dfda12ad7ddb168c984"><td class="memItemLeft" align="right" valign="top">Derived&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ad92d728b975d0dfda12ad7ddb168c984">trim</a> () const </td></tr>
<tr class="memdesc:ad92d728b975d0dfda12ad7ddb168c984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim.  <a href="#ad92d728b975d0dfda12ad7ddb168c984">More...</a><br /></td></tr>
<tr class="separator:ad92d728b975d0dfda12ad7ddb168c984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fc18640bdfa5d96217434a533e0567"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ad2fc18640bdfa5d96217434a533e0567">print_tex</a> (std::ostream &amp;os) const </td></tr>
<tr class="memdesc:ad2fc18640bdfa5d96217434a533e0567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print in TeX mode.  <a href="#ad2fc18640bdfa5d96217434a533e0567">More...</a><br /></td></tr>
<tr class="separator:ad2fc18640bdfa5d96217434a533e0567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7e68abc23ec8d71664d463cf83c8e3"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a4f7e68abc23ec8d71664d463cf83c8e3">hash</a> () const </td></tr>
<tr class="memdesc:a4f7e68abc23ec8d71664d463cf83c8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash value.  <a href="#a4f7e68abc23ec8d71664d463cf83c8e3">More...</a><br /></td></tr>
<tr class="separator:a4f7e68abc23ec8d71664d463cf83c8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3303c0cfd2399b9f71570f43e85f8ee3"><td class="memTemplParams" colspan="2">template&lt;typename T  = Derived, is_identical_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3303c0cfd2399b9f71570f43e85f8ee3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a3303c0cfd2399b9f71570f43e85f8ee3">is_identical</a> (const Derived &amp;other) const </td></tr>
<tr class="memdesc:a3303c0cfd2399b9f71570f43e85f8ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for identical series.  <a href="#a3303c0cfd2399b9f71570f43e85f8ee3">More...</a><br /></td></tr>
<tr class="separator:a3303c0cfd2399b9f71570f43e85f8ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4a9e7100d9842f3dbc6e7fdd04ee49"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a7c4a9e7100d9842f3dbc6e7fdd04ee49">get_symbol_set</a> () const </td></tr>
<tr class="memdesc:a7c4a9e7100d9842f3dbc6e7fdd04ee49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol set getter.  <a href="#a7c4a9e7100d9842f3dbc6e7fdd04ee49">More...</a><br /></td></tr>
<tr class="separator:a7c4a9e7100d9842f3dbc6e7fdd04ee49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3752460cc7a4c4cc0bea3330b31bcc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ac3752460cc7a4c4cc0bea3330b31bcc9">set_symbol_set</a> (const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a> &amp;args)</td></tr>
<tr class="memdesc:ac3752460cc7a4c4cc0bea3330b31bcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol set setter.  <a href="#ac3752460cc7a4c4cc0bea3330b31bcc9">More...</a><br /></td></tr>
<tr class="separator:ac3752460cc7a4c4cc0bea3330b31bcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Table-querying methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods to query the properties of the internal container used to store the terms. </p>
</div></td></tr>
<tr class="memitem:a57b8b94d7b67c5e91ec9bab039a37f73"><td class="memItemLeft" align="right" valign="top">sparsity_info_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a57b8b94d7b67c5e91ec9bab039a37f73">table_sparsity</a> () const </td></tr>
<tr class="memdesc:a57b8b94d7b67c5e91ec9bab039a37f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table sparsity.  <a href="#a57b8b94d7b67c5e91ec9bab039a37f73">More...</a><br /></td></tr>
<tr class="separator:a57b8b94d7b67c5e91ec9bab039a37f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc5c9b27d9dbf3cdca9102eabb09003"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a8cc5c9b27d9dbf3cdca9102eabb09003">table_load_factor</a> () const </td></tr>
<tr class="memdesc:a8cc5c9b27d9dbf3cdca9102eabb09003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table load factor.  <a href="#a8cc5c9b27d9dbf3cdca9102eabb09003">More...</a><br /></td></tr>
<tr class="separator:a8cc5c9b27d9dbf3cdca9102eabb09003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259a3dfca6849c5097246a4a0235cc61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiranha_1_1series.html#a3bd2e6c7089dee8f3d370eda2260013a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a259a3dfca6849c5097246a4a0235cc61">table_bucket_count</a> () const </td></tr>
<tr class="memdesc:a259a3dfca6849c5097246a4a0235cc61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table bucket count.  <a href="#a259a3dfca6849c5097246a4a0235cc61">More...</a><br /></td></tr>
<tr class="separator:a259a3dfca6849c5097246a4a0235cc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae7da3b838cc92a235785ae4e339a1e97"><td class="memTemplParams" colspan="2">template&lt;typename T  = Derived, is_identical_enabler&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae7da3b838cc92a235785ae4e339a1e97"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ae7da3b838cc92a235785ae4e339a1e97">clear_pow_cache</a> ()</td></tr>
<tr class="memdesc:ae7da3b838cc92a235785ae4e339a1e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the internal cache of natural powers.  <a href="#ae7da3b838cc92a235785ae4e339a1e97">More...</a><br /></td></tr>
<tr class="separator:ae7da3b838cc92a235785ae4e339a1e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee2cef7972c1ed1a410351c9f3e175e"><td class="memTemplParams" colspan="2">template&lt;typename F , typename Series  = Derived, custom_partial_enabler&lt; F, Series &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5ee2cef7972c1ed1a410351c9f3e175e"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a5ee2cef7972c1ed1a410351c9f3e175e">register_custom_derivative</a> (const std::string &amp;name, F func)</td></tr>
<tr class="memdesc:a5ee2cef7972c1ed1a410351c9f3e175e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register custom partial derivative.  <a href="#a5ee2cef7972c1ed1a410351c9f3e175e">More...</a><br /></td></tr>
<tr class="separator:a5ee2cef7972c1ed1a410351c9f3e175e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041b2099313fa16a9b13d55ce7c0d930"><td class="memTemplParams" colspan="2">template&lt;typename Series  = Derived, typename Partial  = partial_type&lt;Series&gt;&gt; </td></tr>
<tr class="memitem:a041b2099313fa16a9b13d55ce7c0d930"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a041b2099313fa16a9b13d55ce7c0d930">unregister_custom_derivative</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a041b2099313fa16a9b13d55ce7c0d930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister custom partial derivative.  <a href="#a041b2099313fa16a9b13d55ce7c0d930">More...</a><br /></td></tr>
<tr class="separator:a041b2099313fa16a9b13d55ce7c0d930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40680bb3e8f2801b3754f0b03abb0633"><td class="memTemplParams" colspan="2">template&lt;typename Series  = Derived, typename Partial  = partial_type&lt;Series&gt;&gt; </td></tr>
<tr class="memitem:a40680bb3e8f2801b3754f0b03abb0633"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a40680bb3e8f2801b3754f0b03abb0633">unregister_all_custom_derivatives</a> ()</td></tr>
<tr class="memdesc:a40680bb3e8f2801b3754f0b03abb0633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister all custom partial derivatives.  <a href="#a40680bb3e8f2801b3754f0b03abb0633">More...</a><br /></td></tr>
<tr class="separator:a40680bb3e8f2801b3754f0b03abb0633"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ad2bf73c31b49054d58efbc11b34883dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2bf73c31b49054d58efbc11b34883dc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#ad2bf73c31b49054d58efbc11b34883dc">container_type</a> = <a class="el" href="classpiranha_1_1hash__set.html">hash_set</a>&lt; <a class="el" href="classpiranha_1_1series.html#a1af0f49cc902d64a77cbaea64f0a2d24">term_type</a>, detail::term_hasher&lt; <a class="el" href="classpiranha_1_1series.html#a1af0f49cc902d64a77cbaea64f0a2d24">term_type</a> &gt;&gt;</td></tr>
<tr class="memdesc:ad2bf73c31b49054d58efbc11b34883dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container type for terms. <br /></td></tr>
<tr class="separator:ad2bf73c31b49054d58efbc11b34883dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4c1d33d3d9ed04b935e3024db2e46f04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c1d33d3d9ed04b935e3024db2e46f04"></a>
<a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a4c1d33d3d9ed04b935e3024db2e46f04">m_symbol_set</a></td></tr>
<tr class="memdesc:a4c1d33d3d9ed04b935e3024db2e46f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol set. <br /></td></tr>
<tr class="separator:a4c1d33d3d9ed04b935e3024db2e46f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ac93f383a79c3325197d6a951e9dd5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68ac93f383a79c3325197d6a951e9dd5"></a>
<a class="el" href="classpiranha_1_1series.html#ad2bf73c31b49054d58efbc11b34883dc">container_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a68ac93f383a79c3325197d6a951e9dd5">m_container</a></td></tr>
<tr class="memdesc:a68ac93f383a79c3325197d6a951e9dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terms container. <br /></td></tr>
<tr class="separator:a68ac93f383a79c3325197d6a951e9dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af58136e1ff905ab83742c234f54d35ef"><td class="memTemplParams" colspan="2"><a class="anchor" id="af58136e1ff905ab83742c234f54d35ef"></a>
template&lt;typename Term2 , typename Derived2 &gt; </td></tr>
<tr class="memitem:af58136e1ff905ab83742c234f54d35ef"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename Term2::cf_type, Derived2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>detail::pair_from_term</b> (const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a> &amp;, const Term2 &amp;)</td></tr>
<tr class="separator:af58136e1ff905ab83742c234f54d35ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4b6250352b1657f36a0f90e021b6ce"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpiranha_1_1series.html#a9f4b6250352b1657f36a0f90e021b6ce">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classpiranha_1_1series.html">series</a> &amp;s)</td></tr>
<tr class="memdesc:a9f4b6250352b1657f36a0f90e021b6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded stream operator for <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>.  <a href="#a9f4b6250352b1657f36a0f90e021b6ce">More...</a><br /></td></tr>
<tr class="separator:a9f4b6250352b1657f36a0f90e021b6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Cf, typename Key, typename Derived&gt;<br />
class piranha::series&lt; Cf, Key, Derived &gt;</h3>

<p>Series class. </p>
<p>This class contains the arithmetic and comparison operator overloads for <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a> instances via the parent class <a class="el" href="classpiranha_1_1series__operators.html" title="Series operators. ">piranha::series_operators</a>.</p>
<h2>Type requirements</h2>
<ul>
<li><code>Cf</code> and <code>Key</code> must be suitable for use in <a class="el" href="classpiranha_1_1term.html" title="Term class. ">piranha::term</a>.</li>
<li><code>Derived</code> must derive from <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a> of <code>Cf</code>, <code>Key</code> and <code>Derived</code>.</li>
<li><code>Derived</code> must satisfy <a class="el" href="classpiranha_1_1is__series.html" title="Type trait to detect series types. ">piranha::is_series</a>.</li>
<li><code>Derived</code> must satisfy <a class="el" href="structpiranha_1_1is__container__element.html" title="Type trait for well-behaved container elements. ">piranha::is_container_element</a>.</li>
</ul>
<h2>Exception safety guarantee</h2>
<p>Unless otherwise specified, this class provides the strong exception safety guarantee for all operations.</p>
<h2>Move semantics</h2>
<p>Moved-from series are left in a state equivalent to an empty series.</p>
<h2>Serialization</h2>
<p>This class supports serialization if its term type does.</p>
<dl class="section author"><dt>Author</dt><dd>Francesco Biscani (<a href="#" onclick="location.href='mai'+'lto:'+'blu'+'es'+'car'+'ni'+'@gm'+'ai'+'l.c'+'om'; return false;">blues<span style="display: none;">.nosp@m.</span>carn<span style="display: none;">.nosp@m.</span>i@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a>) </dd></dl>

<p>Definition at line <a class="el" href="series__fwd_8hpp_source.html#l00037">37</a> of file <a class="el" href="series__fwd_8hpp_source.html">series_fwd.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a9e56e9552fe250c2032580e2b7b9b722"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const_iterator_impl <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::<a class="el" href="classpiranha_1_1series.html#a9e56e9552fe250c2032580e2b7b9b722">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const iterator. </p>
<p>Iterator type that can be used to iterate over the terms of the series. The object returned upon dereferentiation is an <code>std::pair</code> in which the first element is a copy of the coefficient of the term, the second element a single-term instance of <code>Derived</code> constructed from the term's key and a unitary coefficient.</p>
<p>This iterator is an input iterator which additionally offers the multi-pass guarantee.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpiranha_1_1series.html#acfeae53f7a213c8aa8c29e9d3f65e4d0" title="Begin iterator. ">piranha::series::begin()</a> and <a class="el" href="classpiranha_1_1series.html#af08dd51abc504168912f97e7569d7fb0" title="End iterator. ">piranha::series::end()</a>. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l01801">1801</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3bd2e6c7089dee8f3d370eda2260013a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591">container_type::size_type</a> <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::<a class="el" href="classpiranha_1_1series.html#a3bd2e6c7089dee8f3d370eda2260013a">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size type. </p>
<p>Used to represent the number of terms in the series. Equivalent to <a class="el" href="classpiranha_1_1hash__set.html#a35554d84e1181e8f6dff01fe3500e591" title="Size type. ">piranha::hash_set::size_type</a>. </p>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l01789">1789</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a052750279ee9bcabd6f700f1233af862"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::<a class="el" href="classpiranha_1_1series.html">series</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, Derived &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defaulted copy constructor. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the copy constructor of <a class="el" href="classpiranha_1_1hash__set.html" title="Hash set. ">piranha::hash_set</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c893768f55bb988d5cf85d172f0c196"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U  = series, generic_ctor_enabler&lt; T, U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::<a class="el" href="classpiranha_1_1series.html">series</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic constructor. </p>
<dl class="section note"><dt>Note</dt><dd>This constructor is enabled only if <code>T</code> does not derive from the calling <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a> instance and the algorithm outlined below is supported by the involved types.</dd></dl>
<p>The generic construction algorithm works as follows:</p><ul>
<li>if <code>T</code> is a series with the same series recursion index as <code>this</code>, then the symbol set of <code>x</code> is copied into <code>this</code> and all terms from <code>x</code> are inserted into <code>this</code>. The terms of <code>x</code> are converted to <code>term_type</code> via the binary constructor of <a class="el" href="classpiranha_1_1term.html" title="Term class. ">piranha::term</a>, and the keys of <code>x</code> are converted to the key type of <code>term_type</code> via a converting constructor, if available (see <a class="el" href="classpiranha_1_1key__is__convertible.html" title="Detect if a key type is convertible to another key type. ">piranha::key_is_convertible</a>);</li>
<li>else, if the recursion index of <code>T</code> is less than the recursion index of <code>this:</code> <ul>
<li><code>x</code> is used to construct a new term as follows:<ul>
<li><code>x</code> is used to construct a coefficient via <a class="el" href="namespacepiranha.html#a8740bbc3e472de1f0acebc18c416c35d" title="Generic conversion function. ">piranha::convert_to</a>;</li>
<li>an empty arguments set will be used to construct a key;</li>
<li>coefficient and key are used to construct the new term instance;</li>
</ul>
</li>
<li>the new term is inserted into <code>this</code>;</li>
</ul>
</li>
<li>otherwise, the constructor is disabled.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>object to construct from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the copy assignment operator of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>the construction of a coefficient from <code>x</code> or of a key from <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>the construction of a term from a coefficient-key pair,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l01840">1840</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a97624cbcc7139b6f70682d908f759656"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::apply_cf_functor </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>(const typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply functor to single-coefficient series. </p>
<p>This method can be called successfully only on single-coefficient series.</p>
<p>If the series is empty, the return value will be a series with single term and unitary key in which the coefficient is the result of applying the functor <code>f</code> on a coefficient instance constructed from the integral constant "0".</p>
<p>If the series has a single term with unitary key, the return value will be a series with single term and unitary key in which the coefficient is the result of applying the functor <code>f</code> to the only coefficient of <code>this</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>coefficient functor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a series constructed via the application of <code>f</code> to a coefficient instance as described above.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the series is not single-coefficient. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the call operator of <code>f</code>,</li>
<li>construction of coefficient, key and term instances,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li><a class="el" href="classpiranha_1_1series.html#a04adb9b939dda140547a027e461a4384" title="Test for single-coefficient series. ">is_single_coefficient()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02151">2151</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acfeae53f7a213c8aa8c29e9d3f65e4d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html#a9e56e9552fe250c2032580e2b7b9b722">const_iterator</a> <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin iterator. </p>
<p>Return an iterator to the first term of the series. The returned iterator will provide, when dereferenced, an <code>std::pair</code> in which the first element is a copy of the coefficient of the term, whereas the second element is a single-term instance of <code>Derived</code> built from the term's key and a unitary coefficient.</p>
<p>Note that terms are stored unordered in the series, hence it is not defined which particular term will be returned by calling this method. The only guarantee is that the iterator can be used to transverse all the series' terms until <a class="el" href="classpiranha_1_1series.html#af08dd51abc504168912f97e7569d7fb0" title="End iterator. ">piranha::series::end()</a> is eventually reached.</p>
<p>Calling any non-const method on the series will invalidate the iterators obtained via <a class="el" href="classpiranha_1_1series.html#acfeae53f7a213c8aa8c29e9d3f65e4d0" title="Begin iterator. ">piranha::series::begin()</a> and <a class="el" href="classpiranha_1_1series.html#af08dd51abc504168912f97e7569d7fb0" title="End iterator. ">piranha::series::end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the first term of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>construction and assignment of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>construction of term, coefficient and key instances. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02287">2287</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae7da3b838cc92a235785ae4e339a1e97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename T  = Derived, is_identical_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::clear_pow_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the internal cache of natural powers. </p>
<p>This method can be used to clear the cache of natural powers of series maintained by <a class="el" href="classpiranha_1_1series.html#a76ddd34099884d45825b72155d1d6e48" title="Exponentiation. ">piranha::series::pow()</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by threading primitives. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02125">2125</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d693909213b238270bd4687a196bbb5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty test. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <a class="el" href="classpiranha_1_1series.html#acae02a113d00a1cd291ac2d8052e1efd" title="Series size. ">size()</a> is nonzero, <code>false</code> otherwise. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l01903">1903</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af08dd51abc504168912f97e7569d7fb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html#a9e56e9552fe250c2032580e2b7b9b722">const_iterator</a> <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End iterator. </p>
<p>Return an iterator one past the last term of the series. See the documentation of <a class="el" href="classpiranha_1_1series.html#acfeae53f7a213c8aa8c29e9d3f65e4d0" title="Begin iterator. ">piranha::series::begin()</a> on how the returned iterator can be used.</p>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the end of the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>construction and assignment of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>construction of term, coefficient and key instances. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02308">2308</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa040344d49db37a9a4bf9d2c32c7221b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename Series  = series&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">eval_type&lt;Series,T&gt; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; std::string, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dict</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if:<ul>
<li>both the coefficient and the key types are evaluable,</li>
<li>the evaluated types are suitable for use in <a class="el" href="namespacepiranha_1_1math.html#a904f85d9a1ef8c95384bcb89ff0795e7" title="Multiply-accumulate. ">piranha::math::multiply_accumulate()</a>,</li>
<li>the return type is constructible from <code>int</code>.</li>
</ul>
</dd></dl>
<p>Series evaluation starts with a zero-initialised instance of the return type, which is determined according to the evaluation types of coefficient and key. The return value accumulates the evaluation of all terms in the series via the product of the evaluations of the coefficient-key pairs in each term. The input dictionary <code>dict</code> specifies with which value each symbolic quantity will be evaluated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dict</td><td>dictionary of that will be used for evaluation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>evaluation of the series according to the evaluation dictionary <code>dict</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>coefficient and key evaluation,</li>
<li>insertion operations on <code>std::unordered_map</code>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#a904f85d9a1ef8c95384bcb89ff0795e7" title="Multiply-accumulate. ">piranha::math::multiply_accumulate()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02409">2409</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4c2bc7a506a97ab87d1013abafec409c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(const std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, Derived &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Term filtering. </p>
<p>This method will apply the functor <code>func</code> to each term in the series, and produce a return series containing all terms in <code>this</code> for which <code>func</code> returns <code>true</code>. Terms are passed to <code>func</code> in the format resulting from dereferencing the iterators obtained via <a class="el" href="classpiranha_1_1series.html#acfeae53f7a213c8aa8c29e9d3f65e4d0" title="Begin iterator. ">piranha::series::begin()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>filtering functor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>filtered series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the call operator of <code>func</code>,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>the assignment operator of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>term, coefficient, key construction. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02334">2334</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c4a9e7100d9842f3dbc6e7fdd04ee49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a>&amp; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::get_symbol_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Symbol set getter. </p>
<dl class="section return"><dt>Returns</dt><dd>const reference to the <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a> associated to the series. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02586">2586</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f7e68abc23ec8d71664d463cf83c8e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::hash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hash value. </p>
<p>The hash value for a series is zero if the series is empty, otherwise it is computed by adding the hash values of all terms. This ensures that two identical series in which the terms are stored in different order still produce the same hash value.</p>
<p>Note, however, that the arguments of the series are not considered in the hash value and that, in general, two series that compare equal according to <a class="el" href="classpiranha_1_1series__operators.html#a685319221f4aba841a9cbf9d1980b7f8" title="Equality operator involving piranha::series. ">operator==()</a> will <b>not</b> have the same hash value (as the equality operator merges the arguments of two series before actually performing the comparison). Instead of <a class="el" href="classpiranha_1_1series__operators.html#a685319221f4aba841a9cbf9d1980b7f8" title="Equality operator involving piranha::series. ">operator==()</a>, <a class="el" href="classpiranha_1_1series.html#a3303c0cfd2399b9f71570f43e85f8ee3" title="Check for identical series. ">is_identical()</a> should be used for storing series as keys in associative containers.</p>
<dl class="section return"><dt>Returns</dt><dd>a hash value for the series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by computing the hash of a term. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02554">2554</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac049565106ddee1881fedf6481de9458"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<div class="memtemplate">
template&lt;bool Sign, typename T , insert_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>term</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert term. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the decay type of <code>T</code> is <a class="el" href="classpiranha_1_1series.html#a1af0f49cc902d64a77cbaea64f0a2d24" title="Alias for term type. ">piranha::series::term_type</a>.</dd></dl>
<p>This method will insert <code>term</code> into the series using internally <a class="el" href="classpiranha_1_1hash__set.html#a1932a69f1c81715ad76a182f7eca9d9f" title="Insert element. ">piranha::hash_set::insert</a>.</p>
<p>The insertion algorithm proceeds as follows:</p><ul>
<li>if the term is not compatible for insertion, an <code>std::invalid_argument</code> exception is thrown;</li>
<li>if the term is ignorable, the method will return without performing any insertion;</li>
<li>if the term is already in the series, then:<ul>
<li>its coefficient is added (if <code>Sign</code> is <code>true</code>) or subtracted (if <code>Sign</code> is <code>false</code>) to the existing term's coefficient;</li>
<li>if, after the addition/subtraction the existing term is ignorable, it will be erased;</li>
</ul>
</li>
<li>else:<ul>
<li>the term is inserted into the term container and, if <code>Sign</code> is <code>false</code>, its coefficient is negated.</li>
</ul>
</li>
</ul>
<p>After any modification to an existing term in the series (e.g., via insertion with negative <code>Sign</code> or via in-place addition or subtraction of existing coefficients), the term will be checked again for compatibility and ignorability, and, in case the term has become incompatible or ignorable, it will be erased from the series.</p>
<p>The exception safety guarantee upon insertion is that the series will be left in an undefined but valid state. Such a guarantee relies on the fact that the addition/subtraction and negation methods of the coefficient type will leave the coefficient in a valid (possibly undefined) state in face of exceptions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">term</td><td>term to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1hash__set.html#a1932a69f1c81715ad76a182f7eca9d9f" title="Insert element. ">piranha::hash_set::insert()</a>,</li>
<li><a class="el" href="classpiranha_1_1hash__set.html#a455c154b0614dc4d86112550ed3e4346" title="Find element. ">piranha::hash_set::find()</a>,</li>
<li><a class="el" href="classpiranha_1_1hash__set.html#a02e4d798ba7678f8874e5ca09696feed" title="Erase element. ">piranha::hash_set::erase()</a>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#a7ec2303772eab00a1ca75c11106c60b9" title="In-place negation. ">piranha::math::negate()</a>, in-place addition/subtraction on coefficient types. </li>
</ul>
</td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>term</code> is incompatible. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l01957">1957</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d1924707f1dbc3c82284e48bdaf87f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename T , insert_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>term</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert generic term with <code>Sign = true</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the decay type of <code>T</code> is <a class="el" href="classpiranha_1_1series.html#a1af0f49cc902d64a77cbaea64f0a2d24" title="Alias for term type. ">piranha::series::term_type</a>.</dd></dl>
<p>Convenience wrapper for the generic <a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a> method, with <code>Sign</code> set to <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">term</td><td>term to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by generic <a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l01973">1973</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3303c0cfd2399b9f71570f43e85f8ee3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename T  = Derived, is_identical_enabler&lt; T &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::is_identical </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for identical series. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <code>Derived</code> is equality-comparable.</dd></dl>
<p>This method will return <code>true</code> if the symbol sets of <code>this</code> and <code>other</code> are the same, and <code>other == *this</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>argument for the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>this</code> and <code>other</code> are identical, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the comparison operator of <code>Derived</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02578">2578</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a04adb9b939dda140547a027e461a4384"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::is_single_coefficient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for single-coefficient series. </p>
<p>A series is considered to be <em>single-coefficient</em> when it is symbolically equivalent to a coefficient. That is, the series is either empty (in which case it is considered to be equivalent to a coefficient constructed from zero) or consisting of a single term with unitary key (in which case the series is considered equivalent to its only coefficient).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> in case of single-coefficient series, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the <code>is_unitary()</code> method of the key type. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l01918">1918</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3dce8005ee4919ce2f68b508e6292118"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::negate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negate series in-place. </p>
<p>This method will call <a class="el" href="namespacepiranha_1_1math.html#a7ec2303772eab00a1ca75c11106c60b9" title="In-place negation. ">math::negate()</a> on the coefficients of all terms. In case of exceptions, the basic exception safety guarantee is provided.</p>
<p>If any term becomes ignorable or incompatible after negation, it will be erased from the series.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="namespacepiranha_1_1math.html#a7ec2303772eab00a1ca75c11106c60b9" title="In-place negation. ">math::negate()</a> on the coefficient type. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02010">2010</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7999e7a1d36a9519ca4b373f8886ed40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::operator+ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identity operator. </p>
<dl class="section return"><dt>Returns</dt><dd>copy of <code>this</code>, cast to <code>Derived</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the copy constructor. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l01983">1983</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6835fa85739cf3f53bea993964b3b80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negation operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a copy of <code>this</code> on which <a class="el" href="classpiranha_1_1series.html#a3dce8005ee4919ce2f68b508e6292118" title="Negate series in-place. ">negate()</a> has been called.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="classpiranha_1_1series.html#a3dce8005ee4919ce2f68b508e6292118" title="Negate series in-place. ">negate()</a>,</li>
<li>the copy constructor of <code>Derived</code>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l01995">1995</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3c380a3c64bcb9dbe6b850b41d005e06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html">series</a>&amp; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>assignment argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the copy constructor. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l01862">1862</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a899ea9bebd2f80f4378af24ea68e6102"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U  = series, generic_ctor_enabler&lt; T, U &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html">series</a>&amp; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic assignment operator. </p>
<dl class="section note"><dt>Note</dt><dd>This operator is enabled only if the generic constructor from <code>x</code> is enabled.</dd></dl>
<p>Generic assignment is equivalent to assignment to a <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a> constructed via the generic constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>assignment argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the generic constructor. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l01887">1887</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a816a2a0ef41921df71a9c0f518ddd653"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename Series  = Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">partial_type&lt;Series&gt; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::partial </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial derivative. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if the coefficient and key are differentiable (i.e., they satisfy the <a class="el" href="classpiranha_1_1is__differentiable.html" title="Type trait for differentiable types. ">piranha::is_differentiable</a> and <a class="el" href="classpiranha_1_1key__is__differentiable.html" title="Type trait to detect differentiable keys. ">piranha::key_is_differentiable</a> type traits), and if the arithmetic operations needed to compute the partial derivative are supported by all the involved types.</dd></dl>
<p>This method will return the partial derivative of <code>this</code> with respect to the variable called <code>name</code>. The method will construct the return value from the output of the differentiation methods of coefficient and key, and via arithmetic and/or term insertion operations.</p>
<p>Note that, contrary to the specialisation of <a class="el" href="namespacepiranha_1_1math.html#ac3959494f64044823fd4c4545a5f3e4a" title="Partial derivative. ">piranha::math::partial()</a> for series types, this method will not take into account custom derivatives registered via <a class="el" href="classpiranha_1_1series.html#a5ee2cef7972c1ed1a410351c9f3e175e" title="Register custom partial derivative. ">piranha::series::register_custom_derivative()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of the argument with respect to which the derivative will be calculated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial derivative of <code>this</code> with respect to the symbol named <code>name</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the differentiation methods of coefficient and key,</li>
<li>term construction and insertion,</li>
<li>arithmetic operations on the involved types,</li>
<li>construction of the return type. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02191">2191</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a76ddd34099884d45825b72155d1d6e48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U  = Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pow_ret_type&lt;T,U&gt; <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::pow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exponentiation. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if:<ul>
<li>the coefficient type is exponentiable to the power of <code>x</code>, and the return type is the coefficient type itself,</li>
<li><code>T</code> can be used as argument for <a class="el" href="namespacepiranha_1_1math.html#a00db2c62bd93a48258dd8545c6fb468c" title="Zero test. ">piranha::math::is_zero()</a> and <a class="el" href="namespacepiranha.html#a712714b1e1348f73ec01687d5d5c9b2d" title="Safe cast. ">piranha::safe_cast()</a> to <a class="el" href="namespacepiranha.html#a236e3b8e7d5b78d00fcdc5de941e9f4b" title="Alias for piranha::mp_integer with default bit size. ">piranha::integer</a>,</li>
<li><code>Derived</code> is multipliable and the result of the multiplication is <code>Derived</code>,</li>
<li>the <a class="el" href="classpiranha_1_1series.html#a3303c0cfd2399b9f71570f43e85f8ee3" title="Check for identical series. ">is_identical()</a> method can be called on <code>Derived</code>.</li>
</ul>
</dd></dl>
<p>Return <code>this</code> raised to the <code>x</code>-th power. The exponentiation algorithm proceeds as follows:</p><ul>
<li>if the series is single-coefficient, a call to <a class="el" href="classpiranha_1_1series.html#a97624cbcc7139b6f70682d908f759656" title="Apply functor to single-coefficient series. ">apply_cf_functor()</a> is attempted, using a functor that calls <a class="el" href="namespacepiranha_1_1math.html#afbd1041a6f6d37325b55a66b7a84c016" title="Exponentiation. ">piranha::math::pow()</a> on the coefficient. Otherwise, the algorithm proceeds;</li>
<li>if <code>x</code> is zero (as established by <a class="el" href="namespacepiranha_1_1math.html#a00db2c62bd93a48258dd8545c6fb468c" title="Zero test. ">piranha::math::is_zero()</a>), a series with a single term with unitary key and coefficient constructed from the integer numeral "1" is returned (i.e., any series raised to the power of zero is 1 - including empty series);</li>
<li>if <code>x</code> represents a non-negative integral value, the return value is constructed via repeated multiplications;</li>
<li>otherwise, an exception will be raised.</li>
</ul>
<p>An internal thread-safe cache of natural powers of series is maintained in order to improve performance during, e.g., substitution operations. This cache can be cleared with <a class="el" href="classpiranha_1_1series.html#ae7da3b838cc92a235785ae4e339a1e97" title="Clear the internal cache of natural powers. ">clear_pow_cache()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>exponent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>this</code> raised to the power of <code>x</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if exponentiation is computed via repeated series multiplications and <code>x</code> does not represent a non-negative integer. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>series, term, coefficient and key construction,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li><a class="el" href="classpiranha_1_1series.html#a04adb9b939dda140547a027e461a4384" title="Test for single-coefficient series. ">is_single_coefficient()</a>,</li>
<li><a class="el" href="classpiranha_1_1series.html#a97624cbcc7139b6f70682d908f759656" title="Apply functor to single-coefficient series. ">apply_cf_functor()</a>,</li>
<li><a class="el" href="namespacepiranha_1_1math.html#afbd1041a6f6d37325b55a66b7a84c016" title="Exponentiation. ">piranha::math::pow()</a>, <a class="el" href="namespacepiranha_1_1math.html#a00db2c62bd93a48258dd8545c6fb468c" title="Zero test. ">piranha::math::is_zero()</a> and <a class="el" href="namespacepiranha.html#a712714b1e1348f73ec01687d5d5c9b2d" title="Safe cast. ">piranha::safe_cast()</a>,</li>
<li>series multiplication,</li>
<li>memory errors in standard containers,</li>
<li>threading primitives,</li>
<li><a class="el" href="classpiranha_1_1series.html#a4f7e68abc23ec8d71664d463cf83c8e3" title="Hash value. ">hash()</a> or <a class="el" href="classpiranha_1_1series.html#a3303c0cfd2399b9f71570f43e85f8ee3" title="Check for identical series. ">is_identical()</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02103">2103</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad2fc18640bdfa5d96217434a533e0567"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::print_tex </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print in TeX mode. </p>
<p>Print series to stream <code>os</code> in TeX mode. The representation is constructed in the same way as explained in <a class="el" href="classpiranha_1_1series.html#a9f4b6250352b1657f36a0f90e021b6ce" title="Overloaded stream operator for piranha::series. ">piranha::series::operator&lt;&lt;()</a>, but using <a class="el" href="namespacepiranha.html#ac5f03dab82a8f92ec7c42ab6e8bbf735" title="Print series coefficient in TeX mode. ">piranha::print_tex_coefficient()</a> and the key's TeX printing method instead of the plain printing functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>target stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="namespacepiranha.html#ac5f03dab82a8f92ec7c42ab6e8bbf735" title="Print series coefficient in TeX mode. ">piranha::print_tex_coefficient()</a>,</li>
<li>the TeX printing method of the key type,</li>
<li>memory allocation errors in standard containers,</li>
<li><a class="el" href="classpiranha_1_1settings.html#aa493e503accf25b56608b239ba8e9a6f" title="Get max term output. ">piranha::settings::get_max_term_output()</a>,</li>
<li>streaming to <code>os</code> or to instances of <code>std::ostringstream</code>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpiranha_1_1series.html#a9f4b6250352b1657f36a0f90e021b6ce" title="Overloaded stream operator for piranha::series. ">operator&lt;&lt;()</a>. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02481">2481</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5ee2cef7972c1ed1a410351c9f3e175e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename F , typename Series  = Derived, custom_partial_enabler&lt; F, Series &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::register_custom_derivative </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register custom partial derivative. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <a class="el" href="classpiranha_1_1series.html#a816a2a0ef41921df71a9c0f518ddd653" title="Partial derivative. ">piranha::series::partial()</a> is enabled for <code>Derived</code>, and if <code>F</code> is a type that can be used to construct <code>std::function&lt;partial_type(const Derived &amp;)</code>, where <code>partial_type</code> is the type resulting from the partial derivative of <code>Derived</code>.</dd></dl>
<p>Register a copy of a callable <code>func</code> associated to the symbol called <code>name</code> for use by <a class="el" href="namespacepiranha_1_1math.html#ac3959494f64044823fd4c4545a5f3e4a" title="Partial derivative. ">piranha::math::partial()</a>. <code>func</code> will be used to compute the partial derivative of instances of type <code>Derived</code> with respect to <code>name</code> in place of the default partial differentiation algorithm.</p>
<p>It is safe to call this method from multiple threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>symbol for which the custom partial derivative function will be registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>custom partial derivative function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>failure(s) in threading primitives,</li>
<li>lookup and insertion operations on <code>std::unordered_map</code>,</li>
<li>construction and move-assignment of <code>std::function</code>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02217">2217</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac3752460cc7a4c4cc0bea3330b31bcc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::set_symbol_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1symbol__set.html">symbol_set</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Symbol set setter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td><a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a> that will be associated to the series.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the series is not empty. </td></tr>
    <tr><td class="paramname">unspecified</td><td>any exception thrown by the copy assignment operator of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02597">2597</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acae02a113d00a1cd291ac2d8052e1efd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html#a3bd2e6c7089dee8f3d370eda2260013a">size_type</a> <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Series size. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of terms in the series. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l01895">1895</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a259a3dfca6849c5097246a4a0235cc61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpiranha_1_1series.html#a3bd2e6c7089dee8f3d370eda2260013a">size_type</a> <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::table_bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Table bucket count. </p>
<dl class="section return"><dt>Returns</dt><dd>the bucket count of the internal container. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02059">2059</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8cc5c9b27d9dbf3cdca9102eabb09003"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::table_load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Table load factor. </p>
<p>Will call <a class="el" href="classpiranha_1_1hash__set.html#a570ae119865b9bdcde64ff10459b3852" title="Load factor. ">piranha::hash_set::load_factor()</a> on the internal terms container and return the result.</p>
<dl class="section return"><dt>Returns</dt><dd>the load factor of the internal container. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02051">2051</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a57b8b94d7b67c5e91ec9bab039a37f73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sparsity_info_type <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::table_sparsity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Table sparsity. </p>
<p>Will call <a class="el" href="classpiranha_1_1hash__set.html#a947bcba0e0439d1abf15050567034978" title="Get information on the sparsity of the table. ">piranha::hash_set::evaluate_sparsity()</a> on the internal terms container and return the result.</p>
<dl class="section return"><dt>Returns</dt><dd>the output of <a class="el" href="classpiranha_1_1hash__set.html#a947bcba0e0439d1abf15050567034978" title="Get information on the sparsity of the table. ">piranha::hash_set::evaluate_sparsity()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by <a class="el" href="classpiranha_1_1hash__set.html#a947bcba0e0439d1abf15050567034978" title="Get information on the sparsity of the table. ">piranha::hash_set::evaluate_sparsity()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02040">2040</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d2be8f9cd018cea990d8d33ff74b34e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, Derived &gt;(const std::pair&lt; typename <a class="el" href="classpiranha_1_1term.html#a57f783cb7a88b99b743df14ab041a4c2">term_type::cf_type</a>, Derived &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Term transformation. </p>
<p>This method will apply the functor <code>func</code> to each term in the series, and will use the return value of the functor to construct a new series. Terms are passed to <code>func</code> in the same format resulting from dereferencing the iterators obtained via <a class="el" href="classpiranha_1_1series.html#acfeae53f7a213c8aa8c29e9d3f65e4d0" title="Begin iterator. ">piranha::series::begin()</a>, and <code>func</code> is expected to produce a return value of the same type.</p>
<p>The return series is first initialised as an empty series. For each input term <code>t</code>, the return value of <code>func</code> is used to construct a new temporary series from the multiplication of <code>t.first</code> and <code>t.second</code>. Each temporary series is then added to the return value series.</p>
<p>This method requires the coefficient type to be multipliable by <code>Derived</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>transforming functor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformed series.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>the call operator of <code>func</code>,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>the assignment operator of <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>term, coefficient, key construction,</li>
<li>series multiplication and addition.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>require multipliability of cf * Derived and addability of the result to Derived in place. </dd></dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02372">2372</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad92d728b975d0dfda12ad7ddb168c984"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::trim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim. </p>
<p>This method will return a series mathematically equivalent to <code>this</code> in which discardable arguments have been removed from the internal set of symbols. Which symbols are removed depends on the trimming method <code>trim_identify()</code> of the key type (e.g., in a polynomial a symbol can be discarded if its exponent is zero in all monomials).</p>
<p>If the coefficient type is an instance of <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>, <a class="el" href="classpiranha_1_1series.html#ad92d728b975d0dfda12ad7ddb168c984" title="Trim. ">trim()</a> will be called recursively on the coefficients while building the return value.</p>
<dl class="section return"><dt>Returns</dt><dd>trimmed version of <code>this</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>operations on <a class="el" href="classpiranha_1_1symbol__set.html" title="Symbol set. ">piranha::symbol_set</a>,</li>
<li>the trimming methods of coefficient and/or key,</li>
<li><a class="el" href="classpiranha_1_1series.html#ac049565106ddee1881fedf6481de9458" title="Insert term. ">insert()</a>,</li>
<li>term, coefficient and key type construction. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02448">2448</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a40680bb3e8f2801b3754f0b03abb0633"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename Series  = Derived, typename Partial  = partial_type&lt;Series&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::unregister_all_custom_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregister all custom partial derivatives. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <a class="el" href="classpiranha_1_1series.html#a816a2a0ef41921df71a9c0f518ddd653" title="Partial derivative. ">piranha::series::partial()</a> is enabled for <code>Derived</code>.</dd></dl>
<p>Will unregister all custom derivatives currently registered via <a class="el" href="classpiranha_1_1series.html#a5ee2cef7972c1ed1a410351c9f3e175e" title="Register custom partial derivative. ">register_custom_derivative()</a>. It is safe to call this method from multiple threads.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by failure(s) in threading primitives. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02262">2262</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a041b2099313fa16a9b13d55ce7c0d930"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename Series  = Derived, typename Partial  = partial_type&lt;Series&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpiranha_1_1series.html">piranha::series</a>&lt; Cf, Key, Derived &gt;::unregister_custom_derivative </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregister custom partial derivative. </p>
<dl class="section note"><dt>Note</dt><dd>This method is enabled only if <a class="el" href="classpiranha_1_1series.html#a816a2a0ef41921df71a9c0f518ddd653" title="Partial derivative. ">piranha::series::partial()</a> is enabled for <code>Derived</code>.</dd></dl>
<p>Unregister the custom partial derivative function associated to the symbol called <code>name</code>. If no custom partial derivative was previously registered using <a class="el" href="classpiranha_1_1series.html#a5ee2cef7972c1ed1a410351c9f3e175e" title="Register custom partial derivative. ">register_custom_derivative()</a>, calling this function will be a no-op.</p>
<p>It is safe to call this method from multiple threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>symbol for which the custom partial derivative function will be unregistered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li>failure(s) in threading primitives,</li>
<li>lookup and erase operations on <code>std::unordered_map</code>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02243">2243</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a9f4b6250352b1657f36a0f90e021b6ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cf, typename Key, typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpiranha_1_1series.html">series</a>&lt; Cf, Key, Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded stream operator for <a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a>. </p>
<p>Will direct to stream a human-readable representation of the series.</p>
<p>The human-readable representation of the series is built as follows:</p>
<ul>
<li>the coefficient and key of each term are printed adjacent to each other separated by the character "*", the former via the <a class="el" href="namespacepiranha.html#abbd5f3761e6b58233f94b615837ccb84" title="Print series coefficient. ">piranha::print_coefficient()</a> function, the latter via its <code>print()</code> method;</li>
<li>terms are separated by a "+" sign.</li>
</ul>
<p>The following additional transformations take place on the printed output:</p>
<ul>
<li>if the printed output of a coefficient is the string "1" and the printed output of its key is not empty, the coefficient and the "*" sign are not printed;</li>
<li>if the printed output of a coefficient is the string "-1" and the printed output of its key is not empty, the printed output of the coefficient is transformed into "-" and the sign "*" is not printed;</li>
<li>if the key output is empty, the sign "*" is not printed;</li>
<li>the sequence of characters "+-" is transformed into "-";</li>
<li>at most <a class="el" href="classpiranha_1_1settings.html#aa493e503accf25b56608b239ba8e9a6f" title="Get max term output. ">piranha::settings::get_max_term_output()</a> terms are printed, and terms in excess are represented with ellipsis "..." at the end of the output; if <a class="el" href="classpiranha_1_1settings.html#aa493e503accf25b56608b239ba8e9a6f" title="Get max term output. ">piranha::settings::get_max_term_output()</a> is zero, all the terms will be printed.</li>
</ul>
<p>Note that the print order of the terms will be undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">os</td><td>target stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><a class="el" href="classpiranha_1_1series.html" title="Series class. ">piranha::series</a> argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>os</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">unspecified</td><td>any exception thrown by:<ul>
<li><a class="el" href="namespacepiranha.html#abbd5f3761e6b58233f94b615837ccb84" title="Print series coefficient. ">piranha::print_coefficient()</a>,</li>
<li>the <code>print()</code> method of the key type,</li>
<li>memory allocation errors in standard containers,</li>
<li><a class="el" href="classpiranha_1_1settings.html#aa493e503accf25b56608b239ba8e9a6f" title="Get max term output. ">piranha::settings::get_max_term_output()</a>,</li>
<li>streaming to <code>os</code> or to instances of <code>std::ostringstream</code>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="series_8hpp_source.html#l02526">2526</a> of file <a class="el" href="series_8hpp_source.html">series.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="series__fwd_8hpp_source.html">series_fwd.hpp</a></li>
<li><a class="el" href="series_8hpp_source.html">series.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 18 2015 21:06:04 for piranha by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9
</small></address>
</body>
</html>
